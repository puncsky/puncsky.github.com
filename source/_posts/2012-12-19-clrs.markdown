---
layout: post
title: "CLRS Notes"
date: 2012-12-19 01:42
comments: true
categories: algorithm
---


## I Foundations

### 1 The Role of Algorithms in Computing 5 

#### 1.1 Algorithms 5

An algorithm is thus a sequence of computational steps that transform the input into the output.

#### 1.2 Algorithms as a technology 11


lg n < sqrt(n) < n < n lg(n) < n^2 < n^3 < n!

### 2 Getting Started 16

#### 2.1 Insertion sort 16

	void insertionSort(double* A, int size) {
		for (int i = 1; i < size; ++i) {
			double key = A[i];
			int index = i - 1;
			while (index >= 0 && A[index] > key) {
				A[index+1] = A[index];
				-- index;
			}
			A[i+1] = key;
		} 
	}

#### 2.2 Analyzing algorithms 23

insertion sort has a worst-case running time of Θ(n^2)

#### 2.3 Designing algorithms 29

The divide-and-conquer approach and recursive

- Divide: left and right subarrays
- Conquer: recursively sort left and right
- Combine: merge by comparing two numbers from the sorted left and right pair by pair 

c-code:

	//Input:
	//	A array
	//	size size of A
	//	p starting index of the span waiting to be sorted
	//	r ending index of the span waiting to be sorted
	//Procedure:
	//	sort left
	//	sort right
	//	merge by comparing two numbers from the sorted left and right pair by pair
	//Output:
	//	A sorted array 
	void mergeSort(double* A, int size, int p, int r) {
		if (p < r) {
			int q = (p+r)/2;
			mergeSort(A, 10, p, q);
			mergeSort(A, 10, q+1, r);
			merge(A, 10, p, q, r);
		}
	}
	void merge(double* A, int size, int p, int q, int r) {
		// create left and right arrays                                                                                                          
		int span1 = q-p+1;
		int span2 = r-q;
		double* left = reinterpret_cast<double*>(malloc(sizeof(double) * (span1+1)));
		double* right= reinterpret_cast<double*>(malloc(sizeof(double) * (span2+1)));
		for (int i = 0; i < span1; ++i) left [i] = A[p+i];
		for (int i = 0; i < span2; ++i) right[i] = A[q+1+i];
		left [span1] = numeric_limits<double>::max();
		right[span2] = numeric_limits<double>::max();
		for(int k=p, i=0, j=0; k<=r; ++k) {
			if (left[i] <= right[j]) {
				A[k] = left [i];
				++i;	
			} else {
    			A[k] = right[j];
     		   	++j;
  		  	}
		}
		free(left);
		free(right);
	}
	int main() {
		double A[10] = {4.,3.,2.,1.,0.,5.,6.,8.,7.,9.};
		for (int i=0; i<10; ++i)
			cout << A[i];
		cout << endl;
		mergeSort(A, 10, 0, 9);
    	for (int i=0; i<10; ++i)
        	cout << A[i];
    	cout << endl;
	}
 
- Θ(n lg n) but not operate in place


### 3 Growth of Functions 43

#### 3.1 Asymptotic notation 43

- **O()**. When we have only an **asymptotic upper bound**, we use O-notation. 
	- O(g(n)) = {f(n): there exist positive constants c and n0 such that 0 <= f(n) <= c*g(n) for all n >= n0}.
	- if f(n) == c*g(n) is not possible, we use **o()**
- **Θ()**. When we have **both an asymptotic upper bound and an asymptotic lower bound**, we use Θ-notation.
	- Θ(g(n)) = {f(n): there exist positive constants c1, c2, and n0 such that 0 <= c1*g(n) <= f(n) <= c2*g(n) for all n >=  n0}
- **Ω()**, When we have only an **asymptotic lower bound**, we use omega-notation.
	- uppercase_omega(g(n)) = {f(n): there exist positive constants c and n0 such that 0 <= c*g(n) <=  f(n) for all n >= n0}
	- if f(n) == c*g(n) is not possible, we use **ω()**

#### 3.2 Standard notations and common functions 53

### 4 Divide-and-Conquer 65

- Three ways for solving recurrences
	- substitution method
	- recursive-tree method
	- master method
		- T(n) = a*T(n/b) + f(n), a>=1, b>1. It characterizes a divide- and-conquer algorithm that creates _a_ subproblems, each of which is _1/b_ the size of the original problem, and in which the divide and combine steps together take f(n) time.

#### 4.1 The maximum-subarray problem 68

In the stock market, you need to buy low and sell high. But the maximum profit does not always start at the lowest price or end at the highest price. 

##### A brute-force solution

Choose 2 from n pairs of (date, price) and calculate the difference. Θ(n^2)

##### A solution using divide-and-conquer

A transformation: create an array of the daily change in price, and **find the maximum subarray**.

- find the max subarray on the left
- find the max subarray on the right
- find the max subarray crossing the middle
	- find max left, max right, and their sum
- take the max of the above

TODO: codes

Θ(n*lg(n))

#### 4.2 Strassen’s algorithm for matrix multiplication 75

O(n^3) to O(n^2.81)

#### 4.3 The substitution method for solving recurrences

1. Guess the form of the solution.
2. Use mathematical induction to find the constants and show that the solution works.

#### 4.4 The recursion-tree method for solving recurrences 88

depth * height

#### 4.5 The master method for solving recurrences 93

![Master Method](http://puncsky.github.com/images/CLRS/mastermethod.png)

### 5 Probabilistic Analysis and Randomized Algorithms 114

5.1 The hiring problem 114
5.2 Indicator random variables 118
5.3 Randomized algorithms 122
5.4 Probabilistic analysis and further uses of indicator random variables


## II Sorting and Order Statistics Introduction 147

<table>
  <tr>
    <th></th>
    <th>worst-case running time</th>
    <th>average-cased running time</th>
  </tr>
  <tr>
    <th>Insertion sort</th>
    <td>Θ(n^2)</td>
    <td>Θ(n^2)</td>
  </tr>
  <tr>
    <th>Merge sort</th>
    <td>Θ(n lg n)</td>
    <td>Θ(n lg n)</td>
  </tr>
  <tr>
    <th>Heapsort</th>
    <td>O(n lg n)</td>
    <td>-</td>
  </tr>
  <tr>
    <th>Quicksort</th>
    <td>Θ(n^2)</td>
    <td>Θ(n lg n) (*)</td>
  </tr>
  <tr>
    <th>Counting sort</th>
    <td>Θ(k+n)</td>
    <td>Θ(k+n)</td>
  </tr>
  <tr>
    <th>Radix sort</th>
    <td>Θ(d(n+k))</td>
    <td>Θ(d(n+k))</td>
  </tr>
  <tr>
    <th>Bucket sort</th>
    <td>Θ(n^2)</td>
    <td>Θ(n) </td>
  </tr>
</table>

### 6 Heapsort 151

O(n lg n),Our heap data structure is not garbage-collected storage.

	#include <iostream>
	#include <cstdlib>

	template <class T>
	class Heap
	{
	public:
	    Heap():m_array(0), m_size(0), m_maxSize(0){}
	    Heap(int maxSize);
	    ~Heap(){delete [] m_array;}
	    bool insert(T item);
	    bool isEmpty();
	    T fetchMax();
	    void deleteMax();
	    void display();
	    //Transfer Array<T> to a heap
	    void arrayToHeap(T* array, int size); 
	    //Sort the heap
	    void heapSort();

	private:
	    void locate_down(int start, int end);
	    void locate_up(int start, int end);

	private:
	    T* m_array;
	    int m_size;//num of elem stored
	    int m_maxSize;//allocated memory
	};

	template <class T>
	Heap<T>::Heap(int maxSize)
	{
	    m_array=new T[maxSize+1];
	    m_size=0;
	    m_maxSize=maxSize;
	}

	template <class T>
	T Heap<T>::fetchMax()
	{
	    return m_array[1];
	}

	template <class T>
	bool Heap<T>::isEmpty()
	{
	    return m_size==0;
	}

	template <class T>
	void Heap<T>::locate_down(int start, int end)
	{
	    int c=start*2;
	    int temp;
	    while(c<=end)
	    {
	        if((c<end) && (m_array[c]<m_array[c+1])) //Pick the larger one in both childs. ATTENTION: c==end is not approved!!
	            c=c+1
	        if(m_array[start]<m_array[c])
	        {
	            temp=m_array[start];
	            m_array[start]=m_array[c];
	            m_array[c]=temp;
	        }
	        start=c;
	        c=2*c;
	    }
	}

	template <class T>  //overlap the top with the bottom, decrease the size, and locate_down
	void Heap<T>::deleteMax()
	{
	    m_array[1]=m_array[m_size];
	    --m_size;
	    locate_down(1,m_size);
	}

	template <class T>
	void Heap<T>::locate_up(int start, int end)
	{
	    int loc=end;
	    int parent=end/2;
	    int temp;
	    while(parent>=start && m_array[loc]<m_array[parent])
	    {
	        temp=m_array[loc];
	        m_array[loc]=m_array[parent];
	        m_array[parent]=temp;
	        loc=parent;
	        parent=loc/2;
	    }
	}

	template <class T>
	bool Heap<T>::insert(T item)
	{
	    if(m_size==m_maxSize)
	    {
	        std::cerr<<"Heap is full";
	        this->~Heap();
	        return 0;
	    }
	    ++m_size;
	    m_array[m_size]=item;
	    locate_up(1, m_size);
	    return true;
	}

	template <class T>
	void Heap<T>::display()
	{
	    for(int i=1; i<=m_size; i++)
	        std::cout<<m_array[i]<<" ";
	    std::cout<<std::endl;
	}

	template <class T>
	void Heap<T>::arrayToHeap(T* array, int size)
	{
	    m_maxSize=size;
	    m_array=new T[m_maxSize+1];
	    for(int i=1; i<=size; ++i)
	        this->insert(array[i-1]);
	    this->heapSort();
	    for(int i=1; i<size; ++i)
	        array[i-1]=m_array[i];
	}

	template <class T>
	void Heap<T>::heapSort()
	{
	    T temp;
	    int i;
	    for(i=m_size; i>=2; --i)
	    {
	        temp=m_array[1];
	        m_array[1]=m_array[i];
	        m_array[i]=temp;
	        locate_down(1, i-1);
	    }
	}


#### 6.1 Heaps 151

The (binary) heap data structure is an array object that we can view as a nearly complete binary tree.

	// calculate by shifting the binary representation
	int parent(i) {
		return i/2;
	}
	int left(i) {
		return 2*i;
	}
	int right(i) {
		return 2*i + 1;
	}

- max-heap: for every node _i_ other than the root, A[parent(i)]>=A[i].
- min-heap: for every node _i_ other than the root, A[parent(i)]<=A[i].
- height of a node: number of edges on the longest simple downward path from the node to a leaf.
- height of the heap: height of its root. Θ(lg n)

#### 6.2 Maintaining the heap property 154

	// Input:
	// 		A array
	//		i index
	//   Binary trees rooted at left(i) and right(i) are max-heaps
	//   but A[i] might be smaller than its children. 
	// Procedure:
	//		exchange A[i] with the larger one between A[left[i]] and A[right[i]]
	//		maxHeapify the new sub tree
	// Output:
	//		This routine lets the value at A[i] float down in the max-heap. 
	maxHeapify(A, i) {
		TODO;
	}

T(n) <= T(2*n/3) + Θ(1), T(n) = O(lg n) = O(height)

#### 6.3 Building a heap 156

conduct maxHeapify upon the array from the rear to the head

O(n)

#### 6.4 The heapsort algorithm 159

build max-heap, exchange the root with the end of heap, and maxHeapify the rest of the heap.

#### 6.5 Priority queues 162

one of the most popular applications of a heap: as an efficient priority queue. It can be used to schedule jobs on a shared computer. Highest-priority job first.

	#include <iostream>
	template <class T>
	class PrioQueue //Min Heap
	{
	public:
	    PrioQueue(int mSize=20);
	    ~PrioQueue(){delete [] q;}
	    bool IsEmpty() const {return size==0;}
	    bool IsFull() const {return size==maxSize;}
	    bool Append(const T &x);
	    bool Serve(T &x);
	private:
	    void AdjustDown(int start, int end);
	    void AdjustUp(int start, int end);
	    T *q;
	    int size, maxSize;
	};

	template <class T>
	PrioQueue<T>::PrioQueue(int mSize)
	{
	    maxSize=mSize;
	    size=0;
	    q=new T[maxSize];
	}

	template <class T>
	void PrioQueue<T>::AdjustDown(int start, int end)
	{
	    if(start<end)
	    {
	        int parent=start;
	        int child=2*parent+1;
	        while(child<=end)
	        {
	            if((child<end)&&(q[child]>q[child+1]))
	                child=child+1;
	            if(q[parent]>q[child])
	            {
	                T temp=q[parent];
	                q[parent]=q[child];
	                q[child]=temp;
	            }
	            else break;
	            parent=child;
	            child=2*parent+1;
	        }
	    }
	}

	template <class T>
	void PrioQueue<T>::AdjustUp(int start, int end)
	{
	    if(start<end)
	    {
	        int child=end;
	        int parent=(child-1)/2;
	        while((parent>=start)&& (q[parent]>q[child]))
	        {
	                T temp=q[parent];
	                q[parent]=q[child];
	                q[child]=temp;
	                child=parent;
	                parent=(child-1)/2;
	        }
	    }
	}

	template <class T>
	bool PrioQueue<T>::Append(const T &x)
	{
	    if(this->IsFull())
	    {
	        //throw std::Overflow;
	        std::cout<<"overflow"<<std::endl;
	       return(0); 
	    }
	    size++;
	    q[size-1]=x;
	    this->AdjustUp(0, size-1);//ATTENTION: n-1
	}

	template <class T>
	bool PrioQueue<T>::Serve(T &x)
	{
	    if(this->IsEmpty())
	    {
	        //throw std::Underflow;
	        return(0);
	    }
	    x=q[0];
	    q[0]=q[size-1];
	    q[size-1]=0;
	    size--;
	    this->AdjustDown(0, size-1); //ATTENTION: n-1
	    std::cout<<"After AdjustDown:"<<q[0]<<q[1]<<q[2]<<q[3]<<q[4]<<std::endl;
	}


### 7 Quicksort 170

Despite this slow worst-case running time Θ(n^2) , quicksort is often **the best practical choice** for sorting because it is remarkably efficient on the average: its expected running time is _Θ(n lg n)_, and the **constant factors hidden in the _Θ(n lg n)_ notation are quite small**. 

### 7.1 Description of quicksort 170

Divide-and-conquer paradigm

- Divide: element A[q] and subarrays on the left and right, s.t. left <= A[q] <= right
- Conquer: recursively sort left and right
- Combine: NULL
 
quickSort.cxx

	#include <iostream>
	using namespace std;

	int partition(double* A, int p, int r) ;
	int quickSort(double* A, int p, int r) ;

	void quickSort(double* A, int p, int r) {
	    if (p < r) {
	        int q = partition(A, p, r);
	        quickSort(A, p, q-1);
	        quickSort(A, q+1, r);
	    }
	}
	// pick A[r] as the flag
	// i for the left array <= A[r]
	// j for iterating the whole array 
	// finally, exchange A[r] in the middle
	// return the new middle index
	int partition(double* A, int p, int r) {
	    double x = A[r];
	    int i = p - 1;
	    for (int j = p; j <= r-1; ++j) 
	        if (A[j] <= x) {
	            ++ i;
	            double tmp = A[i]; A[i] = A[j]; A[j] = tmp;
	        }
	    double tmp = A[i+1]; A[i+1] = A[r]; A[r] = tmp;
	    return i+1;
	}

	int main() {
	    double A[10] = {8,1,3,2,4,7,5,6,9,0};
	    for (int i = 0; i < 10; ++i) cout << A[i];
	    cout << endl;
	    quickSort(A, 0, 9);
	    for (int i = 0; i < 10; ++i) cout << A[i];
	    cout << endl;
	    return 0;
	}



#### 7.2 Performance of quicksort 174

- Worst-case partitioning: the partitioning routine produces one subproblem with _n-1_ elements and one with _0_ elements.
	- T(n) = T(n-1) + T(0) + Θ(n)
	- Θ(n^2)
- Best-case partitioning: even possible split
	- T(n) = 2T(n/2) + Θ(n)
	- Θ(n lg n)
- Balanced partitioning: Any split of constant proportionality yields a recursion tree of depth Θ(lg n), where the cost at each level is O(n).
- Average case: PARTITION produces a mix of “good” and “bad” splits.
	- TODO

#### 7.3 A randomized version of quicksort 179

pick the flag in the partition routine randomly (exchange with the one at the rear)

#### 7.4 Analysis of quicksort 180

### 8 Sorting in Linear Time 191

**comparison sorts**: merge sort, heapsort, and quicksort sharing, **must make Ω(n lg n) comparisons in the worst case** to sort _n_ elements. 

However, counting sort, radix sort, and bucket sort...

#### 8.1 Lower bounds for sorting 191

#### 8.2 Counting sort 194

counting sort assumes that the input consists of integers in a small range

Create an extra array to record the occurrence of these number and put them back into a new array as the result. We usually use counting sort when we have k = O(n), in which case the running time is Θ(n).

#### 8.3 Radix sort 197

TODO? 感觉像counting sort，只不过是存了整个数，而不是数数的个数

[Radix sort tutorial](http://cubic.org/docs/radix.htm)

- _source_: List of bytes
- _source\_n_: number of bytes to sort
- _dest[256]_: 256 lists of bytes. each list should have enough space to hold source_n elements. 

a pseudo-code would sort the list this way:

	for i=0 to source_n do
	   dest[source[i]].append(source[i])

#### 8.4 Bucket sort 200

bucket sort assumes that the input is generated by a random process that distributes elements uniformly and independently over the interval [0, 1). 

Bucket sort divides the interval [0, 1) into n equal-sized subintervals, or buckets, and then distributes the n input numbers into the buckets. Since the inputs are uniformly and independently distributed over [0, 1), we do not expect many numbers to fall into each bucket. To produce the output, we simply sort the numbers in each bucket (e.g. insertion sort) and then go through the buckets in order, listing the elements in each.

Θ(n)

### 9 Medians and Order Statistics 213

**Selection problem** selects _i-st_ largest number among a set _A_ of _n_ (distinct) numbers

#### 9.1 Minimum and maximum 214

How to find the min in A? Best way is to iterate it once (_n-1_ comparisons).

How to find min and max simultaneously? In fact, we can find both the minimum and the maximum using at most 3*n/2 comparisons. 每次取一对，自己先比较，然后大的跟max比，小的跟min比，总共只需要比3*n/2次。

#### 9.2 Selection in expected linear time 215

randomizedSelect.cxx

	#include <iostream>
	using namespace std;

	int randomizedSelect(double* A, int p, int r, int i) ;
	int randomizedPatition(double* A, int p, int r) ;
	int partition(double* A, int p, int r) ;

	// ----------------------------------------------------------------------------
	// select i-st largest number from A[p] to A[r]
	int randomizedSelect(double* A, int p, int r, int i) {
	    if (p == r) 
	        return A[p];
	    int q = randomizedPatition(A, p, r);
	    int k = q-p+1;
	    if (i == k) // the pivot value is the answer
	        return A[q];
	    else if (i < k) // on the left
	        return randomizedSelect(A, p, q-1, i);
	    else            // on the right
	        return randomizedSelect(A, q+1, r, i-k);
	}
	// ----------------------------------------------------------------------------
	// get the index of the number in the middle 
	// s.t. subarray on the left <= A[index] <= subarray on the right
	int randomizedPatition(double* A, int p, int r) {
	    int i = random()%(p-r+1) + p;
	    double tmp = A[i]; A[i] = A[r]; A[r] = tmp;
	    return partition(A, p, r);
	}
	// ----------------------------------------------------------------------------
	// pick A[r] as the flag
	// i for the left array <= A[r]
	// j for iterating the whole array 
	// finally, exchange A[r] in the middle
	// return the new middle index
	int partition(double* A, int p, int r) {
	    double x = A[r];
	    int i = p - 1;
	    for (int j = p; j <= r-1; ++j) 
	        if (A[j] <= x) {
	            ++ i;
	            double tmp = A[i]; A[i] = A[j]; A[j] = tmp;
	        }
	    double tmp = A[i+1]; A[i+1] = A[r]; A[r] = tmp;
	    return i+1;
	}
	// ----------------------------------------------------------------------------
	int main() {
	    double A[10] = {8,1,3,2,4,7,5,6,9,0};
	    for (int i = 0; i < 10; ++i) cout << A[i];
	    cout << endl;
	    cout << randomizedSelect(A, 0, 9, 5) << endl;
	    return 0;
	}


E[T(n)] = O(n)

#### 9.3 Selection in worst-case linear time 220

O(n)

## III Data Structures
Introduction 229
### 10 Elementary Data Structures 232
10.1 Stacks and queues 232
10.2 Linked lists 236
10.3 Implementing pointers and objects 241 10.4 Representing rooted trees 246
### 11 Hash Tables 253
11.1 Direct-address tables 254 11.2 Hash tables 256
11.3 Hash functions 262
11.4 Open addressing 269
11.5 Perfect hashing 277