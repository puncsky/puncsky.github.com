---
layout: post
title: "Cracking the Coding Interview"
date: 2012-12-23 21:57
comments: true
categories: playground
published: false
---

## Interview Overview

1.**不求无错，但求比人好**

2.真实的面试题和学术算法书上的很不一样

3.algorithm questions, behavioral questions, trivia questions.

6.screening interview(phone): write on paper and read it back over the phone. on-site: 4~6 in-person interviews (one lunch interview, not technical)

7.prior experience(留下好印象 interviewer 会认为你聪明而忽略小错误), culture fit, coding skills, analytical ability

- 做一个好相处的人
- 关于简历的问题必须准备
- 主要关注算法题
- Practicing without a compiler
- Behavior questions really matters: impression! 
- Mock interview
- Don't memorize solutions. Solve problems all by yourself. Quality beats quantity.
- 把脑海中的想法说出来，不沟通=没进展
- take your time
- 编程好风格
- 测试
- 仔细改错
- 不害怕
- TODO??告诉面试官这题我见过

## Interview Questions

[Solutions with C++ at github.com](https://github.com/puncsky/playground/tree/master/careercup)

- Runner technique for linked list: iterate through the linked list with two (fast and slow) pointers simultaneously. 
- All recursive algorithms can be implemented iteratively.

- `x & (~0 << n)` clears the n rightmost bits of x. `~0` is not 1 but 111...1.

### 6 Brain teasers

start talking, and showing how you tackle the problem. Write down the rules you have found.

### 9 Recursion and DP

- Buttom-up recursion, start with a simple case
- Top-down recursion, how to divide the problem for case N into subproblems
- DP
	- rarely asked
	- solve like recursion. The ***only difference*** is that intermediate results are cached for future calls
- discuss the trade-offs between recursive & iterative solutions with your interview

### 10 Scalability and Memory Limits

- 理想情况 -> 实际情况 -> 解决问题
- Typical Capacity:
	- Hard Drive Space
	- Memory
	- Internet Transfer Latency
	
### Databases

- Normalized: minimize redundancy. 
- Denormalized: optimize read time.

### Resume

 
### Companies

#### Amadeus IT Group

- AMADEUS DATA PROCESSING GMBH
	- Amadeus Data Processing GmbH processes data. The company operates and maintains the systems and network for all Amadeus Technology Group SA products. Amadeus Data Processing GmbH was founded in 1990 and is headquartered in Erding-Aufhausen, Germany. Amadeus Data Processing GmbH operates as a subsidiary of Amadeus IT Holding SA.
- C++ and JAVA
- Process and thread
	- The typical difference is that threads (of the same process) run in a shared memory space, while processes run in separate memory spaces.
	- Do you know segments in which program gets divided?
		- all Stack, Data, Code, Heap
	- So tell me which segment thread share?
		- threads share all segments except the stack. Threads have independent call stacks, however the memory in other thread stacks is still accessible and in theory you could hold a pointer to memory in some other thread's local stack frame.
- Design patterns (BINGO!!)
	- Decorator: TODO
- stacks vs heaps allocations

#### ABB

- ABB is a global leader in **power and automation technologies** which enable utility and industry customers to improve their performance while lowering environmental impact. 
- Not for IT, not match. Just chat.

#### Google

std::string serialize(const std::vector<std::string>& input) ;
std::vector<std::string> deserialize(const std::string& serialized) ;

Memory leak, valgrind, priciples

##### Phone Interview

##### 1 Skip list 

[Skip list](http://en.wikipedia.org/wiki/Skip_list), 写code实现`struct skip_list * find(struct skip_list *head, int value)`

	struct Skip_list {
		int val;
		vector<skip_list*> links;
	};
	struct Skip_list* find(struct Skip_list* head, int value) {
		assert(head);
		Skip_list* pCur = head;
		int nIndex = head->links.size() - 1;
		// from top to bottom
		while (nIndex >= 0) {
			if (pCur->val == value) 
				return pCur;
			if (pCur->links[nIndex] == NULL || pCur->links[nIndex]->val > x) // move to below
				nIndex--;
			else 
				pCur = pCur->links[nIndex]; // move to right
		}
		return NULL;
	}
	// O(log n)

##### 2 find range

sorted array with repeated elements for given element, find out its range. e.g. A A B B B B B C C D D E F G, given B, the output should be [2, 6] binary search的变种

	pair<size_t, size_t> findRange(vector<char> a, char target) {
		size_t found = binarySearch(a, target);
		size_t left = right = found;
		while (left >=0 && a[left] == target) left--;
		while (right < a.size() && a[right] == target) right++;
		return pair<size_t, size_t>(left+1, right-1);
	}
	size_t binarySearch(vector<char> a, char target) {
		size_t begin = 0, end = a.size()-1;
		while (begin <= end) {
			size_t mid = (begin+end)/2;
			if (a[mid] == target) return mid;
			else if (a[mid] > target) {
				end = mid - 1;
			} else if (a[mid] < target) {
				begin = mid + 1;
			}
		}
		return 0;
	}
	// O(logn + k)

##### 3 

number of unique url accesses in huge log files 

	int main() {
	    ifstream f("./logs");
	    string s;
	    map<string, int> urls;
	    while(getline(f, s)) {
	        urls.insert(pair<string, int>(s, 1));
	    }   
	    f.close();
	    cout << urls.size() << endl;
	}

hashtable 讨论hash的实现

- What makes a good hash function? less collisions
	- 分配到m个slot的概率相等，且与其他hash value无关
	- 跟自己内部的pattern无关
- Implementation?
	- Non open addressing
		- Division method `h(k) = k mod m`.
		- Multiplication method `h(k) = ⦏m(kA mod 1)⦎`
		- Universal hashing
	- Open addressing (No chaining)
		- linear probing
		- quadratic probing 二介多项式
		- double hashing
##### bit count

How to count the number of set bits in a 32-bit integer?

	long count_bits(long n) {     
	  unsigned int c; // c accumulates the total bits set in v
	  for (c = 0; n; c++) 
	    n &= n - 1; // clear the least significant bit set
	  return c;
	}


#### Onsite

##### 1 爬楼梯

爬楼梯一次可以走一级或者两级，爬N级有多少种走法

	1, 2, 3, 5, 8, 13, ... fibonacci sequence 
	F(n)=(1/√5)*{[(1+√5)/2]^n - [(1-√5)/2]^n}

	// write code for fibonacci sequence
	int fib(int n, vector<int>& hist) {
		if (n==1) {return 1;}
		if (n==2) {return 2;}
		if (!hist[n-2]) hist[n-2] = fib(n-2, hist);
		if (!hist[n-1]) hist[n-1] = fib(n-1, hist);
		hist[n] = hist[n-1] + hist[n-2];
		return hist[n];
	}

##### 2 文件读写

有个封装好的函数 `int block_reader(char *buf)` 内部有个静态文件指针，只能向文件末尾移动，不能rewind 每次只能读取4K的block到buf里，返回读取的字节数（除非到文件尾，否则总是4K）要求实现 `int anysize_reader(char *buf, int size)` 从文件的当前位置读取任意大小的数据存入buf，并返回实际读到的数据字节数白板写code 

问题的关键在于anysize_reader会被多次调用，每次都可能不是4K对齐所以需要自己维护一个4K的buffer


##### 3 URL Shortener

From www.puncsky.com to goo.gl/Z0Ofm

1. 62 characters = lowercase + uppercase + numbers -> almost 6bit/char
2. 128bit MD5
3. divide by shortened url length

#### 4 float sqrt(float n)

	float sqrt(float num) {
		float b = 0;
		float e = num;
		float mid = 0;
		while (mid*mid - num > 0.000001 || mid*mid - num < -0.000001) {
			mid = (b+e)/2;
			if (mid*mid > num) {
				e = mid;
			} else {
				b = mid;
			}
		}
		return mid;
	}

#### 5 实现分布的LRU cache，要求存取时间O(1)
DHT + (double linked list + `hash_map`) LRU cache

#### 6 simplify unix file path

Unix file path化简，写code
例如 /a/./b/../../c/ ，化简为 /c/
用stack或者d-queue，有些细节需要考虑，例如 /..//.. 还是输出 /






Sorting: Know how to sort. Don't do bubble-sort. You should know the details of at least one n*log(n) sorting algorithm, preferably two (say, quicksort and merge sort). Merge sort can be highly useful in situations where quicksort is impractical, so take a look at it.

1. comparison sorts
	- merge sort O(nlogn)
	- quick sort O(nlogn) (partition sort) worst-case O(n^2)
	- heap sort O(nlogn)
2. non-comparison sorts: counting sort, radix sort, and bucket sort

Sample code

	void mergeSort(int* a, int b, int e) {
		if (b>=e) return;
		int mid = (b+e)/2;
		mergeSort(a, b, mid);
		mergeSort(a, mid+1, e);
		// merge
		int* left = new int[mid-b+2];
		int* right= new int[e-mid+1];
		for (int i = b; i <= mid; i++) {
			left[i-b] = a[i];
		}
		left[mid-b+1] = INT_MAX;
		for (int i = mid+1; i <= e; i++) {
			right[i-mid-1] = a[i];
		}
		right[e-mid] = INT_MAX;
		int j = 0, k = 0;
		for (int i = b; i <= e; i++) {
			a[i] = (left[j]<right[k])?left[j++]:right[k++];
		}
		delete[] left;
		delete[] right;
	}
  
	void qSort(int* a, int b, int e) {
		if (b>=e) return;
		// partition
		int midVal = a[e];
		int j = b;
		for (int i = b; i <= e; i++) {
			if (a[i] <= midVal) {
				int tmp = a[i]; a[i] = a[j]; a[j] = tmp;
				j++;
			}
		}
		qSort(a, b, j-2);
		qSort(a, j, e);
	}

	void maxHeaplify(int*a, int i) {
		int left = 2*i;
		int right= 2*i+1;
		int largest = (left<=a[0] && a[left] > a[i])?left:i;
		largest = (right<=a[0] && a[right] > a[largest])?right:largest;
		if (largest != i) {
			int tmp = a[largest]; a[largest] = a[i]; a[i] = tmp;
			maxHeaplify(a, largest);
		}
	} 
	void buildMaxHeap(int* a) {
		for (int i = a[0]/2; i >= 1; i--) {
			maxHeaplify(a, i);
		}
	}
	void heapSort(int* a) {
		for (int i = a[0]; i >= 2; i--) {
			buildMaxHeap(a);
			int tmp = a[1]; a[1] = a[i]; a[i] = tmp;
			a[0] --;
		}
	}
	

Hashtables: Arguably the single most important data structure known to mankind. You absolutely should know how they work. Be able to implement one using only arrays in your favorite language, in about the space of one interview.

Trees: Know about trees; basic tree construction, traversal and manipulation algorithms. Familiarize yourself with binary trees, n-ary trees, and trie-trees. Be familiar with at least one type of balanced binary tree, whether it's a red/black tree, a splay tree or an AVL tree, and know how it's implemented. Understand tree traversal algorithms: BFS and DFS, and know the difference between inorder, postorder and preorder.

Graphs: Graphs are really important at Google. There are 3 basic ways to represent a graph in memory (objects and pointers, matrix, and adjacency list); familiarize yourself with each representation and its pros & cons. You should know the basic graph traversal algorithms:     breadth-first search and depth-first search. Know their computational complexity, their tradeoffs, and how to implement them in real code. If you get a chance, try to study up on fancier algorithms, such as Dijkstra and A*.

Other data structures: You should study up on as many other data structures and algorithms as possible. You should especially know about the most famous classes of NP-complete problems, such as traveling salesman and the knapsack problem, and be able to recognize them when an interviewer asks you them in disguise. Find out what NP-complete means.

Mathematics: Some interviewers ask basic discrete math questions. This is more prevalent at Google than at other companies because we are surrounded by counting problems, probability problems, and other Discrete Math 101 situations. Spend some time before the interview refreshing your memory on (or teaching yourself) the essentials of combinatorics and probability. You should be familiar with n-choose-k problems and their ilk – the more the better.

Operating Systems: Know about processes, threads and concurrency issues. Know about locks and mutexes and semaphores and monitors and how they work. Know about deadlock and livelock and how to avoid them. Know what resources a processes needs, and a thread needs, and how context switching works, and how it's initiated by the operating system and underlying hardware. Know a little about scheduling. The world is rapidly moving towards multi-core, so know the fundamentals of "modern" concurrency constructs.

- How to avoid deadlock?
	- impose an order in which locks can be obtained.
	- require threads to pre-declare their locking needs
	- abort threads rather than blocking them in certain situations
- How to detect deadlock?
	- timeouts
	- explicit checking "waits-for graph"