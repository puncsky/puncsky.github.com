---
layout: post
title: "Algorithm Design"
date: 2013-01-07 16:52
comments: true
categories: algorithm
published: false
---

## 1 Introduction: Some Representative Problems 1
#### 1.1 A First Problem: Stable Matching 1
#### 1.2 Five Representative Problems 12
##### Solved Exercises 19
##### Exercises 22
##### Notes and Further Reading 28

## 2 Basics of Algorithm Analysis
2.1 Computational Tractability 29
2.2 Asymptotic Order of Growth 35
2.3 Implementing the Stable Matching Algorithm Using Lists and
Arrays 42
2.4 A Survey of Common Running Times 47
2.5 A More Complex Data Structure: Priority Queues 57
Solved Exercises 65
Exercises 67
Notes and Further Reading 70

## 3 Graphs
29
3.1 Basic Definitions and Applications 73
3.2 Graph Connectivity and Graph Traversal 78
3.3 Implementing Graph Traversal Using Queues and Stacks 87
3.4 Testing Bipartiteness: An Application of Breadth-First Search 94
3.5 Connectivity in Directed Graphs 97
3.6 Directed Acyclic Graphs and Topological Ordering Solved Exercises 104
Exercises 107
Notes and Further Reading 112

## 4 Greedy Algorithms 115

4.1 Interval Scheduling: The Greedy Algorithm Stays Ahead 116 4.2 Scheduling to Minimize Lateness: An Exchange Argument 125 4.3 Optimal Caching: A More Complex Exchange Argument 131 4.4 Shortest Paths in a Graph 137
4.5 The Minimum Spanning Tree Problem 142
4.6 Implementing Kruskal’s Algorithm: The Union-Find Data
Structure 151 4.7 Clustering 157
4.8 Huffman Codes and Data Compression 161
∗ 4.9 Minimum-Cost Arborescences: A Multi-Phase Greedy

## 5 Divide and Conquer 209
5.1 A First Recurrence: The Mergesort Algorithm
5.2 Further Recurrence Relations 214
5.3 Counting Inversions 221
5.4 Finding the Closest Pair of Points 225
5.5 Integer Multiplication 231
5.6 Convolutions and the Fast Fourier Transform
Solved Exercises 242
Exercises 246
Notes and Further Reading 249

## 6 Dynamic Programming 251

6.1 Weighted Interval Scheduling: A Recursive Procedure
6.2 Principles of Dynamic Programming: Memoization or Iteration
over Subproblems 258
6.3 Segmented Least Squares: Multi-way Choices 261
6.4 Subset Sums and Knapsacks: Adding a Variable 266
6.5 RNA Secondary Structure: Dynamic Programming over
Intervals 272
6.6 Sequence Alignment 278
6.7 Sequence Alignment in Linear Space via Divide and
Conquer 284
6.8 Shortest Paths in a Graph 290
6.9 Shortest Paths and Distance Vector Protocols
297
∗ 6.10
Negative Cycles in a Graph Solved Exercises 307 Exercises 312
Notes and Further Reading
301
335

## 7 Network Flow 337
7.1 The Maximum-Flow Problem and the Ford-Fulkerson Algorithm 338
7.2 Maximum Flows and Minimum Cuts in a Network 346
7.3 Choosing Good Augmenting Paths 352
∗ 7.4 The Preflow-Push Maximum-Flow Algorithm 357
7.5 A First Application: The Bipartite Matching Problem 367 7.6 Disjoint Paths in Directed and Undirected Graphs 373 7.7 Extensions to the Maximum-Flow Problem 378
7.8 Survey Design 384
7.9 Airline Scheduling 387
7.10 Image Segmentation
7.11 Project Selection 396 7.12 Baseball Elimination 400
391
∗ 7.13 A Further Direction: Adding Costs to the Matching Problem 404 Solved Exercises 411
Exercises 415
Notes and Further Reading 448

## 8 NP and Computational Intractability 451
8.1 Polynomial-Time Reductions 452
8.2 Reductions via “Gadgets”: The Satisfiability Problem
8.3 Efficient Certification and the Definition of NP 463
8.4 NP-Complete Problems 466
8.5 Sequencing Problems 473
8.6 Partitioning Problems 481
8.7 Graph Coloring 485