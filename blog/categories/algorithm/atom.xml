<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | CS Notebook]]></title>
  <link href="http://puncsky.github.com/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://puncsky.github.com/"/>
  <updated>2013-05-14T02:28:52-04:00</updated>
  <id>http://puncsky.github.com/</id>
  <author>
    <name><![CDATA[Tian]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CLRS 2: Advanced]]></title>
    <link href="http://puncsky.github.com/blog/2013/01/08/clrs-2-advanced/"/>
    <updated>2013-01-08T16:43:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2013/01/08/clrs-2-advanced</id>
    <content type="html"><![CDATA[<h2>IV Advanced Design and Analysis Techniques Introduction 357</h2>

<ul>
<li>Three important but more sophisticated techniques used in designing and analyzing efficient algorithms:

<ol>
<li>dynamic programming

<ul>
<li>used to optimize problems in which we make a set of choices to get optimal solution</li>
<li>store the solution to each such subproblem in case it should reappear.</li>
</ul>
</li>
<li>greedy algorithms

<ul>
<li>used to optimize problems in which we make a set of choices to get optimal solution</li>
<li>make each choice in a locally optimal manner. e.g. 买东西找钱算法</li>
<li>matroid theory as a mathematical basis</li>
</ul>
</li>
<li>amortized analysis

<ul>
<li>used to analyze certain algorithms that perform a sequence of similar operations.</li>
<li>Bound the cost of the entire sequence s.t. although some operations might be expensive, many others might be cheap.</li>
</ul>
</li>
</ol>
</li>
<li>We have covered before:

<ol>
<li>Divide-and-conquer</li>
<li>Randomization</li>
<li>Recurrence</li>
</ol>
</li>
</ul>


<h3>15 Dynamic Programming 359</h3>

<ul>
<li>Divide-and-conquer: subproblems are disjoint</li>
<li>Dynamic Programming: subproblems overlap.

<ul>
<li>solve subproblems just once and save it in a table, avoiding recomputing</li>
<li>applied to <strong>optimization problems</strong>: find <strong><em>a</em></strong> solution with the optimal (min/max) value</li>
<li>four steps:

<ol>
<li>Characterize the structure of an optimal solution.</li>
<li>Recursively define the value of an optimal solution.</li>
<li>Compute the value of an optimal solution, typically in a bottom-up fashion (get the result)</li>
<li>Construct an optimal solution from computed information (get how to compute the result)</li>
</ol>
</li>
</ul>
</li>
</ul>


<h4>15.1 Rod cutting 360</h4>

<ul>
<li>Input: a rod of length <em>n</em> inches. a table of prices <em>pi</em> for i = 1,2,...,n</li>
<li>Output: max revenue rn</li>
</ul>


<h4>15.2 Matrix-chain multiplication 370</h4>

<h4>15.3 Elements of dynamic programming 378</h4>

<h4>15.4 Longest common subsequence 390</h4>

<h4>15.5 Optimal binary search trees 397</h4>

<h3>16 Greedy Algorithms 414</h3>

<h4>16.1 An activity-selection problem 415</h4>

<h4>16.2 Elements of the greedy strategy 423</h4>

<h4>16.3 Huffman codes 428</h4>

<h4>16.4 Matroids and greedy methods 437</h4>

<h4>16.5 A task-scheduling problem as a matroid 443</h4>

<h3>17 Amortized Analysis 451</h3>

<h4>17.1 Aggregate analysis 452</h4>

<h4>17.2 The accounting method 456</h4>

<h4>17.3 The potential method 459</h4>

<h4>17.4 Dynamic tables 463</h4>

<h2>V Advanced Data Structures Introduction 481</h2>

<h3>18 B-Trees 484</h3>

<p>18.1 Definition of B-trees 488
18.2 Basic operations on B-trees 491 18.3 Deleting a key from a B-tree 499</p>

<h3>19 Fibonacci Heaps 505</h3>

<p>19.1 Structure of Fibonacci heaps 507
19.2 Mergeable-heap operations 510
19.3 Decreasing a key and deleting a node 518 19.4 Bounding the maximum degree 523</p>

<h3>20 van Emde Boas Trees 531</h3>

<p>20.1 Preliminary approaches 532 20.2 A recursive structure 536 20.3 The van Emde Boas tree 545</p>

<h3>21 Data Structures for Disjoint Sets 561</h3>

<p>21.1 Disjoint-set operations 561
21.2 Linked-list representation of disjoint sets 564 21.3 Disjoint-set forests 568
21.4 Analysis of union by rank with path compression 573</p>

<h2>VI Graph Algorithms</h2>

<p>￼Introduction 587</p>

<h3>22 Elementary Graph Algorithms 589</h3>

<h4>22.1 Representations of graphs 589</h4>

<ul>
<li>Sparse graphs: |E| is much less than |V|<sup>2</sup>

<ul>
<li>adjacency list Θ(V+E)</li>
</ul>
</li>
<li>Dense graphs: |E| is close to |V|<sup>2</sup> or when we need to be able to tell quickly if there is an edge connecting two given vertices.

<ul>
<li>adjacency matrices Θ(V<sup>2)</sup></li>
</ul>
</li>
<li>edge (u,v) has attribute ƒ</li>
</ul>


<h4>22.2 Breadth-first search 594</h4>

<ul>
<li>BFS with queue

<ul>
<li><em>u.color</em> (WHITE for ones having not been to, GRAY for ones in the queue, BLACK for ones having been dequeued and enqueued their white neighbors), <em>u.π</em> the predecessor, <em>u.d</em> distance</li>
</ul>
</li>
</ul>


<p>``` cpp BFS_pseudo_code.c</p>

<pre><code>BFS(G, s)
    initialize vertices except source
    initialize the source vertex
    enqueue the source
    while (queue) {
        dequeue u
        for each white neigbor 
            mark attributes
            enqueue
        u.color = BLACK
    }
</code></pre>

<p>```</p>

<h4>22.3 Depth-first search</h4>

<ul>
<li>DFS with recursion (stack)

<ul>
<li> timestamps are integers between 1 and 2 jV j, since there is one discovery event and one finishing event for each of the jV j vertices.</li>
</ul>
</li>
</ul>


<h4>22.4 Topological sort 612</h4>

<ul>
<li>topological sort <strong>with DFS</strong></li>
<li>DAG(directed acyclic graph)</li>
<li>a <strong>topological sort</strong> of a graph as an ordering of its vertices along a horizontal line so that all directed edges go from left to right.</li>
<li>to indicate precedence among events.</li>
<li>TODO 有多个入度为0的</li>
</ul>


<p>``` cpp Toplogical_sort_pseudo_code.c</p>

<pre><code>toplogicalSort(G) {
    call DFS(G) to compute finishing times v.f for each vertex v
    as each vertex is finished, insert it onto the front of a linked list
    return the linked list of vertices
}
</code></pre>

<p>```</p>

<h4>22.5 Strongly connected components 615</h4>

<ul>
<li>decomposing a directed graph into its strongly connected components <strong>with DFS</strong></li>
</ul>


<h3>23 Minimum Spanning Trees 624</h3>

<p>23.1 Growing a minimum spanning tree 625 23.2 The algorithms of Kruskal and Prim 631</p>

<h3>24 Single-Source Shortest Paths 643</h3>

<h4>24.1 The Bellman-Ford algorithm 651</h4>

<p>24.2 Single-source shortest paths in directed acyclic graphs</p>

<h4>24.3 Dijkstra’s algorithm 658</h4>

<ul>
<li>faster than Bellmen-Ford algorithm</li>
</ul>


<p>24.4 Difference constraints and shortest paths 664
24.5 Proofs of shortest-paths properties 671
655</p>

<h3>25 All-Pairs Shortest Paths 684</h3>

<p>25.1 Shortest paths and matrix multiplication 25.2 The Floyd-Warshall algorithm 693 25.3 Johnson’s algorithm for sparse graphs
686 700</p>

<h3>26 Maximum Flow 708</h3>

<h4>26.1 Flow networks 709</h4>

<ul>
<li><strong>Flow networks</strong>. Let directed graph G = (V, E) be a flow network with a capacity function c. Let s be the source of the network, and let t be the sink. A flow in G is a real-valued function f: V*V -> R that satisfies:

<ol>
<li><strong>Capacity constraint</strong>. For all u,v in V, we require 0 &lt;= f(u,v) &lt;= c(u,v)</li>
<li><strong>Flow conservation</strong>. The rate at which material enters a ver- tex must equal the rate at which it leaves the vertex.</li>
</ol>
</li>
<li>Value |f| of a flow f is the total flow out of the source minus the flow into the source. <strong>maximum-flow problem</strong>: we are given a flow network G with source s and sink t, and we wish to find a flow of maximum value.</li>
</ul>


<h4>26.2 The Ford-Fulkerson method 714</h4>

<ul>
<li>dependent on

<ol>
<li>residual networks</li>
<li>augmenting path</li>
<li>cuts</li>
</ol>
</li>
<li>We repeatedly augment the flow until the residual network has no more augmenting paths.</li>
</ul>


<p>26.3 Maximum bipartite matching 732
26.4 Push-relabel algorithms 736
26.5 The relabel-to-front algorithm 748</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CLRS 1: Basics]]></title>
    <link href="http://puncsky.github.com/blog/2013/01/07/clrs-1-basics/"/>
    <updated>2013-01-07T14:55:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2013/01/07/clrs-1-basics</id>
    <content type="html"><![CDATA[<h2>I Foundations</h2>

<h3>1 The Role of Algorithms in Computing 5</h3>

<h4>1.1 Algorithms 5</h4>

<p>An algorithm is thus a sequence of computational steps that transform the input into the output.</p>

<h4>1.2 Algorithms as a technology 11</h4>

<p>lg n &lt; sqrt(n) &lt; n &lt; n lg(n) &lt; n<sup>2</sup> &lt; n<sup>3</sup> &lt; n!</p>

<h3>2 Getting Started 16</h3>

<h4>2.1 Insertion sort 16</h4>

<p>``` cpp</p>

<pre><code>void insertionSort(double* A, int size) {
    for (int i = 1; i &lt; size; ++i) {
        double key = A[i];
        int index = i - 1;
        while (index &gt;= 0 &amp;&amp; A[index] &gt; key) {
            A[index+1] = A[index];
            -- index;
        }
        A[i+1] = key;
    } 
}
</code></pre>

<p>```</p>

<h4>2.2 Analyzing algorithms 23</h4>

<p>insertion sort has a worst-case running time of Θ(n<sup>2)</sup></p>

<h4>2.3 Designing algorithms 29</h4>

<p>The divide-and-conquer approach and recursive</p>

<ul>
<li>Divide: left and right subarrays</li>
<li>Conquer: recursively sort left and right</li>
<li>Combine: merge by comparing two numbers from the sorted left and right pair by pair</li>
</ul>


<p>``` cpp mergeSort.cpp</p>

<pre><code>//Input:
//  A array
//  size size of A
//  p starting index of the span waiting to be sorted
//  r ending index of the span waiting to be sorted
//Procedure:
//  sort left
//  sort right
//  merge by comparing two numbers from the sorted left and right pair by pair
//Output:
//  A sorted array 
void mergeSort(int* a, int b, int e) {
    if (b &lt; e) {
        int mid = (b+e)/2;
        mergeSort(a, b, mid);
        mergeSort(a, mid+1, e);
        // merge
        int* left = new int[mid-b+1 + 1];
        int* right= new int[e-mid + 1];
        for (int i = b; i &lt;= mid; i++) {
            left[i-b] = a[i];
        }
        left[mid+1-b] = INT_MAX;
        for (int i = mid+1; i &lt;= e; i++) {
            right[i-mid-1] = a[i];
        }
        right[e-mid] = INT_MAX;
        int i = 0, j = 0;
        for (int k = b; k &lt;= e; k++) {
            a[k] = (left[i]&lt;=right[j])?(left[i++]):(right[j++]);
        }
        delete[] left;
        delete[] right;
    }
}
</code></pre>

<p>```</p>

<ul>
<li>Θ(n lg n) but not operate in place</li>
</ul>


<h3>3 Growth of Functions 43</h3>

<h4>3.1 Asymptotic notation 43</h4>

<ul>
<li><strong>O()</strong>. When we have only an <strong>asymptotic upper bound</strong>, we use O-notation.

<ul>
<li>O(g(n)) = {f(n): there exist positive constants c and n0 such that 0 &lt;= f(n) &lt;= c*g(n) for all n >= n0}.</li>
<li>if f(n) == c*g(n) is not possible, we use <strong>o()</strong></li>
</ul>
</li>
<li><strong>Θ()</strong>. When we have <strong>both an asymptotic upper bound and an asymptotic lower bound</strong>, we use Θ-notation.

<ul>
<li>Θ(g(n)) = {f(n): there exist positive constants c1, c2, and n0 such that 0 &lt;= c1<em>g(n) &lt;= f(n) &lt;= c2</em>g(n) for all n >=  n0}</li>
</ul>
</li>
<li><strong>Ω()</strong>, When we have only an <strong>asymptotic lower bound</strong>, we use omega-notation.

<ul>
<li>uppercase_omega(g(n)) = {f(n): there exist positive constants c and n0 such that 0 &lt;= c*g(n) &lt;=  f(n) for all n >= n0}</li>
<li>if f(n) == c*g(n) is not possible, we use <strong>ω()</strong></li>
</ul>
</li>
</ul>


<h4>3.2 Standard notations and common functions 53</h4>

<h3>4 Divide-and-Conquer 65</h3>

<ul>
<li>Three ways for solving recurrences

<ul>
<li>substitution method</li>
<li>recursive-tree method</li>
<li>master method

<ul>
<li>T(n) = a*T(n/b) + f(n), a>=1, b>1. It characterizes a divide- and-conquer algorithm that creates <em>a</em> subproblems, each of which is <em>1/b</em> the size of the original problem, and in which the divide and combine steps together take f(n) time.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>4.1 The maximum-subarray problem 68</h4>

<p>In the stock market, you need to buy low and sell high. But the maximum profit does not always start at the lowest price or end at the highest price.</p>

<h5>A brute-force solution</h5>

<p>Choose 2 from n pairs of (date, price) and calculate the difference. Θ(n<sup>2)</sup></p>

<h5>A solution using divide-and-conquer</h5>

<p>A transformation: create an array of the daily change in price, and <strong>find the maximum subarray</strong>.</p>

<ul>
<li>find the max subarray on the left</li>
<li>find the max subarray on the right</li>
<li>find the max subarray crossing the middle

<ul>
<li>find max left, max right, and their sum</li>
</ul>
</li>
<li>take the max of the above</li>
</ul>


<p>TODO: codes</p>

<p>Θ(n*lg(n))</p>

<h4>4.2 Strassen’s algorithm for matrix multiplication 75</h4>

<p>O(n<sup>3)</sup> to O(n<sup>2.81)</sup></p>

<h4>4.3 The substitution method for solving recurrences</h4>

<ol>
<li>Guess the form of the solution.</li>
<li>Use mathematical induction to find the constants and show that the solution works.</li>
</ol>


<h4>4.4 The recursion-tree method for solving recurrences 88</h4>

<p>depth * height</p>

<h4>4.5 The master method for solving recurrences 93</h4>

<p><img src="http://puncsky.github.com/images/CLRS/mastermethod.png" alt="Master Method" /></p>

<h3>5 Probabilistic Analysis and Randomized Algorithms 114</h3>

<p>5.1 The hiring problem 114
5.2 Indicator random variables 118
5.3 Randomized algorithms 122
5.4 Probabilistic analysis and further uses of indicator random variables</p>

<h2>II Sorting and Order Statistics Introduction 147</h2>

<table>
  <tr>
    <th></th>
    <th>worst-case running time</th>
    <th>average-cased running time</th>
  </tr>
  <tr>
    <th>Insertion sort</th>
    <td>Θ(n^2)</td>
    <td>Θ(n^2)</td>
  </tr>
  <tr>
    <th>Merge sort</th>
    <td>Θ(n lg n)</td>
    <td>Θ(n lg n)</td>
  </tr>
  <tr>
    <th>Heapsort</th>
    <td>O(n lg n)</td>
    <td>-</td>
  </tr>
  <tr>
    <th>Quicksort</th>
    <td>Θ(n^2)</td>
    <td>Θ(n lg n) (*)</td>
  </tr>
  <tr>
    <th>Counting sort</th>
    <td>Θ(k+n)</td>
    <td>Θ(k+n)</td>
  </tr>
  <tr>
    <th>Radix sort</th>
    <td>Θ(d(n+k))</td>
    <td>Θ(d(n+k))</td>
  </tr>
  <tr>
    <th>Bucket sort</th>
    <td>Θ(n^2)</td>
    <td>Θ(n) </td>
  </tr>
</table>


<h3>6 Heapsort 151</h3>

<p>O(n lg n),Our heap data structure is not garbage-collected storage.</p>

<p>``` cpp heap.hpp</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

template &lt;class T&gt;
class Heap
{
public:
    Heap():m_array(0), m_size(0), m_maxSize(0){}
    Heap(int maxSize);
    ~Heap(){delete [] m_array;}
    bool insert(T item);
    bool isEmpty();
    T fetchMax();
    void deleteMax();
    void display();
    //Transfer Array&lt;T&gt; to a heap
    void arrayToHeap(T* array, int size); 
    //Sort the heap
    void heapSort();

private:
    void locate_down(int start, int end);
    void locate_up(int start, int end);

private:
    T* m_array;
    int m_size;//num of elem stored
    int m_maxSize;//allocated memory
};

template &lt;class T&gt;
Heap&lt;T&gt;::Heap(int maxSize)
{
    m_array=new T[maxSize+1];
    m_size=0;
    m_maxSize=maxSize;
}

template &lt;class T&gt;
T Heap&lt;T&gt;::fetchMax()
{
    return m_array[1];
}

template &lt;class T&gt;
bool Heap&lt;T&gt;::isEmpty()
{
    return m_size==0;
}

template &lt;class T&gt;
void Heap&lt;T&gt;::locate_down(int start, int end)
{
    int c=start*2;
    int temp;
    while(c&lt;=end)
    {
        if((c&lt;end) &amp;&amp; (m_array[c]&lt;m_array[c+1])) //Pick the larger one in both childs. ATTENTION: c==end is not approved!!
            c=c+1
        if(m_array[start]&lt;m_array[c])
        {
            temp=m_array[start];
            m_array[start]=m_array[c];
            m_array[c]=temp;
        }
        start=c;
        c=2*c;
    }
}

template &lt;class T&gt;  //overlap the top with the bottom, decrease the size, and locate_down
void Heap&lt;T&gt;::deleteMax()
{
    m_array[1]=m_array[m_size];
    --m_size;
    locate_down(1,m_size);
}

template &lt;class T&gt;
void Heap&lt;T&gt;::locate_up(int start, int end)
{
    int loc=end;
    int parent=end/2;
    int temp;
    while(parent&gt;=start &amp;&amp; m_array[loc]&lt;m_array[parent])
    {
        temp=m_array[loc];
        m_array[loc]=m_array[parent];
        m_array[parent]=temp;
        loc=parent;
        parent=loc/2;
    }
}

template &lt;class T&gt;
bool Heap&lt;T&gt;::insert(T item)
{
    if(m_size==m_maxSize)
    {
        std::cerr&lt;&lt;"Heap is full";
        this-&gt;~Heap();
        return 0;
    }
    ++m_size;
    m_array[m_size]=item;
    locate_up(1, m_size);
    return true;
}

template &lt;class T&gt;
void Heap&lt;T&gt;::display()
{
    for(int i=1; i&lt;=m_size; i++)
        std::cout&lt;&lt;m_array[i]&lt;&lt;" ";
    std::cout&lt;&lt;std::endl;
}

template &lt;class T&gt;
void Heap&lt;T&gt;::arrayToHeap(T* array, int size)
{
    m_maxSize=size;
    m_array=new T[m_maxSize+1];
    for(int i=1; i&lt;=size; ++i)
        this-&gt;insert(array[i-1]);
    this-&gt;heapSort();
    for(int i=1; i&lt;size; ++i)
        array[i-1]=m_array[i];
}

template &lt;class T&gt;
void Heap&lt;T&gt;::heapSort()
{
    T temp;
    int i;
    for(i=m_size; i&gt;=2; --i)
    {
        temp=m_array[1];
        m_array[1]=m_array[i];
        m_array[i]=temp;
        locate_down(1, i-1);
    }
}
</code></pre>

<p>```</p>

<h4>6.1 Heaps 151</h4>

<p>The (binary) heap data structure is an array object that we can view as a nearly complete binary tree.</p>

<p>``` cpp</p>

<pre><code>// calculate by shifting the binary representation
int parent(i) {
    return i/2;
}
int left(i) {
    return 2*i;
}
int right(i) {
    return 2*i + 1;
}
</code></pre>

<p>```</p>

<ul>
<li>max-heap: for every node <em>i</em> other than the root, A[parent(i)]>=A[i].</li>
<li>min-heap: for every node <em>i</em> other than the root, A[parent(i)]&lt;=A[i].</li>
<li>height of a node: number of edges on the longest simple downward path from the node to a leaf.</li>
<li>height of the heap: height of its root. Θ(lg n)</li>
</ul>


<h4>6.2 Maintaining the heap property 154</h4>

<p>``` cpp</p>

<pre><code>// Input:
//      A array
//      i index
//   Binary trees rooted at left(i) and right(i) are max-heaps
//   but A[i] might be smaller than its children. 
// Procedure:
//      exchange A[i] with the larger one between A[left[i]] and A[right[i]]
//      maxHeapify the new sub tree
// Output:
//      This routine lets the value at A[i] float down in the max-heap. 
maxHeapify(A, i) {
    TODO;
}
</code></pre>

<p>```</p>

<p>T(n) &lt;= T(2*n/3) + Θ(1), T(n) = O(lg n) = O(height)</p>

<h4>6.3 Building a heap 156</h4>

<p>conduct maxHeapify upon the array from the rear to the head</p>

<p>O(n)</p>

<h4>6.4 The heapsort algorithm 159</h4>

<p>build max-heap, exchange the root with the end of heap, and maxHeapify the rest of the heap.</p>

<h4>6.5 Priority queues 162</h4>

<p>one of the most popular applications of a heap: as an efficient priority queue. It can be used to schedule jobs on a shared computer. Highest-priority job first.</p>

<p>``` cpp prioqueue.hpp</p>

<pre><code>#include &lt;iostream&gt;
template &lt;class T&gt;
class PrioQueue //Min Heap
{
public:
    PrioQueue(int mSize=20);
    ~PrioQueue(){delete [] q;}
    bool IsEmpty() const {return size==0;}
    bool IsFull() const {return size==maxSize;}
    bool Append(const T &amp;x);
    bool Serve(T &amp;x);
private:
    void AdjustDown(int start, int end);
    void AdjustUp(int start, int end);
    T *q;
    int size, maxSize;
};

template &lt;class T&gt;
PrioQueue&lt;T&gt;::PrioQueue(int mSize)
{
    maxSize=mSize;
    size=0;
    q=new T[maxSize];
}

template &lt;class T&gt;
void PrioQueue&lt;T&gt;::AdjustDown(int start, int end)
{
    if(start&lt;end)
    {
        int parent=start;
        int child=2*parent+1;
        while(child&lt;=end)
        {
            if((child&lt;end)&amp;&amp;(q[child]&gt;q[child+1]))
                child=child+1;
            if(q[parent]&gt;q[child])
            {
                T temp=q[parent];
                q[parent]=q[child];
                q[child]=temp;
            }
            else break;
            parent=child;
            child=2*parent+1;
        }
    }
}

template &lt;class T&gt;
void PrioQueue&lt;T&gt;::AdjustUp(int start, int end)
{
    if(start&lt;end)
    {
        int child=end;
        int parent=(child-1)/2;
        while((parent&gt;=start)&amp;&amp; (q[parent]&gt;q[child]))
        {
                T temp=q[parent];
                q[parent]=q[child];
                q[child]=temp;
                child=parent;
                parent=(child-1)/2;
        }
    }
}

template &lt;class T&gt;
bool PrioQueue&lt;T&gt;::Append(const T &amp;x)
{
    if(this-&gt;IsFull())
    {
        //throw std::Overflow;
        std::cout&lt;&lt;"overflow"&lt;&lt;std::endl;
       return(0); 
    }
    size++;
    q[size-1]=x;
    this-&gt;AdjustUp(0, size-1);//ATTENTION: n-1
}

template &lt;class T&gt;
bool PrioQueue&lt;T&gt;::Serve(T &amp;x)
{
    if(this-&gt;IsEmpty())
    {
        //throw std::Underflow;
        return(0);
    }
    x=q[0];
    q[0]=q[size-1];
    q[size-1]=0;
    size--;
    this-&gt;AdjustDown(0, size-1); //ATTENTION: n-1
    std::cout&lt;&lt;"After AdjustDown:"&lt;&lt;q[0]&lt;&lt;q[1]&lt;&lt;q[2]&lt;&lt;q[3]&lt;&lt;q[4]&lt;&lt;std::endl;
}
</code></pre>

<p>```</p>

<h3>7 Quicksort 170</h3>

<p>Despite this slow worst-case running time Θ(n<sup>2)</sup> , quicksort is often <strong>the best practical choice</strong> for sorting because it is remarkably efficient on the average: its expected running time is <em>Θ(n lg n)</em>, and the <strong>constant factors hidden in the <em>Θ(n lg n)</em> notation are quite small</strong>.</p>

<h3>7.1 Description of quicksort 170</h3>

<p>Divide-and-conquer paradigm</p>

<ul>
<li>Divide: element A[q] and subarrays on the left and right, s.t. left &lt;= A[q] &lt;= right</li>
<li>Conquer: recursively sort left and right</li>
<li>Combine: NULL</li>
</ul>


<p>``` cpp quickSort.cxx</p>

<pre><code>void qSort(int* a, int b, int e) {
    if (b &lt; e) {
        int midVal = a[e];
        // partition
        int j = b;
        for (int i = b; i &lt;= e; i++) {
            if (a[i] &lt;= midVal) {
                int tmp = a[j]; a[j] = a[i]; a[i] = tmp;
                j++;
            }
        }
        qSort(a, b, j-2);
        qSort(a, j, e);
    }
}
</code></pre>

<p>```</p>

<h4>7.2 Performance of quicksort 174</h4>

<ul>
<li>Worst-case partitioning: the partitioning routine produces one subproblem with <em>n-1</em> elements and one with <em>0</em> elements.

<ul>
<li>T(n) = T(n-1) + T(0) + Θ(n)</li>
<li>Θ(n<sup>2)</sup></li>
</ul>
</li>
<li>Best-case partitioning: even possible split

<ul>
<li>T(n) = 2T(n/2) + Θ(n)</li>
<li>Θ(n lg n)</li>
</ul>
</li>
<li>Balanced partitioning: Any split of constant proportionality yields a recursion tree of depth Θ(lg n), where the cost at each level is O(n).</li>
<li>Average case: PARTITION produces a mix of “good” and “bad” splits.

<ul>
<li>TODO</li>
</ul>
</li>
</ul>


<h4>7.3 A randomized version of quicksort 179</h4>

<p>pick the flag in the partition routine randomly (exchange with the one at the rear)</p>

<h4>7.4 Analysis of quicksort 180</h4>

<h3>8 Sorting in Linear Time 191</h3>

<p><strong>comparison sorts</strong>: merge sort, heapsort, and quicksort sharing, <strong>must make Ω(n lg n) comparisons in the worst case</strong> to sort <em>n</em> elements.</p>

<p>However, counting sort, radix sort, and bucket sort...</p>

<h4>8.1 Lower bounds for sorting 191</h4>

<h4>8.2 Counting sort 194</h4>

<p>counting sort assumes that the input consists of integers in a small range</p>

<p>Create an extra array to record the occurrence of these number and put them back into a new array as the result. We usually use counting sort when we have k = O(n), in which case the running time is Θ(n).</p>

<h4>8.3 Radix sort 197</h4>

<p>TODO? 感觉像counting sort，只不过是存了整个数，而不是数数的个数</p>

<p><a href="http://cubic.org/docs/radix.htm">Radix sort tutorial</a></p>

<ul>
<li><em>source</em>: List of bytes</li>
<li><em>source_n</em>: number of bytes to sort</li>
<li><em>dest[256]</em>: 256 lists of bytes. each list should have enough space to hold source_n elements.</li>
</ul>


<p>a pseudo-code would sort the list this way:</p>

<pre><code>for i=0 to source_n do
   dest[source[i]].append(source[i])
</code></pre>

<h4>8.4 Bucket sort 200</h4>

<p>bucket sort assumes that the input is generated by a random process that distributes elements uniformly and independently over the interval [0, 1).</p>

<p>Bucket sort divides the interval [0, 1) into n equal-sized subintervals, or buckets, and then distributes the n input numbers into the buckets. Since the inputs are uniformly and independently distributed over [0, 1), we do not expect many numbers to fall into each bucket. To produce the output, we simply sort the numbers in each bucket (e.g. insertion sort) and then go through the buckets in order, listing the elements in each.</p>

<p>Θ(n)</p>

<h3>9 Medians and Order Statistics 213</h3>

<p><strong>Selection problem</strong> selects <em>i-st</em> smallest number among a set <em>A</em> of <em>n</em> (distinct) numbers</p>

<h4>9.1 Minimum and maximum 214</h4>

<p>How to find the min in A? Best way is to iterate it once (<em>n-1</em> comparisons).</p>

<p>How to find min and max simultaneously? In fact, we can find both the minimum and the maximum using at most 3<em>n/2 comparisons. 每次取一对，自己先比较，然后大的跟max比，小的跟min比，总共只需要比3</em>n/2次。</p>

<h4>9.2 Selection in expected linear time 215</h4>

<p>``` cpp randomizedSelect.cxx</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int randomizedSelect(double* A, int p, int r, int i) ;
int randomizedPatition(double* A, int p, int r) ;
int partition(double* A, int p, int r) ;

// ----------------------------------------------------------------------------
// select i-st largest number from A[p] to A[r]
int randomizedSelect(double* A, int p, int r, int i) {
    if (p == r) 
        return A[p];
    int q = randomizedPatition(A, p, r);
    int k = q-p+1;
    if (i == k) // the pivot value is the answer
        return A[q];
    else if (i &lt; k) // on the left
        return randomizedSelect(A, p, q-1, i);
    else            // on the right
        return randomizedSelect(A, q+1, r, i-k);
}
// ----------------------------------------------------------------------------
// get the index of the number in the middle 
// s.t. subarray on the left &lt;= A[index] &lt;= subarray on the right
int randomizedPatition(double* A, int p, int r) {
    int i = random()%(p-r+1) + p;
    double tmp = A[i]; A[i] = A[r]; A[r] = tmp;
    return partition(A, p, r);
}
// ----------------------------------------------------------------------------
// pick A[r] as the flag
// i for the left array &lt;= A[r]
// j for iterating the whole array 
// finally, exchange A[r] in the middle
// return the new middle index
int partition(double* A, int p, int r) {
    double x = A[r];
    int i = p - 1;
    for (int j = p; j &lt;= r-1; ++j) 
        if (A[j] &lt;= x) {
            ++ i;
            double tmp = A[i]; A[i] = A[j]; A[j] = tmp;
        }
    double tmp = A[i+1]; A[i+1] = A[r]; A[r] = tmp;
    return i+1;
}
// ----------------------------------------------------------------------------
int main() {
    double A[10] = {8,1,3,2,4,7,5,6,9,0};
    for (int i = 0; i &lt; 10; ++i) cout &lt;&lt; A[i];
    cout &lt;&lt; endl;
    cout &lt;&lt; randomizedSelect(A, 0, 9, 5) &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>```</p>

<p>E[T(n)] = O(n)</p>

<h4>9.3 Selection in worst-case linear time 220</h4>

<p>O(n)</p>

<h2>III Data Structures</h2>

<ul>
<li>Data structures: techniques for representing finite dynamic sets and manipulating them on a computer.</li>
<li>Dynamic-set operations: <strong>CR(U)D 大小前后</strong>: insert, search, delete, max, min, predecessor, successor.</li>
<li>Dictionary: a dynamic set supporting insert, delete, and test membership.</li>
<li>2 categories of operations

<ul>
<li>queries</li>
<li>modifying operations</li>
</ul>
</li>
</ul>


<h3>10 Elementary Data Structures 232</h3>

<h4>10.1 Stacks and queues 232</h4>

<h5>Stack</h5>

<p>``` cpp stack.h</p>

<pre><code>#include &lt;iostream&gt;
template &lt;class T&gt;
class Stack
{
public:
    virtual bool IsEmpty() const=0;
    virtual bool IsFull() const=0;
    virtual bool Top(T &amp;x) const=0;
    virtual bool Push(T x) =0;
    virtual T Pop() =0;
    virtual void Clear() =0;
};
</code></pre>

<p>```</p>

<h5>Sequential Stack</h5>

<p>``` cpp seqstack.cxx</p>

<pre><code>#include "stack.h"

template &lt;class T&gt;
class SeqStack:public Stack&lt;T&gt;
{
public:
    SeqStack(int mSize);
    ~SeqStack() {delete []s;}
    bool IsEmpty() const { return top == -1;}
    bool IsFull() const { return top == maxTop;}
    bool Top(T &amp;x) const;         //return the top element in x
    bool Push(T x);
    T Pop();
    void Clear() { top = -1;}
private:
    int top;
    int maxTop;
    T *s;
};
template &lt;class T&gt;
SeqStack&lt;T&gt;::SeqStack(int mSize)
{
    maxTop = mSize - 1;
    s = new T[mSize];
    top = -1;
}

template &lt;class T&gt;
bool SeqStack&lt;T&gt;::Top(T &amp;x) const
{
    if (IsEmpty())
    {
        std::cout&lt;&lt;"Empty"&lt;&lt;std::endl;
        return false;
    }
    x = s[top];
    return true;
}

template &lt;class T&gt;
bool SeqStack&lt;T&gt;::Push(T x)
{
    if(IsFull())
    {
        std::cout&lt;&lt;"Overflow"&lt;&lt;std::endl;
        return false;
    }
    s[++top] = x;
    return true;
}

template &lt;class T&gt;
T SeqStack&lt;T&gt;::Pop()
{
    if(IsEmpty())
    {
        std::cout&lt;&lt;"Underflow"&lt;&lt;std::endl;
        return false;
    }
    return s[top--];
}
</code></pre>

<p>```</p>

<p>``` cpp SeqStackTest.cxx</p>

<pre><code>#include "seqstack.h"
int main()
{
    SeqStack&lt;int&gt; S(10);
    std::cout&lt;&lt;S.IsEmpty()&lt;&lt;std::endl;
    std::cout &lt;&lt; S.IsFull() &lt;&lt; std::endl;
    for(int i = 0; i &lt; 10; i++)
    {
        S.Push(i);
        int x;
        S.Top(x);
        std::cout&lt;&lt; x &lt;&lt; " "; 
    }
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; S.IsFull() &lt;&lt; std::endl;
    for(int i = 0; i &lt; 10; i++)
    {
        std::cout &lt;&lt;  S.Pop() &lt;&lt; " " ;
    }
    std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>```</p>

<h5>Queue</h5>

<p>``` cpp queue.h</p>

<pre><code>#include &lt;iostream&gt;
template &lt;class T&gt;
class Queue
{
public:
    virtual bool IsEmpty() const=0;
    virtual bool IsFull() const=0;
    virtual bool Front(T&amp; x) const=0;
    virtual bool EnQueue(T x) =0;
    virtual T DeQueue() =0;
    virtual bool Clear() =0;
};
</code></pre>

<p>```</p>

<h5>Sequential Queue</h5>

<p>``` cpp seqqueue.h</p>

<pre><code>#include "queue.h"

template &lt;class T&gt;
class SeqQueue:public Queue 
{
public:
    SeqQueue(int mSize);
    ~SeqQueue() { delete [] q;}
    bool IsEmpty() const { return front == rear;}
    bool IsFull() const { return (rear+1) == front;}
    bool Front(T&amp; x) const;
    bool EnQueue(T x);
    T DeQueue();
    void Clear() { front = rear = 0;}
private:
    int front, rear;
    int maxSize;
    T *q;
};

template &lt;class T&gt;
SeqQueue&lt;T&gt;::SeqQueue(int mSize)
{
    maxSize = mSize;
    q = new T[maxSize];
    front = rear = 0;
}

template &lt;class T&gt;
bool SeqQueue&lt;T&gt;::Front(T&amp; x) const
{
    if (IsEmpty())
    {
        std::cout &lt;&lt; "Empty" &lt;&lt; std::endl;
        return false;
    }
    x = q[front];
    return true;
}

template &lt;class T&gt;
bool SeqQueue&lt;T&gt;::EnQueue(T x)
{
    if (IsFull()) 
    {
        std::cout &lt;&lt; "Overflow" &lt;&lt; std::endl;
        return false;
    }
    q[(rear=(rear + 1) % maxSize)] = x;
    return true;
}

template &lt;class T&gt;
T SeqQueue&lt;T&gt;::DeQueue()
{
    if (IsEmpty())
    {
        std::cout &lt;&lt; "Underflow" &lt;&lt; std::endl;
        return false;
    }
    T x = q[front];
    front = (front + 1) % maxSize;
    return x;
}
</code></pre>

<p>```</p>

<h4>10.2 Linked lists 236</h4>

<h5>Linear List</h5>

<p>``` cpp linearlist.h</p>

<pre><code>template &lt;class T&gt;
class LinearList
{
public:
    virtual bool IsEmpty() const=0;
    virtual int GetLength() const=0;
    virtual bool Find(int i, T&amp; x) const=0;            //return element x with index i
    virtual int Search(T x) const=0;                   //if x is found, return its index, else -1
    virtual bool Insert(int i, T x)=0;                 //insert x at element Ai.
    virtual bool Delete(int i)=0;                      //delete element Ai
    virtual bool Update(int i, T x)=0;                 //update element Ai with x
    virtual void Output(std::ostream&amp; out)const=0;     //ouput the list to the stream
protected:
    int ElemNum;                                        //element number in the list
};
</code></pre>

<p>```</p>

<h5>Single List</h5>

<p>``` cpp singlelist.h</p>

<pre><code>#include "iostream"
#include "linearlist.h"

template &lt;class T&gt; class SingleList;

template &lt;class T&gt;
class Node
{
    private:
        T element;
        Node&lt;T&gt; *next;
        friend class SingleList&lt;T&gt;;
};

template &lt;class T&gt;
class SingleList:public LinearList&lt;T&gt;
{
    public:
        SingleList(){ head = NULL; this-&gt;ElemNum = 0;}
        ~SingleList();
        bool IsEmpty() const;
        int GetLength() const;
        bool Find(int i, T&amp; x) const;
        int Search(T x) const;
        bool Insert(int i, T x);
        bool Delete(int i);
        bool Update(int i, T x);
        void Clear();
        void Output(std::ostream&amp; out) const;
    private:
        Node&lt;T&gt;* head;
};

template &lt;class T&gt;
SingleList&lt;T&gt;::~SingleList()
{
    Node&lt;T&gt; *p;
    while (head)
    {
        p = head-&gt;next;
        delete head;
        head = p;
    }
}

template &lt;class T&gt;
bool SingleList&lt;T&gt;::IsEmpty() const
{
    return this-&gt;ElemNum == 0;
}

template &lt;class T&gt;
int SingleList&lt;T&gt;::GetLength() const
{
    return this-&gt;ElemNum;
}

template &lt;class T&gt;
bool SingleList&lt;T&gt;::Find(int i, T&amp; x) const
{
    if (i &lt; 0 || i &gt; this-&gt;ElemNum -1)
    {
        std::cout &lt;&lt; "Exceed Bounds!" &lt;&lt; std::endl;
        return false;
    }
    Node&lt;T&gt; *p = head;
    for (int j = 0; j &lt; i; j++) p = p-&gt;next;
    x = p-&gt;element;
    return true;
}

template &lt;class T&gt;
int SingleList&lt;T&gt;::Search(T x) const
{
    Node&lt;T&gt; *p = head;
    for (int i = 0; i &lt; this-&gt;ElemNum; i ++) 
    {
        if(x == p-&gt;element)
            return i;
        else
            p = p-&gt;next;
    }
    return -1;
}

template &lt;class T&gt;
bool SingleList&lt;T&gt;::Insert(int i, T x)
{
    if (i &lt; 0 || i &gt; this-&gt;ElemNum )
    {
        std::cout &lt;&lt; "Exceed Bounds!" &lt;&lt; std::endl;
        return false;
    }
    Node&lt;T&gt; * r = new Node&lt;T&gt;(); r-&gt;element = x;
    Node&lt;T&gt; * p = head;
    Node&lt;T&gt; * q ;
    for (int j = 0; j &lt; i; j++)
    {
        q = p;
        p = p-&gt;next;
    }
    if(i == 0)
    {
        head = r;
        r-&gt;next = p;
    }
    else
    {
        q-&gt;next = r;
        r-&gt;next = p;
    }
    (this-&gt;ElemNum) ++;
    return true;
}

template &lt;class T&gt;
bool SingleList&lt;T&gt;::Delete(int i)
{
    if (!(this-&gt;ElemNum))
    {
        std::cout&lt;&lt;"Underflow!"&lt;&lt;std::endl;
        return false;
    }
    if (i &lt; 0 || i &gt; this-&gt;ElemNum - 1)
    {
        std::cout &lt;&lt; "Exceed Bounds!" &lt;&lt; std::endl;
        return false;
    }
    Node&lt;T&gt; * p = head;
    Node&lt;T&gt; * q = head;
    if (i == 0)
    {
        head = head-&gt;next;
        delete p;
    }
    else
    {
        for (int j = 0; j &lt; i; j++)
        {
            q = p;
            p = p-&gt;next;
        }
        q-&gt;next = p-&gt;next;
        delete p;
    }
    (this-&gt;ElemNum) --; 
    return true;
}

template &lt;class T&gt;
bool SingleList&lt;T&gt;::Update(int i, T x)
{
    if (i &lt; 0 || i &gt; this-&gt;ElemNum-1)
    {

        std::cout &lt;&lt; "Exceed Bounds!" &lt;&lt; std::endl;
        return false;
    }
    Node&lt;T&gt; * p = head;
    for (int j = 0; j &lt; i; j ++)
    {
        p = p-&gt;next;
    }
    p-&gt;element = x;
    return true;
}

template &lt;class T&gt;
void SingleList&lt;T&gt;::Clear()
{
    Node&lt;T&gt; *p;
    while (head)
    {
        p = head-&gt;next;
        delete head;
        head = p;
    }
}

template &lt;class T&gt;
void SingleList&lt;T&gt;::Output(std::ostream&amp; out) const
{
    Node&lt;T&gt; *p = head;
    while (p)
    {
        out &lt;&lt; p-&gt;element &lt;&lt; " ";
        p = p-&gt;next;
    }
    out &lt;&lt; std::endl;
}
</code></pre>

<p>```</p>

<p>``` cpp SingleListTest.cxx</p>

<pre><code>#include "singlelisti.h"
#include "stdio.h"
int main()
{
    SingleList&lt;int&gt; LA;
    SingleList&lt;int&gt; LB;
    for (int i = 0; i &lt; 6; i++) LA.Insert(i, i);
    for (int i = 5; i &lt; 10; i++) LB.Insert(i-5, i);
    LB.Insert(0, 0);
    LB.Insert(4, 2);
    LB.Insert(LB.GetLength(), 4);
    LA.Output(std::cout);
    LB.Output(std::cout);
    Intersection(LA, LB);
    LA.Output(std::cout);

    return 0;
}
</code></pre>

<p>```</p>

<h5>Double List</h5>

<p>``` cpp doublelist.h</p>

<pre><code>#include "linearlist.h"

template &lt;class T&gt; class DoubleList;

template &lt;class T&gt;
class Node
{
    private:
        T element;
        Node&lt;T&gt; *last, *next;
        friend class DoubleList&lt;T&gt;;
};

template &lt;class T&gt;
class DoubleList:public LinearList&lt;T&gt;
{
    public:
        DoubleList(){ head = NULL; this-&gt;ElemNum = 0;}
        ~DoubleList();
        bool IsEmpty() const;
        int GetLength() const;
        bool Find(int i, T&amp; x) const;
        int Search(T x) const;
        bool Insert(int i, T x);
        bool Delete(int i);
        bool Update(int i, T x);
        void Clear();
        void Output(std::ostream&amp; out) const;
    private:
        Node&lt;T&gt;* head;
};

template &lt;class T&gt;
DoubleList&lt;T&gt;::~DoubleList()
{
    Node&lt;T&gt; *p;
    while (head)
    {
        p = head-&gt;next;
        delete head;
        head = p;
    }
}

template &lt;class T&gt;
bool DoubleList&lt;T&gt;::IsEmpty() const
{
    return this-&gt;ElemNum == 0;
}

template &lt;class T&gt;
int DoubleList&lt;T&gt;::GetLength() const
{
    return this-&gt;ElemNum;
}

template &lt;class T&gt;
bool DoubleList&lt;T&gt;::Find(int i, T&amp; x) const
{
    if (i &lt; 0 || i &gt; this-&gt;ElemNum -1)
    {
        std::cout &lt;&lt; "Exceed Bounds!" &lt;&lt; std::endl;
        return false;
    }
    Node&lt;T&gt; *p = head;
    for (int j = 0; j &lt; i; j++) p = p-&gt;next;
    x = p-&gt;element;
    return true;
}

template &lt;class T&gt;
int DoubleList&lt;T&gt;::Search(T x) const
{
    Node&lt;T&gt; *p = head;
    for (int i = 0; i &lt; this-&gt;ElemNum; i ++) 
    {
        if(x == p-&gt;element)
            return i;
        else
            p = p-&gt;next;
    }
    return -1;
}

template &lt;class T&gt;
bool DoubleList&lt;T&gt;::Insert(int i, T x)
{
    if (i &lt; 0 || i &gt; this-&gt;ElemNum )
    {
        std::cout &lt;&lt; "Exceed Bounds!" &lt;&lt; std::endl;
        return false;
    }
    Node&lt;T&gt; * r = new Node&lt;T&gt;(); r-&gt;element = x;
    Node&lt;T&gt; * p = head;
    for (int j = 0; j &lt; i; j++)
    {
        p = p-&gt;next;
    }
    if(i == 0)
    {
        head = r;
        r-&gt;last = NULL;
        r-&gt;next = p;
        p-&gt;last = r;
    }
    else
    {
        r-&gt;last = p-&gt;last;
        p-&gt;last-&gt;next = r;
        r-&gt;next = p;
        p-&gt;last = r;
    }
    (this-&gt;ElemNum) ++;
    return true;
}

template &lt;class T&gt;
bool DoubleList&lt;T&gt;::Delete(int i)
{
    if (!(this-&gt;ElemNum))
    {
        std::cout&lt;&lt;"Underflow!"&lt;&lt;std::endl;
        return false;
    }
    if (i &lt; 0 || i &gt; this-&gt;ElemNum - 1)
    {
        std::cout &lt;&lt; "Exceed Bounds!" &lt;&lt; std::endl;
        return false;
    }
    Node&lt;T&gt; * p = head;
    if (i == 0)
    {
        head = head-&gt;next;
        delete p;
    }
    else
    {
        for (int j = 0; j &lt; i; j++)
        {
            p = p-&gt;next;
        }
        p-&gt;last-&gt;next = p-&gt;next;
        p-&gt;next-&gt;last = p-&gt;last;
        delete p;
    }
    (this-&gt;ElemNum) --; 
    return true;
}

template &lt;class T&gt;
bool DoubleList&lt;T&gt;::Update(int i, T x)
{
    if (i &lt; 0 || i &gt; this-&gt;ElemNum-1)
    {

        std::cout &lt;&lt; "Exceed Bounds!" &lt;&lt; std::endl;
        return false;
    }
    Node&lt;T&gt; * p = head;
    for (int j = 0; j &lt; i; j ++)
    {
        p = p-&gt;next;
    }
    p-&gt;element = x;
    return true;
}

template &lt;class T&gt;
void DoubleList&lt;T&gt;::Clear()
{
    Node&lt;T&gt; *p;
    while (head)
    {
        p = head-&gt;next;
        delete head;
        head = p;
    }
}

template &lt;class T&gt;
void DoubleList&lt;T&gt;::Output(std::ostream&amp; out) const
{
    Node&lt;T&gt; *p = head;
    while (p)
    {
        out &lt;&lt; p-&gt;element &lt;&lt; " ";
        p = p-&gt;next;
    }
    out &lt;&lt; std::endl;
}
</code></pre>

<p>```</p>

<p>``` cpp DoubleListTest.cxx</p>

<pre><code>#include "singlelisti.h"
#include "stdio.h"
int main()
{
    SingleList&lt;int&gt; LA;
    SingleList&lt;int&gt; LB;
    for (int i = 0; i &lt; 6; i++) LA.Insert(i, i);
    for (int i = 5; i &lt; 10; i++) LB.Insert(i-5, i);
    LB.Insert(0, 0);
    LB.Insert(4, 2);
    LB.Insert(LB.GetLength(), 4);
    LA.Output(std::cout);
    LB.Output(std::cout);
    LA.Delete(3);
    LA.Output(std::cout);

    return 0;
}
</code></pre>

<p>```</p>

<h4>10.3 Implementing pointers and objects 241</h4>

<ul>
<li>How do we implement pointers and objects in languages that do not provide them?

<ol>
<li>A multiple-array representation of objects

<ul>
<li>for example, <code>next[]</code>, <code>key[]</code>, <code>prev[]</code> can store the values and indexes</li>
</ul>
</li>
<li>A single-array representation of objects

<ul>
<li>for example, store triple &lt; key, next, prev > in one single array</li>
</ul>
</li>
</ol>
</li>
<li>Allocating and freeing objects

<ul>
<li>a <strong>garbage collector</strong> is responsible for determining which objects are unused.</li>
<li>We keep the free objects in a singly linked list, which we call the <strong>free list</strong>. Each object in the representation is either in list L or in the free list, but not in both. Free list acts like a stack. 在free list的head操作</li>
</ul>
</li>
</ul>


<h4>10.4 Representing rooted trees 246</h4>

<ul>
<li>Binary trees</li>
<li>Rooted trees with unbounded branching

<ul>
<li><strong>left-child, right-sibling representation</strong>

<ol>
<li><em>x.left-child</em> points to the leftmost child of node <em>x</em></li>
<li><em>x.right-sibling</em> points to the sibling of <em>x</em> immediately to its right.</li>
<li>If node <em>x</em> has no children, then <em>x.left-child</em> = NIL, and if node x is the rightmost child of its parent, then <em>x.right-sibling</em> = NIL.</li>
</ol>
</li>
</ul>
</li>
<li>Other tree representations. Many are possible.</li>
</ul>


<p>``` cpp binarytree.hpp</p>

<pre><code>template &lt;class T&gt;
struct BTNode
{
    BTNode()
    {
        lChild = rChild = NULL;
    }
    BTNode(const T&amp; x)
    {
        element = x;
        lChild = rChild = NULL;
    }
    BTNode(const T&amp; x, BTNode&lt;T&gt;* l, BTNode&lt;T&gt;* r)
    {
        element = x;
        lChild = l;
        rChild = r;
    }
    T element;
    BTNode&lt;T&gt;* lChild, *rChild;
};

template &lt;class T&gt;
class BinaryTree
{
public:
    BinaryTree() {root = NULL;}
    ~BinaryTree() {};
    bool IsEmpty() const;
    void Clear();
    bool Root(T&amp; x) const;
    void MakeTree(const T&amp; x, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right);
    void BreakTree(T&amp; x, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right);
    void PreOrder(void (*Visit)(T&amp; x));
    void InOrder(void (*Visit)(T&amp; x));
    void PostOrder(void (*Visit)(T&amp; x));
    int Size();
    void Copy();
protected:
    BTNode&lt;T&gt;* root;
private:
    void Clear(BTNode&lt;T&gt;* &amp;t);
    void PreOrder(void (*Visit)(T&amp; x), BTNode&lt;T&gt; *t);
    void InOrder(void (*Visit)(T&amp; x), BTNode&lt;T&gt; *t);
    void PostOrder(void (*Visit)(T&amp; x), BTNode&lt;T&gt; *t);
    int Size(BTNode&lt;T&gt; *t);
    void Clear(BTNode&lt;T&gt; *t);
    friend class BIterator;
};

template &lt;class T&gt;
bool BinaryTree&lt;T&gt;::Root(T&amp; x)const
{
    if(root)
    {
        x = root-&gt;element;
        return true;
    }
    else
        return false;
}

template &lt;class T&gt;
void BinaryTree&lt;T&gt;::MakeTree(const T&amp; x, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right)
{
    if (root || &amp;left == &amp;right) return;
    root = new BTNode&lt;T&gt; (x, left.root, right.root);
    left.root=right.root=NULL;
}

template &lt;class T&gt;
void BinaryTree&lt;T&gt;::BreakTree(T&amp; x, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right)
{
    if (!root||&amp;left==&amp;right||left.root||left.root) return;
    x=root-&gt;element;
    left.root=root-&gt;lChild; right.root=root-&gt;rChild;
    delete root;
    root=NULL;
}

template &lt;class T&gt;
void BinaryTree&lt;T&gt;::PreOrder(void (* Visit)(T&amp; x))
{
    PreOrder(Visit, root);
}
template &lt;class T&gt;
void BinaryTree&lt;T&gt;::PreOrder(void (* Visit)(T&amp; x), BTNode&lt;T&gt;* t)
{
    if (t)
    {
        Visit(t-&gt;element);
        PreOrder(Visit, t-&gt;lChild);
        PreOrder(Visit, t-&gt;rChild);
    }
}

template &lt;class T&gt;
void BinaryTree&lt;T&gt;::InOrder(void (* Visit)(T&amp; x))
{
    InOrder(Visit, root);
}
template &lt;class T&gt;
void BinaryTree&lt;T&gt;::InOrder(void (* Visit)(T&amp; x), BTNode&lt;T&gt;* t)
{
    if(t)
    {
        InOrder(Visit, t-&gt;lChild);
        Visit(t-&gt;element);
        InOrder(Visit, t-&gt;rChild);
    }
}


template &lt;class T&gt;
void BinaryTree&lt;T&gt;::PostOrder(void (* Visit)(T&amp; x))
{
    PostOrder(Visit, root);
}
template &lt;class T&gt;
void BinaryTree&lt;T&gt;::PostOrder(void (* Visit)(T&amp;x), BTNode&lt;T&gt;* t)
{
    if(t)
    {
        PostOrder(Visit, t-&gt;lChild);
        PostOrder(Visit, t-&gt;rChild);
        Visit(t-&gt;element);
    }
}

template &lt;class T&gt;
int BinaryTree&lt;T&gt;::Size()
{
    return Size(root);
}
template &lt;class T&gt;
int BinaryTree&lt;T&gt;::Size(BTNode&lt;T&gt; &amp;t)
{
    if(!t) return 0;
    return Size(t-&gt;lChild) + Size(t-&gt;rChild) + 1;
}

template &lt;class T&gt;
BTNode&lt;T&gt;* BinaryTree&lt;T&gt;::Copy(BTNode&lt;T&gt;* t)
{
    if(!t) return NULL;
    BTNode&lt;T&gt;* q=new BTNode&lt;T&gt;(t-&gt;element);
    q-&gt;lChild=Copy(t-&gt;lChild);
    q-&gt;rChild=Copy(t-&gt;rChild);
    return q;
}

template &lt;class T&gt;
void BinaryTree&lt;T&gt;::Clear()
{
    Clear(root);
}
template &lt;class T&gt;
void BinaryTree&lt;T&gt;::Clear(BTNode&lt;T&gt;* t)
{
    if(t)
    {
        Clear(t-&gt;lChild);
        Clear(t-&gt;rChild);
        delete t;
    }
}


template &lt;class&gt;
class BIterator
{
public:
    virtual T* GoFirst(const BinaryTree&lt;T&gt;&amp; bt)=0;
    virtual T* Next()=0;
    virtual void Traverse(void (*Visit)(T&amp; x), const BinaryTree&lt;T&gt;&amp; bt);
protected:
    BTNode&lt;T&gt;* r, *current;
};

template &lt;class T&gt;
void BIterator&lt;T&gt;::Traverse(void (*Visit)(T&amp; x), const BinaryTree&lt;T&gt;&amp; bt)
{
    T* p=GoFirst(bt);
    while(p)
    {
        Visit(*p);
        p=Next();
    }
}

template &lt;class T&gt;
class IInOrder:public BIterator&lt;T&gt;
{
public:
    IInOrder(BinaryTree&lt;T&gt;&amp; bt, int mSize)
    {
        r=bt.root;
        current=NULL;
        s=new SeqStack&lt;BTNode&lt;T&gt;* &gt;(mSize);
    }
    T* GoFirst(const BinaryTree&lt;T&gt;&amp; bt);
    T* Next();
private:
    SeqStack&lt;BTNode&lt;T&gt;*&gt; *s;
};
</code></pre>

<p>```</p>

<h3>11 Hash Tables 253</h3>

<ul>
<li>A hash table is an effective data structure for implementing dictionaries.

<ul>
<li>searching worst-case Θ(n)</li>
<li>expected O(1)</li>
<li>Instead of using the key as an array index directly, the array index is computed from the key.</li>
</ul>
</li>
</ul>


<h4>11.1 Direct-address tables 254</h4>

<p>Assume that universe U of keys is reasonably small, and no two elements have the same key. Store <em>x</em> at <em>T[x.key]</em> or at the place which <em>T[x.key]</em> points to. (Even storing the key is not necessary.)</p>

<p><strong>slot</strong>: position in the array (direct-address table)</p>

<h4>11.2 Hash tables 256</h4>

<ul>
<li>What if universe U is large? namely, K of keys stored in a dictionary is much smaller than the universe U of all possible keys?</li>
<li>hash function! element is stored in slot <em>h(k)</em> instead of <em>key</em> directly

<ul>
<li>h: U -> {0, 1, ..., m-1}</li>
<li>An element with key <em>k</em> <strong>hashes</strong> to slot <em>h(k)</em>.</li>
</ul>
</li>
<li>Problem: <strong>collision</strong>: two keys may hash to the same slot.

<ul>
<li>Collision resolution by chaining, insert at the head

<ul>
<li> Given a hash table T with m slots that stores n elements, we define the <strong><em>load factor α</em></strong> for T as n/m, that is, <strong><em>the average number of elements stored in a chain</em></strong>.</li>
<li>Worst-case: Θ(n) + T(compute hash)</li>
<li>Average-case: <strong>simple uniform hashing</strong> Any given element is equally likely to hash into any of the m slots, independently of where any other element has hashed to.

<ul>
<li>Unsuccessful, Θ(1+α) n个元素m个slot，期望是每个slot有n/m个元素</li>
<li>Successful, Θ(1+α)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>11.3 Hash functions 262</h4>

<ul>
<li>What makes a good hash function? less collisions

<ul>
<li>satisfies (approximately) the assumption of simple uniform hashing.</li>
<li>Hash values are independent of any patterns that might exist in the data.</li>
</ul>
</li>
<li>Interpreting keys as natural numbers</li>
<li>Different ways:

<ol>
<li><strong>division method</strong>. h(k) = k mod m.</li>
<li><strong>multiplication method</strong>. h(k) = ⦏m(kA mod 1)⦎, “kA mod 1” means the fractional part of kA, that is, kA - ⦏kA⦎. (A is a constant, 0 &lt; A &lt; 1) Knuth suggests that A = 0.618</li>
<li><strong>universal hashing</strong>. select the hash function at random from a carefully designed class of functions.</li>
</ol>
</li>
</ul>


<h4>11.4 Open addressing 269</h4>

<ul>
<li><strong>Open addressing</strong>: all elements occupy the hash table itself. <strong>No chaining</strong>. load factor α can never exceed 1.

<ul>
<li>We <strong>compute the sequence of slots to be examined by probing until we find an empty slot</strong>. The probing sequence has not to be &lt; 0, 1, ..., m-1 > with Θ(n), but <strong>depends upon the key being inserted</strong>. To determine which slots to probe, we extend the hash function to include the probe number (starting from 0) as a second input.  &lt; h(k,0), h(k,1), ..., h(k,m-1) >.</li>
<li>注意，此处不能标记删除的slot为NIL，因为这样一来就无法读到存在其后面部分的散列 值了。解决方法是，用DELETED取代NIL.</li>
<li><strong><em>uniform hashing</em></strong>: the probe sequence of each key is equally likely to be any of the m! permutations of &lt; 0, 1, ..., m-1 >.

<ul>
<li>linear probing

<ul>
<li>h(k,i) = (h'(k)+i) mod m</li>
<li>problem: primary <strong>clustering</strong></li>
</ul>
</li>
<li>quadratic probing

<ul>
<li>h(k,i) = (h'(k) + c1*i + c2*i<sup>2)</sup> mod m</li>
<li>problem: secondary clustering</li>
</ul>
</li>
<li>double hashing

<ul>
<li>one of the best</li>
<li>h(k,i) = (h1(k) + i*h2(k)) mod m</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>11.5 Perfect hashing 277</h4>

<ul>
<li><strong>Perfect hashing</strong>: O(1) memory accesses are required to perform a search in the worst case.

<ul>
<li>two levels of hashing with universal hashing at each level.</li>
<li>By choosing the first-level hash function well, we can limit the expected total amount of space used to O(n)</li>
<li>TODO 证明很复杂的样子</li>
</ul>
</li>
</ul>


<p><a href="http://www.cplusplus.com/reference/map/map/">C++ std::map的使用</a></p>

<h3>12 Binary Search Trees 286</h3>

<ul>
<li>Performance

<ul>
<li>Best-case Θ(lgn)</li>
<li>Average-case Θ(lgn)</li>
<li>Worst-case Θ(n)</li>
</ul>
</li>
<li>Improve? red-black trees(height O(lg n)), B-trees(secondary storage)</li>
</ul>


<p>``` cpp bstree.hpp</p>

<pre><code>#include"dynamic.h"
#include"binarytree.h"
//二叉搜索树：
//所有节点的关键字不同，此树要么为空，要么：
//1. 左不空，则左所有&lt;根
//2. 右不空，则右所有&gt;根
//3. 左右子树均为二叉搜索树
template &lt;class T&gt;
class BSTree:public DynamicSet&lt;T&gt;
{
public:
    BSTree() {root=NULL;}
    ResultCode Search_recursion(T&amp; x) const;
    ResultCode Search_iteration(T&amp; x) const;
    ResultCode Insert_recursion(T&amp; x);
    ResultCode Insert_iteration(T&amp; x);
    ResultCode Remove(T&amp; x);

protected:
    BTNode&lt;T&gt;* root;

private:
    ResultCode Search(BTNode&lt;T&gt; *p, T&amp; x) const;
    ResultCode Insert(BTNode&lt;T&gt; *p, T&amp; x);
};

template &lt;class T&gt;
ResultCode BSTree&lt;T&gt;::Search_recursion(T&amp; x) const
{
    return Search(root, x);
}

template &lt;class T&gt;
ResultCode BSTree&lt;T&gt;::Search(BTNode&lt;T&gt; *p, T&amp; x) const
{
    if(!p) return NotPresent;
    else if(x&gt;p-&gt;element) return Search(p-&gt;rChild, x);
    else if(x&lt;p-&gt;element) return Search(p-&gt;lChild, x);
    else return Success;
}
template &lt;class T&gt;
ResultCode BSTree&lt;T&gt;::Search_iteration(T&amp; x) const
{
    BTNode&lt;T&gt; *p=root;
    while(p)
    {
        if(x&lt;p-&gt;element) p=p-&gt;lChild;
        else if(x&gt;p-&gt;element) p=p-&gt;rChild;
        else return Success;
    }
    return NotPresent;
}

template &lt;class T&gt;
ResultCode BSTree&lt;T&gt;::Insert_recursion(T&amp; x)//ATTENTION: situation when root is NULL
{
    if(root) return Insert(root, x);
    else root=new BTNode&lt;T&gt;(x);
}

template &lt;class T&gt;
ResultCode BSTree&lt;T&gt;::Insert(BTNode&lt;T&gt;* p, T&amp; x) //ATTENTION: situation when root is NULL
{
    if(x&gt;p-&gt;element)
    {
       if(p-&gt;rChild==NULL)
       {
           p-&gt;rChild=new BTNode(x);
           return Success;
       }
       else return Insert(p-&gt;rChild, x);
    }
    else if(x&lt;p-&gt;element)
    {
       if(p-&gt;lChild==NULL)
       {
           p-&gt;lChild=new BTNode(T);
           return Success;
       }
       else return Insert(p-&gt;lChild, x);
    }
    else return Duplicate;
}

template &lt;class T&gt;
ResultCode BSTree&lt;T&gt;::Insert_iteration(T&amp; x)
{
    BTNode&lt;T&gt; *p=root, *q=NULL;
    if(!p)
    {
        q=p;
        if(x&gt;p-&gt;element) p=p-&gt;rChild; 
        else if(x&lt;p-&gt;element) p=p-&gt;lChild;
        else return Duplicate;
    }
    p=new BTNode&lt;T&gt;(x);
    if(!root) root=p;
    else if(x&lt;q-&gt;element) q-&gt;lChild=p;
    else q-&gt;rChild=p;
    return Success;
}

template &lt;class T&gt;
ResultCode BSTree&lt;T&gt;::Remove(T* x)
{
   // TODO
}
</code></pre>

<p>```</p>

<h4>12.1 What is a binary search tree? 286</h4>

<p><strong>binary-search-tree property: left &lt;= middle &lt;= right</strong>: Let x be a node in a binary search tree. If y is a node in the left subtree of x, then y.key &lt;= x.key. If y is a node in the right subtree of x, then y.key >= x.key.</p>

<p>How to print out keys in sorted order? <strong>inorder tree walk</strong> (other walks: <strong>preorder</strong>, <strong>postorder</strong>)</p>

<p>``` cpp</p>

<pre><code>void inorderTreeWalk(Node* r) {
    if (r) {
        inorderTreeWalk(r-&gt;left);
        cout &lt;&lt; r.key;
        inorderTreeWalk(r-&gt;right)};
    }
}
</code></pre>

<p>```
Θ(n)</p>

<h4>12.2 Querying a binary search tree 289</h4>

<ul>
<li>Iteration is faster in <em>Java, C, Python...</em> Recursion is fairly expensive compared to iteration (in general) because it requires the allocation of a new stack frame.</li>
<li>Recursion <em>might</em> be faster in <em>functional programming language</em>.</li>
</ul>


<h5>Searching</h5>

<ul>
<li>Recursive version: Me? search left? search right?</li>
<li>Iteration version: Use pointer p. p->key? p=p->left? p=p->right?</li>
</ul>


<h5>Min and Max</h5>

<p>left-most leaf and right-most leaf</p>

<h5>Successor and predecessor</h5>

<ul>
<li>Successor: If x has right subtree, return max(x.right), else find in parents.</li>
<li>Predecessor: If x has left subtree, return max(x.left), else find in parents.</li>
</ul>


<h4>12.3 Insertion and deletion 294</h4>

<h4>12.4 Randomly built binary search trees 299</h4>

<h3>13 Red-Black Trees 308</h3>

<h4>13.1 Properties of red-black trees 308</h4>

<ul>
<li>A BST with one extra <strong>color</strong> bit of storage per node.</li>
<li>Red-black properties:

<ol>
<li>Every node is either red or black.</li>
<li>The root is black.</li>
<li>Every leaf (NIL) is black.</li>
<li>If a node is red, then both its children are black.</li>
<li>For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</li>
</ol>
</li>
<li>sentinel T.nil for all all pointers to NIL (replacing leaves and parent of root)</li>
<li><strong>black-height</strong> of node x: number of black nodes on the path from (not including) x to a leaf</li>
<li><strong>black-height</strong> of a tree: black-height of its root</li>
<li>A red-black tree with n <strong>internal</strong> nodes has height at most 2*log(n+1)</li>
</ul>


<h4>13.2 Rotations 312</h4>

<ul>
<li><strong>Rotation</strong>: A local operation in a search tree that preserves the binary-search-tree property.

<ul>
<li>left-rotation: counter-clockwise

<ul>
<li>set y</li>
<li>turn y's left subtree into x's right subtree</li>
<li>link x's parent to y</li>
<li>put x on y's left</li>
</ul>
</li>
<li>right-rotation: clockwise</li>
</ul>
</li>
</ul>


<h4>13.3 Insertion 315</h4>

<ol>
<li>insert node <strong>red</strong> <em>z</em> into tree T (Property 5)</li>
<li>auxiliary procedure RBinsertFixup(T,z) to re-color and rotate.Ω

<ul>
<li>Property 2 is violated if <em>z</em> is the root</li>
<li>Property 4 is violated if <em>z</em>'s parent is red.

<ul>
<li>Case 1: <em>z</em>'s uncle <em>y</em> is red: z上两层反色</li>
<li>Case 2: <em>z</em>'s uncle <em>y</em> is black and <em>z</em> is a right child: around z left-rotate</li>
<li>Case 3: <em>z</em>'s uncle <em>y</em> is black and <em>z</em> is a left child: around z's parent right-rotate + z上两层反色</li>
</ul>
</li>
<li>O(lgn)</li>
</ul>
</li>
</ol>


<h4>13.4 Deletion 323</h4>

<ul>
<li>RBTransplant(T, u, v): replace subtree u with subtree v. mind NIL node as parent and leaves</li>
</ul>


<p>TODO</p>

<h3>14 Augmenting Data Structures 339</h3>

<h4>14.1 Dynamic order statistics 339</h4>

<ul>
<li><strong>Rank of an element</strong>: its position in the linear order of the set</li>
<li><strong>Order-statistic tree</strong>: RBT + every node has <em>x.size</em> = number of nodes in its subtree, including the NIL sentinel

<ul>
<li><em>x.size</em> = <em>x.left.size</em> + <em>x.right.size</em> + 1</li>
</ul>
</li>
</ul>


<h4>14.2 How to augment a data structure 345</h4>

<ol>
<li>Choose an underlying data structure.</li>
<li>Determine additional information to maintain in the underlying data structure.</li>
<li>Verify that we can maintain the additional information for the basic modifying operations on the underlying data structure.</li>
<li>Develop new operations.</li>
</ol>


<h4>14.3 Interval trees 348</h4>

<p>RBT + operations on dynamic sets of intervals.</p>
]]></content>
  </entry>
  
</feed>
