<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming_language | Puncsky CS Notebook]]></title>
  <link href="http://www.puncsky.com/blog/categories/programming-language/atom.xml" rel="self"/>
  <link href="http://www.puncsky.com/"/>
  <updated>2016-02-13T11:14:44-08:00</updated>
  <id>http://www.puncsky.com/</id>
  <author>
    <name><![CDATA[Tian]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Miguel de Icaza: Callbacks 就像我们这一代人的 Go To 语句]]></title>
    <link href="http://www.puncsky.com/blog/2015/02/04/callbacks-as-our-generations-goto/"/>
    <updated>2015-02-04T18:04:00-08:00</updated>
    <id>http://www.puncsky.com/blog/2015/02/04/callbacks-as-our-generations-goto</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://tirania.org/blog/archive/2013/Aug-15.html">Miguel de Icaza</a></p>

<p>译者：潘天 (puncsky)</p>

<p>本周，我一直在准备一份讲稿，主题为“让 C# 在 iOS 和 Android 上欢唱”，我突然意识到，基于 callback 的编程，从某种程度上说，竟然成为了大家可以接受的编程方式。</p>

<p>成为了大家可以接受的编程方式，就好像用 IF / GOTO 写代码在上世纪六十年代可以被大家接受一般。他们之所以可以被接受，是因为那时候没有更好的东西来替代他们。</p>

<p>时至今日，C# 和 F# 都支持这种基于 callback 的编程方式。然而这种编程方式却让我们这一代人重蹈覆辙，如同六十年代结构化编程、高级语言、控制流语句对开发者所干的那些事情一般。</p>

<p>可悲的是，很多开发者一听到 “C# <code>async</code>” 就立马想到了 “我的编程语言有 callback”。类似的回答还有 “<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 更好”，“<a href="http://en.wikipedia.org/wiki/Futures_and_promises">Future</a> 才是正道”，“Objective-C 有 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html">block</a> 了”，“<a href="http://en.wikipedia.org/wiki/Asynchronous_I/O">操作系统有那个功能</a>”。所有的这些说法，都出自于那些还没学习过 C# 的人之口，或者他们还不知道它有多么地美妙。</p>

<p>这次，我要解释，为什么对开发者来说，C# <code>async</code> 模型是一次巨大的飞跃。</p>

<h2>Callback 是创可贴</h2>

<p>Callback 这些年来进展显著。在纯 C 语言的年代，如果你要用 callback ，代码会是这样的：</p>

<p>``` c
void cback (void <em>key, void </em>value, void *user_state)
{</p>

<pre><code>// 我们的数据存在 user_state 中, 把它拿出来
// 在这里，它就是个 int 整数
int *sum = (int *) user_state;

*sum = *sum + *(int *)value;
</code></pre>

<p>}</p>

<p>int sum_values (Hashtable *hash)
{</p>

<pre><code>int sum = 0;

hash_table_foreach (hash, cback, &amp;sum);
return sum;
</code></pre>

<p>}
```</p>

<p>开发者不得不把这些指向状态的指针传来传去，手动管理，如此地笨拙。</p>

<p>而当今这些支持 lambda 表达式的语言，能让你的代码自动保留状态。所以上面的东东就变成了这样：</p>

<p>``` csharp
int sum_values (Hashtable hash)
{</p>

<pre><code>int sum = 0;
hash.foreach ((key, value) =&gt; { sum += value; });
return sum;
</code></pre>

<p>}
```</p>

<p>Lambda 让写代码更加轻松简单，如今我们能看到很多应用程序 UI 会用到 events / lambdas 与用户的输入交互，JavaScript 则在浏览器和客户端拿 callback 完成工作。</p>

<p>Node.js 最初的想法就是，去掉那些阻塞的操作 (blocking operations)，取而代之以纯 callback 驱动的异步模型。就桌面应用而言，通常需要链接一系列的操作，“当响应点击的时候，下载文件，解压缩，保存到用户指定的位置”，此时，UI 操作和背景操作就交杂在一起。</p>

<p>于是就产生了一些 callbacks 嵌套在另外的 callbacks 中，他们每个的缩进的层级对应着在未来的某个时间点执行。有人说，这就是 <a href="http://callbackhell.com/">Callback Hell</a>.</p>

<p>本周，Marco Arment 恰好 tweet 了一条消息，大意是一堆 block callback 们深深地混杂在一起，产生了滑稽的效果。</p>

<p>这其实很常见，在我们的网站上，做异步操作时，我们发布了这样的范例：</p>

<p>``` csharp
private void SnapAndPost ()
{</p>

<pre><code>Busy = true;
UpdateUIStatus ("Taking a picture");
var picker = new Xamarin.Media.MediaPicker ();
var picTask = picker.TakePhotoAsync (new Xamarin.Media.StoreCameraMediaOptions ());
picTask.ContinueWith ((picRetTask) =&gt; {
    InvokeOnMainThread (() =&gt; {
        if (picRetTask.IsCanceled) {
            Busy = false;
            UpdateUIStatus ("Canceled");
        } else {
            var tagsCtrl = new GetTagsUIViewController (picRetTask.Result.GetStream ());
            PresentViewController (tagsCtrl, true, () =&gt; {
                UpdateUIStatus ("Submitting picture to server");
                var uploadTask = new Task (() =&gt; {
                    return PostPicToService (picRetTask.Result.GetStream (), tagsCtrl.Tags);
                });
                uploadTask.ContinueWith ((uploadRetTask) =&gt; {
                    InvokeOnMainThread (() =&gt; {
                        Busy = false;
                        UpdateUIStatus (uploadRetTask.Result.Failed ? "Canceled" : "Success");
                    });
                });
                uploadTask.Start ();
            });
        }
    });
});
</code></pre>

<p>}
```</p>

<p>这般 callback 们嵌套所导致的问题是，你会很快发现，你根本就不想碰这堆乱糟糟的代码。它确实做了一些基本的错误处理 (basic error handling)，但是却没有丝毫做好错误恢复 (error recover)的意图。</p>

<p>我停下来慢慢思考，如何扩展上述功能，或许还有更好地做法，能够让我避免这种潦草的实现？</p>

<p>如果我想要更好的错误恢复，代码逻辑更加流畅，我会发现，需要类似记流水账一般，在每一处代码的出口，（以及我可能会拓展处的出口），手动核对每个 <code>Busy</code> 值的正确性，真烦躁。</p>

<p>这种丑陋的实现会让你走神："或许可以刷一刷 hacker news 啦"，"又有新的喵星人帖到 catoverflow.com 上了吗？"</p>

<p>注意，如上代码中每一个 lambda  都会产生一次上下文切换：从背景线程 (background threads) 切换到前景线程 (foreground threads) 。可以想象，真实世界中这种代码会更加地庞杂，加入更多的功能，也就会有更多的 bug 积累在犄角旮旯，难以被注意得到。</p>

<p>这让我想到了 Dijkstra 的 《Go To 语句有害论》，他在六十年代是这么说的：</p>

<blockquote><p>多年来，我一直注意到，程序员的水平和他们goto语句的使用频率成递减关系。直到前段时间，我发现了为什么使用goto语句会有如此恶劣的影响。我相信所有的“高级”编程语言都不应该再支持goto语句。那时候我还没有意识到这一发现的重要性，但在直到最近的一次讨论中，有人敦促我发表这些看法，我才提交这篇文章。</p>

<p>我的第一个看法是，虽然程序员的工作在他们写出了正确的程序 (program) 后就结束了，但在此程序控制下的进程 (process) 才是真正重要的，因为正是进程来达成预期的效果，正是进程的动态行为要满足程序员预期的规范。一旦程序写完后，相应的进程就转交给了机器来做了。</p>

<p>我的第二个看法是，<strong>我们的大脑善于处理静态关系，却不善于想象随时间推进的进程。</strong>所以我们应该（聪明的程序员明白自己的局限性）尽力缩小静态程序和动态进程之间的概念差距，让文本里的程序 (program) 和时间轴上的进程 (process) 的对应关系尽量简单。</p></blockquote>

<p>而这，恰恰是我们现在正在面对的问题——混杂嵌套的 callback 所导致的问题。</p>

<p>就像是那 GOTO 的年代，或者是手动内存管理的年代，我们这一代人也正在成为光荣的会计师，勤勤恳恳地在每条代码路径下核查那些状态，该重置的重置，该修改的修改，该抛弃的抛弃，该交付的交付。</p>

<p>作为一个可以进化的物种，我们理所应当地能够做得更好。</p>

<p>就在这个节骨眼上，C# <code>async</code> （和 F#）到来了。每当你在程序中放入<code>await</code> 关键字，编译器就知道你程序中的这一点需要被挂起，切换做某背景操作。一旦 task 执行完毕，程序执行就恢复到这 <code>await</code> 一点的位置。</p>

<p>如上丑陋的代码，会变成这样：</p>

<p>``` csharp
private async Task SnapAndPostAsync ()
{</p>

<pre><code>try {
    Busy = true;
    UpdateUIStatus ("Taking a picture");
    var picker = new Xamarin.Media.MediaPicker ();
    var mFile = await picker.TakePhotoAsync (new Xamarin.Media.StoreCameraMediaOptions ());
    var tagsCtrl = new GetTagsUIViewController (mFile.GetStream ());
    // Call new iOS await API
    await PresentViewControllerAsync (tagsCtrl, true);
    UpdateUIStatus ("Submitting picture to server");
    await PostPicToServiceAsync (mFile.GetStream (), tagsCtrl.Tags);
    UpdateUIStatus ("Success");
} catch (OperationCanceledException) {
    UpdateUIStatus ("Canceled");
} finally {
    Busy = false;
}
</code></pre>

<p>}
```</p>

<p>编译器处理如上代码后，编译的产物和人写的代码间就没有（按照同样的顺序）一行行直接对应的关系了。类似的事情会发生在 C# iterator  甚至 lambda 身上。</p>

<p>这种代码看上去很线性，这样一来，我就能信心满满地修改程序流。或是使用条件语句开不同的背景进程，或是使用循环语句把图片存到不同的位置，又或是一次性使用多个过滤器。Jeremie 恰巧写了篇<a href="https://blog.neteril.org/blog/2013/07/05/data-extraction-mobile-apps-with-xamarin/">不错的文章做这些事情</a>。</p>

<p>注意，因为 <code>finally</code> 语句，<code>Busy</code> 状态的处理变得集中而简洁。我现在能够保证，变量总是合理地得到了维护，无论在这段代码长怎么样，发生了什么。</p>

<p>记流水账这种事情，就交给了编译器。</p>

<p><code>async</code> 让我能够动用流程图上的那些基本元素，来思考我的软件。而不是按照那些紧紧耦合在一起的混乱而粗糙的进程们来做同样的事情。</p>

<h2>思维的解放</h2>

<p>C# 编译器处理 <code>async</code> 的基础是 <code>Task</code> 原生类型。<code>Task</code> 类正是其他编程语言所谓的那些 future, promise 和 async，难免会导致混淆。</p>

<p>此刻，我把所有的这些框架（包括 .NET 里的这只）都比作很底层的基础水暖管道。</p>

<p><code>Task</code> 类封装一系列的操作，由一些 properties 来反应它们的执行状态、结果（如果完成的话）、抛出的异常或者错误。有很丰富的 API 来有趣地组合这些 task ：等待所有、等待一些、聚合很多个成一个，等等不一而足。</p>

<p>那些（callback 的做法）尽管很重要，比起你自己惯常的做法已经是很大的进步了，但它们却并不能帮你解放思维。C# <code>async</code> 却可以。</p>

<h2>关于 <code>async</code> 关键字的常见问答</h2>

<p>借这次机会，我要直接回答下列问题：</p>

<p>问：每次使用 <code>async</code> 的时候会创建新的线程么？</p>

<p>答：当你使用 <code>async</code> method 的时候，你的操作被封装在 <code>Task</code> (或者 <code>Task&lt;T&gt;</code>) 对象中。有时候，这些操作需要另一个线程去跑；有时候，这些操作会进入事件队列，供给事件循环去处理(runloop)；有时候，这些操作会调用带有通知机制的内核异步API. 你不会确定地知道幕后到底发生了什么，这取决于 <code>async</code> method 自己的实现。(译者注：调用 <code>async</code> method 不会产生新的线程，但是 <code>async</code> method 内部，开发者自己定义的实现里面可以开新的线程。)</p>

<p>问：在使用 <code>async</code> 的时候，你似乎不再需要 <code>InvokeOnMainThread</code>了，为啥呢？</p>

<p>答：当 task 结束的时候，执行流程会默认恢复到当下同步的上下文，这是因为 <code>ThreadLocal</code> 的 property 指向了<code>SynchronizationContext</code> 的某个具体实现。</p>

<p>在 iOS 和 Android 上，我们在 UI 线程设定一个<code>SynchronizationContext</code>，确保代码每次都恢复到主线程上。微软在它们的平台上也在做同样的事情。</p>

<p>而且，在 iOS 上，我们还有一个 <code>DispatchQueue</code> 同步上下文，因此默认情况下，用<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html">Grand Central Dispatch (GCD)</a>调用 await ，完成后会回到那个 queue.</p>

<p>当然你可以调整这一行为，用 <code>SynchronizationContext</code> 和 <code>ConfigureAwait</code>。</p>

<p>最后，PFX team 有篇不错的  <a href="http://blogs.msdn.com/b/pfxteam/archive/2012/04/12/async-await-faq.aspx">FAQ for Async and Await</a>.</p>

<h2><code>async</code> 的参考资源</h2>

<p>这儿有些不错的 <code>async</code> 学习资料：</p>

<ul>
<li>Microsoft's <a href="http://www.microsoft.com/en-us/download/details.aspx?id=19957">Task-based Asynchronous Pattern</a> shows great idioms to use with Async.</li>
<li><a href="http://blogs.msdn.com/b/pfxteam/">Parallel Programming with .NET blog</a>.</li>
<li><a href="http://praeclarum.org/post/45277337108/await-in-the-land-of-ios-scripting-users">Very cute use of Async</a> for adding an interactive walkthrough to your mobile app.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Essential C# 4.0: Advanced]]></title>
    <link href="http://www.puncsky.com/blog/2013/09/15/essential-c-sharp-advanced/"/>
    <updated>2013-09-15T13:58:00-07:00</updated>
    <id>http://www.puncsky.com/blog/2013/09/15/essential-c-sharp-advanced</id>
    <content type="html"><![CDATA[<p>This is the third and final part of my series of notes on learning C#.</p>

<ol>
<li><a href="http://www.puncsky.com/blog/2013/08/14/essential-c-sharp-basics/">Essential C# 4.0: Basics</a></li>
<li><a href="http://www.puncsky.com/blog/2013/09/05/essential-c-sharp-intermediate/">Essential C# 4.0: Intermediate</a></li>
<li>Essential C# 4.0: Advanced(this post)</li>
</ol>


<p>In general, C# leaves me an unpleasant impression of redundancy and tyranny. The designers of the language seem to be always mocking "oh my stupid boy, we have to spare no effort to prevent you from making stupid mistakes~" However, this idea of design is <em>good</em> to some extend.</p>

<p>My passion on coding is mostly inspired by the colorful vim on Ubuntu. <em>It is amazing fun. I love it!!</em> So the first app I install on my new Windows workstation is, of course, cygwin. Now I have to use Visual Studio, so the first plugin I install on it is surely vsvim. Moreover, maybe I am not a guy of Eclipse. I can see no beauty and usability in it, although it is much more extensible than Visual Studio. The experience of configuring the build environment of Android and later Hadoop is awful and drives me crazy.</p>

<p>As to the last chapters of this book, I am not interested in muti-processing/multi-threading in Windows OS, which is much slower than *nix OS and thus somewhat boring. Windows was not designed to be a multiprocessing and multi-user platform in the first place; instead, it was originally intended for <em>personal</em> usage. So I just skimmed this chapter. Maybe I will revisit it someday when I have to exhaust the computing power on Windows. May that not happen.</p>

<p>At last, C# is not designed for manipulating pointers and addresses directly. Why do we bother to study it? We have C/C++ already. So I also just skimmed the last two chapters. :D</p>

<p>The following is my notes.</p>

<!--more-->


<h2>14 Collection Interfaces with Standard Query Operators 535</h2>

<ol>
<li>Anonymous Types

<ul>
<li><code>var patent = new {Title = "Bifocals", YearOfPublication = "1784"}</code></li>
</ul>
</li>
<li>Implicit Typed Local Variables (<code>var</code>)

<ul>
<li>There is no difference in the resultant CIL code for implic- itly typed variables whose assignment is not an anonymous type (such as string) and those that are declared as type string.</li>
<li><strong><em>still strongly typed as well by the compiler.</em></strong>

<ul>
<li><em>Language Contrast</em>: JavaScript's var is dynamically typed. <a href="http://stackoverflow.com/questions/8457813/difference-between-the-implementation-of-var-in-javascript-and-c-sharp">See here</a>. C# is (usually) a statically typed language.</li>
</ul>
</li>
<li>You should use implicitly typed variable declarations sparingly

<ul>
<li>To accomplish this with implicitly typed local variables, use them only when the type assigned to the implicitly typed variable is entirely obvious and makes themselves more readable.</li>
<li>e.g. <code>var items = new Dictionary&lt;string, List&lt;Account&gt;&gt;();</code></li>
<li>e.g. <code>Dictionary&lt;string, List&lt;Account&gt;&gt; dictionary = GetAccounts();</code></li>
<li>the requirements for two anonymous types to be type-compatible within the same assembly are a match in property names, data types, and order of properties.</li>
</ul>
</li>
</ul>
</li>
<li>Collection Initializers</li>
<li>Collections

<ul>
<li>Arrays(length fixed, index operator supported)

<ul>
<li><code>foreach(TItem item in array) {}</code></li>
</ul>
</li>
<li>IEnumerable<T> (such as <code>Stack&lt;T&gt;</code>, <code>Queue&lt;T&gt;</code>, <code>Dictionary&lt;Tkey, Tvalue&gt;</code>)

<ul>
<li><code>while (stack.MoveNext()) {number = stack.Current; Console.WriteLine(number)}</code></li>
<li><strong>The state of moving to the next is shared.</strong> So we need <code>Enumerator</code> and <code>GetEnumerator()</code></li>
<li><code>Dispose()</code> the enumerator's state. A more simplified version in the example.</li>
</ul>
</li>
<li><code>foreach</code> without <code>IEnumerable</code>?

<ul>
<li>"duck typing": if no IEnumerable/IEnumerable<T> method is found, it looks for the <code>GetEnumerator()</code> method to return a type with Current() and MoveNext() methods. Duck typing involves searching for a method by name rather than relying on an interface or explicit method call to the method.</li>
</ul>
</li>
<li><strong><em>compiler prevents assignment of the foreach variable</em></strong> Do not modify the collection during a foreach loop.</li>
</ul>
</li>
<li><strong>Standard Query Operators</strong>

<ul>
<li>Each method on <code>IEnumerable&lt;T&gt;</code> is a standard query operator</li>
<li>Filtering with <code>Where()</code>

<ul>
<li>A delegate expression that takes an argument and returns a Boolean is called a <strong>predicate</strong></li>
</ul>
</li>
<li>Projecting with <code>Select()</code>

<ul>
<li><code>IEnumerable&lt;FileInfo&gt; files = fileList.Select(file =&gt; new FileInfo(file))</code></li>
<li>PLINQ(Parallel LINQ): <code>.AsParallel().</code> See CH18, CH19</li>
</ul>
</li>
<li>Counting with <code>Count()</code></li>
<li><strong><em>Deferring Execution</em></strong>: One of the most important concepts to remember when using LINQ

<ul>
<li>At the time of declaration(".Where()"), lambda expressions do not execute. It isn’t until the lambda expressions are invoked (<code>foreach</code>) that the code within them begins to execute.</li>
<li><strong>To avoid such repeated execution, it is necessary to cache the data that the executed query retrieves.</strong> To do this, you assign the data to a local collection using one of the “To” method’s collection methods.</li>
</ul>
</li>
<li>Sorting with <code>OrderBy()</code> and <code>OrderBy().ThenBy()</code>

<ul>
<li>return a <code>IOrderedEnumerable&lt;T&gt;</code> instead of <code>IEnumerable&lt;T&gt;</code></li>
</ul>
</li>
<li><code>IEnumerable&lt;IGrouping&lt;int, Employee&gt;&gt; groupedEmployees = employees.GroupBy((employee) =&gt; employee.DepartmentId);</code></li>
<li><code>GroupJoin()</code>, <code>SelectMany()</code>...</li>
</ul>
</li>
</ol>


<p>``` cpp
using(System.Collections.Generic.Stack<int>.Enumerator<int></p>

<pre><code>  enumerator = stack.GetEnumerator()) {
while (enumerator.MoveNext()) {
    number = enumerator.Current;
    Console.WriteLine(number);
}
</code></pre>

<p>}
```</p>

<h2>15 LINQ with Query Expressions 589</h2>

<ul>
<li><strong>More readable and SQL-like query expressions</strong>, when compared to Standard Query Operators</li>
</ul>


<h2>16 Building Custom Collections 611</h2>

<ol>
<li>More Collection Interfaces

<ul>
<li><code>IList&lt;T&gt;</code></li>
<li><code>IDictionary&lt;TKey, TValue&gt;</code></li>
<li><code>IComparable&lt;T&gt;</code></li>
<li><code>ICollection&lt;T&gt;</code></li>
</ul>
</li>
<li>Primary Collection Classes

<ul>
<li><code>List&lt;T&gt;</code></li>
<li><code>Dictionary&lt;TKey, TValue&gt;</code></li>
<li><code>SortedDictionary&lt;TKey, TValue&gt;</code> and <code>SortedList&lt;T&gt;</code></li>
<li><code>Stack&lt;T&gt;</code></li>
<li><code>Queue&lt;T&gt;</code></li>
<li><code>LinkedList&lt;T&gt;</code></li>
</ul>
</li>
<li>Providing an Index Operator <code>[]</code>

<ul>
<li><code>public T1 this[T2 index] {}</code> and <code>public T this[params PairItem[] branches] {}</code></li>
</ul>
</li>
<li>Returning null or an Empty Collection

<ul>
<li>The better choice in general is to return a collection instance with no items.</li>
<li>One of the few times to deviate from this guideline is when <code>null</code> is intentionally indicating something different from zero items. e.g. telephone number, <code>null</code> for not set, empty for no phone number</li>
</ul>
</li>
<li>Iterators, <code>IEnumerator&lt;T&gt;</code> and <code>IEnumerator</code>

<ul>
<li>If classes want to support iteration using the foreach loop construct, they must implement the enumerator pattern.</li>
<li>Defining</li>
<li>Syntax

<ol>
<li>the class should derive from <code>IEnumerable&lt;T&gt;</code></li>
<li><code>public IEnumerator&lt;T&gt; GetEnumerator() {}</code> method</li>
</ol>
</li>
<li><strong><em>yield</em></strong>

<ul>
<li>Iterators are like functions, but instead of returning values, they yield them. 生成一个个即将被iterate 的结果？</li>
<li><code>yield return SomeObject;</code> you can use yield only in <code>GetEnumerator()</code> methods that return <code>IEnumerator&lt;T&gt;</code>, or in methods that return <code>IEnumerable&lt;T&gt;</code> but are not called GetEnumerator().

<ul>
<li>C# compiler generates the code to maintain the state machine for the iterator.</li>
</ul>
</li>
<li><code>yield break;</code></li>
<li>some other restrictions: P649</li>
</ul>
</li>
</ul>
</li>
</ol>


<h2>17 Reflection, Attributes, and Dynamic Programming 651</h2>

<p><strong>Reflection</strong> is the process of examining the metadata within an assembly.</p>

<ol>
<li>Accessing Metadata Using <code>System.Type</code>

<ul>
<li><code>GetType()</code></li>
<li><code>typeof()</code></li>
</ul>
</li>
<li>Member Invocation

<ul>
<li><code>type.GetProperty()</code> and <code>property.SetValue()</code> see examples</li>
</ul>
</li>
<li>Reflection on Generics

<ul>
<li><code>type.IsGenericType</code></li>
<li><code>foreach(Type type in t.GetGenericArguments()) {}</code></li>
</ul>
</li>
<li>Custom Attributes

<ul>
<li>attributes are a means of associating additional data with a property (and other constructs).</li>
<li><em>Language Contrast</em>: Attributes are to C# what annotations are to Java</li>
<li>2 ways to combine

<ol>
<li><code>[Attr1] [Attr2]</code></li>
<li><code>[Attr1, Attr2]</code></li>
</ol>
</li>
<li>custom attributes

<ul>
<li><code>public class CLISwitchRequiredAttribute : Attribute {}</code></li>
</ul>
</li>
<li>get custom attributes

<ul>
<li><code>Attribute[] a = (Attribute[])property.GetCustomAttributes(...)</code></li>
</ul>
</li>
</ul>
</li>
<li>Attribute Constructors

<ul>
<li><code>public class CLISwitchRequiredAttribute : Attribute { CLISwitchAliasAttribute(string alias) {Alias = alias;}}</code></li>
</ul>
</li>
<li>Named Parameters</li>
<li>Predefined Attributes

<ul>
<li><code>AttributeUsageAttribute</code> before the attribute class to set target properties</li>
<li><code>ConditionalAttribute("CONDITION_BLAH")</code> before the methods to call on condition of <code>#define CONDITION_BLAH</code></li>
<li><code>ObsoleteAttribute</code> causes a compile-time warning, optionally an error.</li>
<li><code>Serializable</code> before class for storage

<ul>
<li><code>NonSerializable</code></li>
<li>version problem? <code>System.Runtime.Serialization.OptionalFieldAttribute</code></li>
</ul>
</li>
</ul>
</li>
<li>Dynamic Objects

<ul>
<li>Dynamic object support provides a common solution for talking to runtime environments that don’t necessarily have a compile-time-defined structure.</li>
<li>The key difference when using a dynamic object is that it is necessary to identify the signature at compile time, rather than determine things such as the member name at runtime (like we did when parsing the command-line arguments).</li>
<li>TODO</li>
</ul>
</li>
</ol>


<p>```
// Using Type.GetProperties() to Obtain an Object's Public Properties
DateTime dateTime = new DateTime();</p>

<p>Type type = dateTime.GetType();
foreach(System.Reflection.PropertyInfo property in type.GetProperties()) {</p>

<pre><code>Console.WriteLine(property.Name);
</code></pre>

<p>}
```</p>

<h2>18 Multithreading 701</h2>

<p>thread, time slicing.</p>

<p>In .NET Framework 4, the task requests a thread from the thread pool.</p>

<ul>
<li><p><code>Task</code> in <strong>Task Parallel Library</strong></p>

<ul>
<li><code>class Task(Delegate Func);</code> and <code>class Task&lt;TResult&gt;(Delegate Func)</code></li>
<li><code>task.Result</code>, <code>task.IsCompleted</code>, <code>task.Id</code>, <code>task.AsyncState</code>, static <code>Task.CurrentId</code>,</li>
</ul>
</li>
<li><p>Parallel Loops</p>

<ul>
<li><code>Parallel.For()</code></li>
<li><code>Parallel.ForEach&lt;T&gt;()</code></li>
</ul>
</li>
<li>Unhanded Exceptions</li>
<li><strong>Parallel LINQ</strong></li>
<li>Multithreaded Programming with Tasks

<ul>
<li>Task Basiscs</li>
<li><code>ContinueWith()</code></li>
<li>Unhandled Exceptions</li>
</ul>
</li>
<li>TPL Cancellation Requests

<ul>
<li>Canceling a Task</li>
<li>Canceling Parallel Loops</li>
<li>Canceling a Task</li>
</ul>
</li>
<li><del>Multithreaded Programming before TPL (Before .NET 4)</del></li>
</ul>


<p>``` cpp
// Task
using System;
using System.Threading.Tasks;</p>

<p>public class Program {
  public static void Main() {</p>

<pre><code>const int repetitions = 10000;
Task task = new Task( () =&gt; {
    for (int count = 0; count &lt; repetitions; count++) {
      Console.Write('-');
    }   
}); 

task.Start();
for (int count = 0; count &lt; repetitions; count++) {
  Console.Write('.');
}   

// Wait until the Task completes
task.Wait();
</code></pre>

<p>  }
}
```</p>

<h2>19 Multithreading Patterns 749</h2>

<ul>
<li><p>Thread-safe: Code or dada synchronized for simultaneous access by multiple threads.</p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/ff963559.aspx">torn read</a>. When reading a variable requires more than one machine instruction, and another task writes to the variable between the read instructions.</p></li>
<li><p>Local variables are loaded onto the stack and each thread has its own logical stack. (But they can still be accessed by other threads.)</p></li>
<li><p>Synchronization</p>

<ul>
<li>Monitor

<ul>
<li>use a monitor to block the second thread from entering a protected code section before the first thread has exited that section. See the example.</li>
<li><code>_Sync</code> object, <code>try</code>/<code>finally</code></li>
</ul>
</li>
<li>Lock

<ul>
<li>Monitor is fallible with <code>try</code>/<code>finally</code> (forgettable)</li>
<li>use a per-synchronization context instance of type object for the lock target.</li>
<li>avoid locking <code>this</code>, <code>typeof(type)</code>, and <code>string</code>  TODO:??我的理解是不要从instance内部锁，一律从外部锁，防止死锁。</li>
</ul>
</li>
<li><p>Volatile <em>Language Contrast</em>:</p>

<ul>
<li>C#: ensures that code accessing the field is not subject to some thread unsafe optimizations that may be performed by the compiler, the CLR, or by hardware. (forces all reads and writes to the volatile field to occur at the exact location the code identifies instead of at some other location that the) optimization produces.</li>
<li>Java: read its current value before continuing, instead of (potentially) using a cached value. Volatile reads and writes establish a happens-before relationship, much like acquiring and releasing a mutex.</li>
<li>C: volatile exists for specifying special treatment for such locations, specifically: (1) the content of a volatile variable is "unstable" (can change by means unknown to the compiler), (2) all writes to volatile data are "observable" so they must be executed religiously, and (3) all operations on volatile data are executed in the sequence in which they appear in the source code.

<ul>
<li>usage of volatile keyword as a portable synchronization mechanism <strong>is discouraged</strong> by many C/C++ groups.</li>
</ul>
</li>
</ul>
</li>
<li><p><code>System.Threading.Interlocked</code></p>

<ul>
<li>synchronization with System.Threading.Monitor is a relatively expensive operation</li>
<li>If <code>_Data</code> is <code>null</code> then set it to <code>newValue</code>

<ul>
<li><code>Interlocked.CompareExchange(ref _data, newValue, null);</code></li>
</ul>
</li>
</ul>
</li>
<li>Synchronization Best Practices

<ul>
<li>avoid deadlocks. Deadlock's 4 conditions:

<ol>
<li>Mutual exclusion</li>
<li>Hold and wait</li>
<li>No preemption</li>
<li>Circular wait condition</li>
</ol>
</li>
<li>All static data should be thread-safe.

<ul>
<li>programmers should declare private static variables and then provide public methods for modifying the data. Such methods should internally handle the synchronization.</li>
</ul>
</li>
</ul>
</li>
<li><code>Mutex</code></li>
<li>WaitHandle</li>
<li>Reset Events

<ul>
<li> reset events have nothing to do with C# delegates and events. Instead, reset events are a way to <strong>force code to wait for the execution of another thread until the other thread signals</strong></li>
<li>Favor <code>ManualResetEvent</code> and <code>Semaphores</code> over <code>AutoResetEvent</code></li>
</ul>
</li>
<li>Concurrent Collection Classes

<ul>
<li>designed to include built-in synchronization code so that they can support simultaneous access by multiple threads without concern for race conditions.</li>
<li><code>BlockingCollection&lt;T&gt;</code></li>
<li><code>ConcurrentBag&lt;T&gt;</code></li>
<li><code>ConcurrentDictionary&lt;TKey, TValue&gt;</code></li>
<li><code>ConcurrentQueue&lt;T&gt;</code></li>
<li><code>ConcurrentStack&lt;T&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>Thread Local Storage

<ul>
<li><code>ThreadLocal&lt;T&gt;</code></li>
<li><code>ThreadStaticAttribute</code></li>
</ul>
</li>
<li>Timers</li>
<li>Asynchronous Programming Model (APM)

<ul>
<li>the key aspect of the APM is the pair of <code>IAsyncResult BeginX()</code> and <code>EndX()</code> methods with well-established signatures.</li>
<li><code>WaitHandle</code> to determine when the asynchronous method completes.</li>
<li><code>EndX()</code>

<ol>
<li>block further execution until the successful complete</li>
<li>get the return data</li>
<li>receive the exception</li>
<li>clean up resources</li>
</ol>
</li>
</ul>
</li>
<li>Background Worker Pattern

<ul>
<li>TODO</li>
</ul>
</li>
<li>Windows UI Programming

<ul>
<li>TODO</li>
</ul>
</li>
</ul>


<p>``` cpp
// monitor
using System;
using System.Threading;
using System.Threading.Tasks;</p>

<p>class Program {
  // Note that calls to Monitor.Enter() and Monitor.Exit() are associated
  // with each other by sharing the same object reference passed as the
  // parameter (in this case <em>Sync).
  readonly static object </em>Sync = new object();
  const int <em>Total = int.MaxValue;
  static long </em>Count = 0;</p>

<p>  public static void Main() {</p>

<pre><code>Task task = Task.Factory.StartNew(Decrement);

// Increment
for (int i = 0; i &lt; _Total; i++) {
  bool lockTaken = false;
  Monitor.Enter(_Sync, ref lockTaken);
  try {
    _Count++;
  } finally {
    if (lockTaken) {
      Monitor.Exit(_Sync);
    }
  }
}

task.Wait();
Console.WriteLine("Count = {0}", _Count);
</code></pre>

<p>  }</p>

<p>  static void Decrement() {</p>

<pre><code>for (int i = 0; i &lt; _Total; i++) {
  bool lockTaken = false;
  Monitor.Enter(_Sync, ref lockTaken);
  try {
    _Count--;
  } finally {
    if (lockTaken) {
      Monitor.Exit(_Sync);
    }
  }
}
</code></pre>

<p>  }
}
```</p>

<p>``` cpp
// lock
using System;
using System.Threading;
using System.Threading.Tasks;</p>

<p>class Program {
  readonly static object <em>Sync = new object();
  const int </em>Total = int.MaxValue;
  static long _Count = 0;</p>

<p>  public static void Main() {</p>

<pre><code>Task task = Task.Factory.StartNew(Decrement);

// Increment
for (int i = 0; i &lt; _Total; i++) {
  lock (_Sync) {
    _Count++;
  }
}

task.Wait();
Console.WriteLine("Count = {0}", _Count);
</code></pre>

<p>  }</p>

<p>  static void Decrement() {</p>

<pre><code>for (int i = 0; i &lt; _Total; i++) {
  lock (_Sync) {
    _Count--;
  }
}
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>``` cpp
// mutex
// It cannot run correctly on Ubuntu with mono.
using System;
using System.Threading;
using System.Reflection;</p>

<p>class Program {
  public static void Main() {</p>

<pre><code>// Indicates whether this is the first
// application instance
bool firstApplicationInstance;

// Obtain the mutex name from the full
// assembly name.
string mutexName = Assembly.GetEntryAssembly().FullName;

using (Mutex mutex = new Mutex(false, mutexName, out firstApplicationInstance)) {
  if (!firstApplicationInstance) {
    Console.Write("This application is already running.");
  } else {
    Console.WriteLine("ENTER to shut down");
    Console.ReadLine();
  }   
}   
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>``` cpp
// APM
using System;
using System.IO;
using System.Net;
using System.Linq;</p>

<p>public class Program {
  public static void Main(string[] args) {</p>

<pre><code>string url = "http://www.puncsky.com";
if (args.Length &gt; 0) {
  url = args[0];
}   

Console.WriteLine(url);
WebRequest webRequest = WebRequest.Create(url);

// puncsky: `BeginX` method call
IAsyncResult asyncResult = webRequest.BeginGetResponse(null, null);

while (!asyncResult.AsyncWaitHandle.WaitOne(100)) {
  Console.Write('.');
}   

// puncsky: `EndX` method call
// Retrieve the results when finished
// downloading
WebResponse response = webRequest.EndGetResponse(asyncResult);
using (StreamReader reader = new StreamReader(response.GetResponseStream())) {
  int length = reader.ReadToEnd().Length;
  Console.WriteLine(FormatBytes(length));
}   
</code></pre>

<p>  }</p>

<p>  static public string FormatBytes(long bytes) {</p>

<pre><code>string[] magnitudes = new string[] { "GB", "MB", "KB", "Bytes" };
long max = (long)Math.Pow(1024, magnitudes.Length);

return string.Format("{1:##.##} {0}", magnitudes.FirstOrDefault(
    magnitude =&gt; bytes &gt; (max /= 1024))?? "0 Bytes", (decimal)bytes / (decimal)max).Trim();
</code></pre>

<p>  }
}
```</p>

<h2>20 Platform Interoperability and Unsafe Code 815</h2>

<ul>
<li>What if the memory addresses and pointers have be used?</li>
<li>3 ways

<ul>
<li>Platform Invoke (P/Invoke)</li>
<li><strong>unsafe code</strong></li>
<li><strong>COM</strong></li>
</ul>
</li>
</ul>


<h2>21 The Common Language Infrastructure 843</h2>

<ul>
<li>TODO</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Essential C# 4.0: Intermediate]]></title>
    <link href="http://www.puncsky.com/blog/2013/09/05/essential-c-sharp-intermediate/"/>
    <updated>2013-09-05T14:00:00-07:00</updated>
    <id>http://www.puncsky.com/blog/2013/09/05/essential-c-sharp-intermediate</id>
    <content type="html"><![CDATA[<p>This is the second part of my serials of notes on learning C#.</p>

<ol>
<li><a href="http://www.puncsky.com/blog/2013/08/14/essential-c-sharp-basics/">Essential C# 4.0: Basics</a></li>
<li>Essential C# 4.0: Intermediate (this post)</li>
<li><a href="http://www.puncsky.com/blog/2013/09/15/essential-c-sharp-advanced/">Essential C# 4.0: Advanced</a></li>
</ol>


<p>A productive-focused language like C# has so much <em>syntax sugar</em> that I feel not so comfortable with, because I used to be a C++ programmer and everything in the C++ kingdom appears to be straight forward, although, at the same time, tend to be fallible.</p>

<p>The most serious problem I find about Microsoft's tools is that up there exist so many auto-generated codes that I cannot know them all in details. I mean, that is good, you can ship as much stuff as possible within limited time. The problem is, it is not good for curious people like me, nor for the beginner. Back in school, when we build something, we build it <em>from scratch</em>. Perhaps, <em>reinvent the wheel</em> is the best way to learn the wheel. IEDs such as Visual Studio and Eclipse make people so lazy and forget to remember and to think.</p>

<p>Consequently, in my spare time, I would do write every code with VIM.</p>

<p>The following is my notes from Chapter 9 through Chapter 13.</p>

<!--more-->


<h2>9 Well-Formed Types 357</h2>

<ol>
<li>Overriding Object Members

<ul>
<li> Guidelines for overriding <code>System.Object</code> members. Reference on request.</li>
<li> <code>GetHashCode()</code></li>
<li> <code>ReferenceEquals()</code> Object Identity vs. <code>Equals()</code> Equal Object Values</li>
<li> Calling <code>ReferenceEquals()</code> on <em>value types</em> will always return false since</li>
</ul>
</li>
<li>Operator Overloading

<ul>
<li> <code>public static</code>

<ul>
<li>avoid recursive loop <code>(leftHandSide == null)</code> when check equality</li>
<li>One of the parameters of a operator must be the containing type</li>
</ul>
</li>
</ul>
</li>
<li>Referencing other Assemblies

<ul>
<li> Assembly Target: <code>csc /target:library /out:Coordinates.dll Coordinate.cs IAngle.cs</code>

<ul>
<li>console executable</li>
<li>class library</li>
<li>windows executable</li>
<li>module</li>
</ul>
</li>
<li> Reference an Assembly <code>csc /R:Coordinates.dll Program.cs</code></li>
<li> By default, a class without any access modifier is defined as <code>internal</code> (accessible from within the assembly only).</li>
</ul>
</li>
<li>Defining Namespaces

<ul>
<li> <strong><em>namespace alias qualifier</em></strong>

<ul>
<li><code>csc /R:CoordPlus=CoordinatesPlus.dll /R:Coordinates.dll Program.cs</code></li>
<li><code>extern alias CoordPlus;</code> before all <code>using</code> statements</li>
<li><code>using CoordPlus:
  Blah.Blah;</code> equally or <code>using CoordPlus.Blah.Blah;</code></li>
<li>How about global scope? <code>using global::Blah.Blah</code> (different from <code>using global.Blah.Blah</code> which means the real namespace of <code>global</code>)</li>
</ul>
</li>
</ul>
</li>
<li>XML Comments

<ul>
<li> <code>///</code>, <code>&lt;summary&gt;</code>, <code>&lt;remarks&gt;</code>, <code>&lt;param name="blah"&gt; &lt;param&gt;</code>, <code>&lt;returns&gt;</code>, <code>&lt;date&gt;</code></li>
<li> Generate an XML doc file <code>csc /doc:Comments.xml DataStorage.cs</code></li>
<li> tools to generate docs: GhostDoc, NDoc</li>
</ul>
</li>
<li>GC

<ul>
<li> <strong>Weak reference</strong> save the reference for future reuse (memory cache) <code>private WeakReference Data;</code></li>
<li> Finalizer: <code>~ClassName()</code> (注意，不是Dispose) like <a href="http://www.puncsky.com/blog/2013/01/14/gc-garbage-collection-in-java/">Java's <code>finalize()</code></a>一般<code>~ClassName()</code>会检查<code>Dispose</code>是否已经被调用</li>
<li> Deterministic finalization with the <code>using</code> statement

<ul>
<li>The <code>IDisposable</code> interface defines the details of the pattern with a single method called <code>Dispose()</code>, which developers call on a resource class to “dispose” of the consumed</li>
<li>HOWEVER, there is a chance that an exception will occur before the dispose call resources. If this happens, Dispose() will not be invoked and the resource cleanup will have to rely on the finalizer.</li>
<li>SO 2 ways:

<ol>
<li>try / finally</li>
<li><code>using</code> statement and <strong>all variables are of the same type and they implement <code>IDisposable</code></strong></li>
</ol>
</li>
</ul>
</li>
<li> The <strong><em>f-reachable queue</em></strong> is a list of all the objects that are ready for
garbage collection and that also have finalization implementations. <code>System.GC.SuppressFinalize(reference)</code> can remove reference instance from f-reachable queue.</li>
<li> Resource Utilization and Finalization Guidelines. Refer the book page 400.</li>
<li> Generally, <code>~Destructor()</code> calls <code>Dispose()</code></li>
<li> <strong>Lazy Initialization</strong>: Defer the init of an object until it is required.

<pre><code> - `System.Lazy&lt;T&gt;`
</code></pre></li>
</ul>
</li>
</ol>


<p>``` cpp
// Lazy Initialization
using System.IO;</p>

<p>class DataCache
{
  // ...</p>

<p>  public DataCache(string FileStreamName)
  {</p>

<pre><code>_FileStream = new Lazy&lt;TemporaryFileStream&gt;(
    () =&gt; new TemporaryFileStream(FileStreamName));
// the lambda expression provides a means of passing the
//  instructions for what will happen, but not actually performing those
//  instructions until explicitly requested.
</code></pre>

<p>  }</p>

<p>  public TemporaryFileStream FileStream
  {</p>

<pre><code>get
{
  return _FileStream.Value;
}
</code></pre>

<p>  }
  private Lazy<TemporaryFileStream> _FileStream;</p>

<p>  // ...
}
```</p>

<h2>10 Exception Handling 405</h2>

<ol>
<li>Multiple Exception Types</li>
<li>Catching Exception</li>
<li>General Catch Block</li>
<li>Guidelines</li>
<li>Custom Exceptions</li>
</ol>


<h2>11 Generics 421</h2>

<ol>
<li>Generics

<ul>
<li>name rule as <code>EntityCollection&lt;TEntity&gt;</code></li>
<li><code>public class Tuple&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;: ... {...}</code>, <code>TRest</code> can be used to store another tuple.</li>
<li><code>Tuple.Create("555-55-5555", new Contact("Tim Pan"));</code> == <code>new Tuple&lt;string, Contact&gt;("555-55-5555", new Contact("Tim Pan"));</code></li>
</ul>
</li>
<li><strong><em>Constraints</em></strong>: To avoid a runtime exception and instead provide a compile-time error, C# enables you to supply an optional list of <strong>constraints</strong> for each type parameter declared in the generic class by using <code>where</code>.

<ul>
<li>Interface Constraints</li>
<li>Base Class Constraints</li>
<li><code>struct</code>/<code>class</code> Constraints</li>
<li>Multiple Constraints</li>
<li><strong>Constructor Constraints</strong>: ensure default ctor like <code>new ctor()</code></li>
</ul>
</li>
<li>Generic Methods

<ul>
<li>explicit cast is preferred at most of the times.</li>
</ul>
</li>
<li>Variance <code>Type1&lt;Type2&gt;</code> and <code>Type3&lt;Type2&gt;</code> are not <em>covariant</em>.

<ul>
<li>Covariance TODO: Read Again

<ul>
<li>with <code>out</code> for getters</li>
<li>with <code>in</code> for setters</li>
</ul>
</li>
<li>Contra variance</li>
</ul>
</li>
<li>Generic Internals

<ul>
<li><em>Language Contrast</em>: Sun's implementation of generics for Java occurs within the compiler entirely, not within the JVM. JVM cannot support generics for value types.</li>
</ul>
</li>
</ol>


<p>``` cpp
// Needing the type parameter to support an interface or exception thrown
public class BinaryTree<T>
{</p>

<pre><code>// ...
public Pair&lt;BinaryTree&lt;T&gt;&gt; SubItems
{
    get { return _SubItems; }
    set {
        IComparable&lt;T&gt; first;
        first = (IComparable&lt;T&gt;)value.First.Item;

        if (first.CompareTo(value.Second.Item) &lt; 0)
        {
            // first is less than second.
        }
        else
        {
            // second is less than first.
        }
        _SubItems = value;
    }
}
private Pair&lt;BinaryTree&lt;T&gt;&gt; _SubItems;
</code></pre>

<p>}</p>

<p>// Declaring the interface constrant
public class BinaryTree<T></p>

<pre><code>where T: System.IComparable&lt;T&gt;
</code></pre>

<p>{</p>

<pre><code>// ...
public Pair&lt;BinaryTree&lt;T&gt;&gt; SubItems
{
    get{ return _SubItems; }
    set
    {
        IComparable&lt;T&gt; first;
        // Notice that the cast can now be eliminated.
        first = value.First.Item;

        if (first.CompareTo(value.Second.Item) &lt; 0)
        {
            // first is less than second
        }
        else
        {
            // second is less than or equal to first
        }
        _SubItems = value;
    }
}
private Pair&lt;BinaryTree&lt;T&gt;&gt; _SubItems;
</code></pre>

<p>}
```</p>

<p>``` cpp
// multiple constraints
// an AND relationship is assumed
public class EntityDictionary&lt;TKey, TValue></p>

<pre><code>: Dictionary&lt;TKey, TValue&gt;
where TKey : IComparable&lt;TKey&gt;, IFormattable
where TValue : EntityBase
</code></pre>

<p>{</p>

<pre><code>// ...
</code></pre>

<p>}
```</p>

<p>``` cpp
// constructor constraints ensure default ctors only
// Ctors with parameters are NOT supported
public class EntityDictionary&lt;TKey, TValue> :</p>

<pre><code>Dictionary&lt;TKey, TValue&gt;
where TKey: IComparable&lt;TKey&gt;, IFormattable
where TValue : EntityBase&lt;TKey&gt;, new()
</code></pre>

<p>{</p>

<pre><code>//...
TValue newEntity = new TValue();
//...
</code></pre>

<p>}
```</p>

<h2>12 Delegates and Lambda Expressions 469</h2>

<ol>
<li>Introducing Delegates

<ul>
<li>Why Delegates

<ul>
<li>C/C++ method pointer == <strong><em>delegate</em></strong>, which encapsulates methods as objects, enabling an indirect method call bound at runtime.</li>
</ul>
</li>
<li>Delegate As Data Types

<ul>
<li>Although all delegate data types derive indirectly from <code>System.Delegate</code>, the C# compiler does not allow you to define a class that derives directly or indirectly (via <code>System.MulticastDelegate</code>) from <code>System.Delegate</code>.</li>
</ul>
</li>
<li>Delegate Internals

<ul>
<li>TODO</li>
</ul>
</li>
<li>Instantiating Delegates</li>
</ul>
</li>
<li>Anonymous Methods

<ul>
<li><code>BubbleSort(items, delegate(int first, int second){return first&lt;second})</code></li>
<li>can be <em>parameterless</em>: Parameterless Anonymous Methods</li>
<li>System-Defined Delegates: <code>Func&lt;&gt;</code>

<ul>
<li><code>Func&lt;&gt;</code> can also be used for generic delegate.</li>
<li><code>Func&lt;int, int, bool&gt;</code> the last type is the return type.</li>
<li><code>System.Action</code> should be used for delegates that have no return.</li>
<li>However, the delegate's name provides a more explicit indication of what it is for, whereas Func&lt;> provides nothing more than an understanding of the method signature.</li>
<li><strong><em>Generic <code>Func</code> delegate and explicitely defined delegate are not compatible</em></strong>. e.g. <code>Func&lt;int, int, bool&gt;</code> and <code>ComparisonHandler</code> are not compatible. <strong><em>But some degree of casting is allowed.</em></strong></li>
</ul>
</li>
<li>All anonymous delegates are immutable.</li>
</ul>
</li>
<li>Lambda Expressions

<ul>
<li>anonymous functions = lambda expressions (expression lambda + statement lambda) + anonymous methods</li>
<li>Statement Lambdas

<ul>
<li><code>BubbleSort(items, (int first, int second) =&gt; {return first &lt; second;})</code>

<ul>
<li><em>go/goes to</em>, <em>becomes</em>, <em>such that</em>: "integers <code>first</code> and <code>second</code> <em>go</em> to returning the result of <code>first</code> less than <code>second</code>"</li>
</ul>
</li>
<li><code>BubbleSort(items, (first, second) =&gt; {return first &lt; second;})</code>

<ul>
<li>statement lambdas can omit parameter types as long as the compiler can infer the types</li>
</ul>
</li>
<li>typically a statement lambda uses only two or three statements in its statement block.</li>
</ul>
</li>
<li>Expression Lambdas

<ul>
<li>no statement block, only an expression</li>
<li><code>names.Where(name =&gt; name.Contains(" "))</code>, "names where names dot contains a space"</li>
</ul>
</li>
<li>you cannot use the typeof() operator (see Chapter 17) on an anonymous method, and calling GetType() is possible only after assigning or casting the anonymous method to a delegate variable.</li>
<li>TODO: internals

<ul>
<li>Closure—a data structure (class in C#) that contains an expression and the variables (public fields in C#) necessary to evaluate the expression.</li>
</ul>
</li>
</ul>
</li>
<li>Expression Trees

<ul>
<li>Used to store lambda expressions as data for passing or translating.</li>
<li>Expression trees are object graphs</li>
<li>composed of read-only collection of parameters, a return type, and a body-- which is another expression.</li>
<li>Lambda Expressions vs. Expression Trees

<ul>
<li>compiled into a delegate in CIL</li>
<li>compiled into a data structure of type "System.Linq.Expressions.Expression"</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>``` cpp
using System;
class DelegateSample {</p>

<pre><code>public static void BubbleSort(int[] items, ComparisonHandler comparisonMethod) {
    int i;
    int j;
    int temp;

    if (items == null) return;
    if (comparisonMethod == null) throw new ArgumentNullException("comparisonMethod");

    for (i = items.Length - 1; i &gt;= 0; i--) {
        for (j = 1; j &lt;= i; j++) {
            if (comparisonMethod(items[j - 1], items[j])) {
                temp = items[j - 1];
                items[j - 1] = items[j];
                items[j] = temp;
            }
        }
    }
}

public delegate bool ComparisonHandler(int first, int second);

public static bool GreaterThan(int first, int second) {
    return first &gt; second;
}

public static bool AlphabeticalGreaterThan(int first, int second) {
    int comparison;
    comparison = (first.ToString().CompareTo(second.ToString()));

    return comparison &gt; 0;
}

static void Main() {
    int[] items = new int[100];
    Random random = new Random();
    for (int i = 0; i &lt; items.Length; i++) {
        items[i] = random.Next(0, 100);
    }

    BubbleSort(items, GreaterThan);
    // In C# 2.0, we can also use BubbleSort(items, new ComparisonHandler(GreaterThan))

    for (int i = 0; i &lt; items.Length; i++) {
        Console.WriteLine(items[i]);
    }

    Console.ReadLine();
}
</code></pre>

<p>}
```</p>

<h2>13 Events 507</h2>

<p>publish-subscribe design pattern</p>

<ol>
<li>Coding the Observer Pattern with Multicast Delegates (with operator+, +=, ...)

<ul>
<li>See the examples below</li>
<li>TODO: P518 Multicast Delegate Internals</li>
<li>How to handle exceptions from subscribers?

<ul>
<li><code>foreach(TDelegate handler in delegates.GetInvocationList())</code>See examples below</li>
</ul>
</li>
<li>How to handle multiple returns from multicast delegates?

<ul>
<li>Also <code>foreach(TDelegate handler in delegates.GetInvocationList())</code></li>
</ul>
</li>
</ul>
</li>
<li>Events

<ul>
<li>introduced to overcome 2 delegate shortages

<ol>
<li>Encapsulating the Subscription

<ul>
<li>User may use <code>=</code> instead of <code>+=</code> by mistake</li>
</ul>
</li>
<li>Encapsulating the publication

<ul>
<li>Delegates may be invoked outside the containing class</li>
</ul>
</li>
<li>easy to forget to check for null before invoking the delegate</li>
</ol>
</li>
<li><code>event</code> keyword before the delegate type and follows a empty delegate assignment

<ul>
<li>e.g. <code>public event TemperatureChangeHandler OnTemperatureChange = delegate { };</code></li>
<li><code>event</code> ensures that any reassignment of the delegate could occur only from within the class.</li>
<li>an empty delegate <code>delegate {}</code> represents a collection of zero listeners.</li>
</ul>
</li>
<li>customize with <code>add</code> and <code>remove</code></li>
</ul>
</li>
</ol>


<p>``` cpp
// delegate's implementation of subscriber-publisher
using System;</p>

<p>// Heater and Cooler Event Subscriber Implementations
class Cooler {</p>

<pre><code>public Cooler(float temperature) {
    Temperature = temperature;
} 

public float Temperature {
    get { return _Temperature; }
    set { _Temperature = value; }
}

private float _Temperature;

public void OnTemperatureChanged(float newTemperature) {
    if (newTemperature &gt; Temperature) {
        System.Console.WriteLine("Cooler: On");
    }
    else {
        System.Console.WriteLine("Cooler: Off");
    }
}
</code></pre>

<p>}</p>

<p>class Heater {</p>

<pre><code>public Heater(float temperature) {
    Temperature = temperature;
}

public float Temperature {
    get { return _Temperature; }
    set { _Temperature = value; }
}
private float _Temperature;

public void OnTemperatureChanged(float newTemperature) {
    if (newTemperature &lt; Temperature) {
        System.Console.WriteLine("Heater: On");
    }
    else {
        System.Console.WriteLine("Heater: Off");
    }
}
</code></pre>

<p>}</p>

<p>// Defining the Event Publisher, <code>Thermostat</code>
public class Thermostat {</p>

<pre><code>// Define the delegate data type
public delegate void TemperatureChangeHandler(float newTemperature);

// Define the event Publisher
public TemperatureChangeHandler OnTemperatureChange {
    get { return _OnTemperatureChange; }
    set { _OnTemperatureChange = value; }
}
private TemperatureChangeHandler _OnTemperatureChange;

public float CurrentTemperature {
    get { return _CurrentTemperature; }
    set {
        if (value != CurrentTemperature) {
            _CurrentTemperature = value;

            TemperatureChangeHandler localOnChange = OnTemperatureChange;

            if (localOnChange != null) {
                // call subscribers
                OnTemperatureChange(value); // multicast delegates
            }
        }
    }
}
public float CurrentTemperatureHandlingError {
    get { return _CurrentTemperature; }
    set {
        if (value != CurrentTemperature) {
            _CurrentTemperature = value;

            if (OnTemperatureChange != null) {
                foreach (TemperatureChangeHandler handler in OnTemperatureChange.GetInvocationList()) {
                    try {
                        handler(value);
                    }
                    catch (Exception e) {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        }
    }
}
private float _CurrentTemperature;
</code></pre>

<p>}</p>

<p>class Program {</p>

<pre><code>public static void Main() {
    Thermostat thermostat = new Thermostat();
    Heater heater = new Heater(60);
    Cooler cooler = new Cooler(80);
    string temperature;

    // Register subscribers
    thermostat.OnTemperatureChange += heater.OnTemperatureChanged;
    thermostat.OnTemperatureChange += cooler.OnTemperatureChanged;

    Console.Write("Enter temperature: ");
    temperature = Console.ReadLine();
    thermostat.CurrentTemperature = int.Parse(temperature);

    // Delegate Operators +=, -=, +, -
    Thermostat.TemperatureChangeHandler delegate1;
    Thermostat.TemperatureChangeHandler delegate2;
    Thermostat.TemperatureChangeHandler delegate3;

    delegate1 = heater.OnTemperatureChanged;
    delegate2 = cooler.OnTemperatureChanged;

    Console.WriteLine("Invoke both delegates:");
    delegate3 = delegate1;
    delegate3 += delegate2;
    delegate3(90);

    Console.WriteLine("Invoke only delegate2");
    delegate3 -= delegate1;
    delegate3(30);

    // Error handling
    thermostat.OnTemperatureChange += (newTemperature) =&gt; { throw new ApplicationException(); };
    thermostat.CurrentTemperatureHandlingError = int.Parse(temperature) + 1;
}
</code></pre>

<p>}
```</p>

<p>``` cpp
// event implementation of subscriber-publisher
using System;</p>

<p>// Heater and Cooler Event Subscriber Implementations
class Cooler {</p>

<pre><code>public Cooler(float temperature) {
    Temperature = temperature;
} 

public float Temperature {
    get { return _Temperature; }
    set { _Temperature = value; }
}

private float _Temperature;

public void OnTemperatureChanged(object sender, Thermostat.TemperatureArgs args) {
    if (args.NewTemperature &gt; Temperature) {
        System.Console.WriteLine("Cooler: On");
    }
    else {
        System.Console.WriteLine("Cooler: Off");
    }
}
</code></pre>

<p>}</p>

<p>class Heater {</p>

<pre><code>public Heater(float temperature) {
    Temperature = temperature;
}

public float Temperature {
    get { return _Temperature; }
    set { _Temperature = value; }
}
private float _Temperature;

public void OnTemperatureChanged(object sender, Thermostat.TemperatureArgs args) {
    if (args.NewTemperature &lt; Temperature) {
        System.Console.WriteLine("Heater: On");
    }
    else {
        System.Console.WriteLine("Heater: Off");
    }
}
</code></pre>

<p>}</p>

<p>// Defining the Event Publisher, <code>Thermostat</code>
public class Thermostat {</p>

<pre><code>public class TemperatureArgs: System.EventArgs { // conventions
    public TemperatureArgs(float newTemperature) {
        NewTemperature = newTemperature;
    }

    public float NewTemperature {
        get { return _newTemperature; }
        set { _newTemperature = value; }
    }
    private float _newTemperature;
}

// Define the delegate data type
// It is a norm:
//      sender: reference of the to the object that invoke the delegate 
//      args:   if of type `System.EventArgs` or derives from `System.EventArgs` but contains additional data
public delegate void TemperatureChangeHandler(object sender, TemperatureArgs newTemperature);

// Define the event publisher
// delegate类型之前加event，赋一个空的delegate
// an empty delegate represents a collection of zero listeners
public event TemperatureChangeHandler OnTemperatureChange = delegate {};

public float CurrentTemperature {
    get { return _CurrentTemperature; }
    set {
        if (value != CurrentTemperature) {
            _CurrentTemperature = value;
            // If there are any subscribers
            // then notify them of changes in 
            // temperature
            if (OnTemperatureChange != null) {
                // Call subscribers
                OnTemperatureChange(this, new TemperatureArgs(value));
            }
        }
    }
}
private float _CurrentTemperature;
</code></pre>

<p>}</p>

<p>class Program {</p>

<pre><code>public static void Main() {
    Thermostat thermostat = new Thermostat();
    Heater heater = new Heater(60);
    Cooler cooler = new Cooler(80);
    string temperature;

    // Register subscribers
    thermostat.OnTemperatureChange += heater.OnTemperatureChanged;
    thermostat.OnTemperatureChange += cooler.OnTemperatureChanged;

    Console.Write("Enter temperature: ");
    temperature = Console.ReadLine();
    thermostat.CurrentTemperature = int.Parse(temperature);
}
</code></pre>

<p>}
```</p>

<p>``` cpp
// Define the event publisher
public event TemperatureChangeHandler OnTemperatureChange {</p>

<pre><code>add
{
    System.Delegate.Remove(_OnTemperatureChange, value);
}
remove
{
    System.Delegate.Combine(value, _OnTemperatureChange);

} 
</code></pre>

<p>}
protected TemperatureChangeHandler _OnTemperatureChange;
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Essential C# 4.0: Basics]]></title>
    <link href="http://www.puncsky.com/blog/2013/08/14/essential-c-sharp-basics/"/>
    <updated>2013-08-14T10:23:00-07:00</updated>
    <id>http://www.puncsky.com/blog/2013/08/14/essential-c-sharp-basics</id>
    <content type="html"><![CDATA[<p>No one can ever master a programming language (PL) by studying it only without looking into and comparing it with other ones. Modern application software often requires a variety of components written in different PLs. Most importantly, language itself is not important at all; at least not important when compared to the fundamental ideas on architectures, frameworks, the design of the PL. A competing programmer can always get the hang of any PLs quickly.</p>

<p>Consequently, I make a list of PLs I would study seriously in the future.</p>

<ol>
<li>C# or Java

<ul>
<li>A serious pure OOP and enterprise level PL is always necessary for the reason of productivity.</li>
</ul>
</li>
<li>C/C++

<ul>
<li>The most powerful PL, which can be used to create almost everything.</li>
<li>Help to understand things under the hood.</li>
<li>C++: semi-OOP version of C, a horrible language which requires a life long time to study.</li>
</ul>
</li>
<li>Bash/Python

<ul>
<li>Scripts make your life easier.</li>
</ul>
</li>
<li>Javascript

<ul>
<li>Everything could be written in Javascript will be eventually written in Javascript.</li>
</ul>
</li>
<li>Lisp

<ul>
<li>Help to understand the beauty of functional PL.</li>
</ul>
</li>
</ol>


<p>The following part is the first part of my series notes on the book <em>Essential C#</em>, which is redeemed as the best book for C# learners.</p>

<ol>
<li>Essential C# 4.0: Basics(this post)</li>
<li><a href="http://www.puncsky.com/blog/2013/09/05/essential-c-sharp-intermediate/">Essential C# 4.0: Intermediate</a></li>
<li><a href="http://www.puncsky.com/blog/2013/09/15/essential-c-sharp-advanced/">Essential C# 4.0: Advanced</a></li>
</ol>


<!-- more -->


<h1>Essential C# 4.0</h1>

<h2>1 Introducing C# 1</h2>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/6/6f/CLR_diag.svg" alt="CLR converts CIL to native code" /></p>

<p>HelloWorld.exe is an <em>assembly</em>.</p>

<p>Dynamic Link Library (DLL) is also an <em>assembly</em>.</p>

<p><em>Language Contrast</em>: Java—Filename Must Match Class Name</p>

<p>keywords, identifiers. keywords may be used as identifiers if they include “@” as a prefix.</p>

<ul>
<li><strong>Pascal Casing</strong>: Type's name should begin with a capital letter and a <em>noun</em>...</li>
<li><strong>Camel Casing</strong>: same except that the first letter is lowercase.</li>
</ul>


<p>method, statement</p>

<p><em>Language Contrast</em>: C++/Java -- <code>main()</code> is all lowercase</p>

<p><strong>Strings are immutable.</strong></p>

<p>composite formatting.</p>

<p>```
System.Console.WriteLine("Your full name is {0} {1}.", firstName, lastName);
//                        -------format string-------  ----format item-----</p>

<p>```</p>

<ul>
<li>Comment Types

<ul>
<li>Delimited comments</li>
<li>Single-line comments</li>
<li>XML delimited comments <code>/**comment**/</code></li>
<li>XML single-line comments <code>///comment</code></li>
</ul>
</li>
</ul>


<p>C# src --(C# compiler)--> common intermediate language(CIL) --(justintime compiling)--> machine code</p>

<p>Virtual Execution System(VES)</p>

<ul>
<li>whether require runtime to execution?

<ul>
<li>managed code and managed execution</li>
<li>unmanaged code and unmanaged execution</li>
</ul>
</li>
</ul>


<h2>2 Data Types 31</h2>

<ol>
<li>Numeric Types

<ul>
<li> Integer Types

<ul>
<li>Base Class Library (BCL)</li>
</ul>
</li>
<li> Float-Point Types</li>
<li> Decimal

<ul>
<li>greater precision than the floating-point types, but a smaller range.</li>
<li>conversions from floating-point types to the decimal type may result in overflow errors.</li>
<li>calculations with decimal are slightly slower.</li>
</ul>
</li>
<li> Literal Values

<ul>
<li>a representation of a constant value within source code.</li>
<li><strong>hardcoding</strong>: place a value directly into src

<ul>
<li>numbers with a decimal point will default to <code>double</code></li>
<li><code>decimal</code>? append an m (or M): <code>1.32525456874526m</code>

<ul>
<li>no suffix -> <code>int</code> <code>uint</code>, <code>long</code>, <code>ulong</code>.</li>
<li>suffix <code>U</code>/<code>L</code>/<code>UL</code>/<code>LU</code></li>
<li>infix <code>E</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>More Types

<ul>
<li> Boolean</li>
<li> Character

<ul>
<li>Escape Sequence: <code>\uxxxx</code> unicode char in hex, e.g. <code>\u0029</code></li>
</ul>
</li>
<li> Strings

<ul>
<li>verbatim string (with prefix <code>@</code>)

<ul>
<li>signify that a backslash should not be interpreted as the beginning of an escape sequence.</li>
<li>a newline cannot be placed directly within a string that is not prefaced with the @ symbol.</li>
<li>The only escape sequence the verbatim string does support is "", which signifies double quotes and does not terminate the string.</li>
</ul>
</li>
<li><strong>immutable</strong>

<ul>
<li>How to modify? <code>System.Text.StringBuilder</code></li>
</ul>
</li>
<li>New Line

<ul>
<li>Win : <code>\r\n</code></li>
<li>*nix: <code>\n</code></li>
<li><code>Console.WriteLine()</code> or <code>Console.Write(Environment.NewLine);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>null and void

<ul>
<li> In C++, void is a data type commonly used as void<em><em>. In C#, <code>void</code> </em>is not
considered a data type</em> in the same way. Rather, it is used to identify that a
method does not return a value.</li>
<li> <code>var</code> introduced to support anonymous types, e.g. <code>var patent1 = new { Title = "Bifocals", YearOfPublication = "1884" };</code>. Avoid to use in other cases.

<ul>
<li>avoid anonymous types until working with lambda and query expressions that associate data from different types or you you are horizontally projecting the data so that for a particular type, there is less data overall.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Categories of Types</strong>

<ul>
<li> Value Types: all the C# primitive types except <code>string</code> and <code>object</code>, all derive from <code>System.ValueType</code>

<ul>
<li>data copied by value</li>
<li>for &lt; 16 bytes</li>
<li>stack</li>
</ul>
</li>
<li> Reference Types: <code>string</code>, <code>object</code>, any custom classes, most classes

<ul>
<li><strong><em>IMPORTANT</em></strong> string is passed by value and cloned when pass it to a method, BUT</li>
<li>data copied by reference</li>
<li>heap</li>
</ul>
</li>
<li> <strong>Nullable Modifier</strong>, value types can be null, like <code>int? count = null;</code></li>
</ul>
</li>
<li>Conversions

<ul>
<li> Explicit Cast

<ul>
<li><strong><em>checked and unchecked block</em></strong> whether to throw overflow exceptions</li>
<li>No numbers to booleans conversion</li>
</ul>
</li>
<li> Implicit Cast</li>
<li> Conversion Without Casting

<ul>
<li><code>Parse(T1 to, T2 from)</code></li>
<li><code>System.Convert</code></li>
<li><code>bool TryParse(T1 to,T2 from, T1 number)</code></li>
</ul>
</li>
</ul>
</li>
<li>Arrays

<ul>
<li> Declaring

<ul>
<li><code>string[] languages;</code> square brackets identify the <strong>rank</strong> (# of dimensions)</li>
<li>before the variable. <em>Language Contrast</em>: different from C++/JAVA, <code>int numbers[]</code> is not allowed.</li>
</ul>
</li>
<li> Instantiating

<ul>
<li><strong>IMPORTANT the same applied to other similar cases</strong>

<ul>
<li>If only one statement: <code>string[] languages = { "C#", "COBOL", "Java" };</code></li>
<li>If multiple lines: <code>string[] languages; languages = new string[]{"C#", "COBOL", "JAVA" };</code></li>
</ul>
</li>
<li><code>new string[size];</code></li>
</ul>
</li>
<li><p> Assigning</p>

<ul>
<li>multi-dimensional

<ol>
<li><strong><em>consistently sized array</em></strong> <code>int[,,,]</code></li>
<li><strong><em>jagged array</em></strong> <code>int[][][]</code></li>
</ol>
</li>
</ul>
</li>
<li><p> Using</p>

<ul>
<li><code>Sort()</code>, <code>BinarySearch()</code>, <code>Reverse()</code>, <code>Clear()</code>, ...</li>
<li>Redimension? <code>System.Array.Resize()</code></li>
</ul>
</li>
<li> String as Arrays

<ul>
<li><code>.ToCharArray()</code></li>
</ul>
</li>
</ul>
</li>
</ol>


<p>```
// instantiating
int[,] cells = {
{1, 0, 2},
{0, 2, 0},
{1, 2, 1}
};</p>

<p>int[][] cells = {
new int[]{1, 0, 2},
new int[]{0, 2, 0},
new int[]{1, 2, 1}
};
```</p>

<p>```
// handle conversion overflow with checked and unchecked
checked {
}</p>

<p>unchecked {
}</p>

<p>```</p>

<h2>3 Operators and Control Flow 83</h2>

<ol>
<li>Operators

<ul>
<li> Thread-Safe Incrementing and Decrementing, use thread-safe <code>Increment()</code> and <code>Decrement()</code> in <code>System.Threading.Interlocked</code> class</li>
</ul>
</li>
<li>Boolean Expressionn

<ul>
<li> XOR for eXclusive OR</li>
<li> Conditional Operator (?)

<ul>
<li>Shortcut to the conditional operator: <strong>Null Coalescing Operator (<code>??</code>)</strong> evaluates an expression for null and returns a second expression if the value is null.</li>
</ul>
</li>
</ul>
</li>
<li>Bitwise Operators</li>
<li>Control Flow Statements

<ul>
<li> <code>foreach (type variable in collection) { /* do something */ }</code>

<ul>
<li><code>variable</code> is read-only, and its scope is limited to the <code>foreach loop</code></li>
</ul>
</li>
</ul>
</li>
<li>Jump Statements

<ul>
<li> <em>Language Contrast</em>: Unlike C++, C# does not allow a <code>switch</code> statement to fall through from one <code>case</code> block to the next if the <code>case</code> includes a statement. A jump statement is always required following the statement within a case.</li>
<li> <em>Language Contrast</em>: C# prevents using goto into something, and allows its use only within or out of something.</li>
</ul>
</li>
<li><strong><em>Preprocessor Directives</em></strong>

<ul>
<li> <em>Language Contrast</em>: C/C++ contain a preprocessor. Preprocessor directives generally tell the compiler how to
compile the code in a file and do not participate in the compilation process
itself. In contrast, the C# compiler handles preprocessor directives as part
of the regular lexical analysis of the source code. As a result, C# does not
support preprocessor macros beyond defining a constant. In fact, the term
preprocessor is generally a misnomer for C#.</li>
</ul>
</li>
</ol>


<p><code>
// Null Coalescing Operator
string fileName;
// ...
string fullName = fileName??"default.txt";
// ...
</code></p>

<p>```
// Preprocessor Directives</p>

<h1>if CSHARP2</h1>

<p>System.Console.Clear();</p>

<h1>endif</h1>

<h1>if LINUX</h1>

<p>...</p>

<h1>elif WINDOWS</h1>

<p>...</p>

<h1>endif</h1>

<p>// you can define a preprocessor symbol in two way
// first,</p>

<h1>define CSHARP2</h1>

<p>// second, in CLI
// >csc.exe /define:CSHARP2 TicTacToe.cs</p>

<h1>warning "Some move allowed multiple times."</h1>

<p>// Performing main compilation...
// ...\tictactoe.cs(471,16): warning CS1030: #warning: ’"Same move allowed
// multiple times."’
// Build complete -- 0 errors, 1 warnings</p>

<p>// Note that warning numbers are prefixed with the letters CS in the compiler output.
// to disable warnings, first,</p>

<h1>pragma warning disable 1030</h1>

<p>// second,
// > csc /doc:generate.xml /nowarn:1591 /out:generate.exe Program.cs</p>

<h1>pragma warning restore 1030</h1>

<p>// one of the most common warnings to disable is CS1591, as this appears when you elect to
// generate XML documentation using the /doc compiler option, but you neglect to document
// all of the public items within your program.</p>

<p>// specify line numbers</p>

<h1>line 113 "TicTacToe.cs"</h1>

<h1>warning "Same move allowed multiple times."</h1>

<h1>line defualt</h1>

<p>// display line 113 and then restore</p>

<p>// for visual editors to open/collapse</p>

<h1>region Display Tic-tac-toe Board</h1>

<p>...</p>

<h1>endregion Display Tic-tac-toe Board</h1>

<p>```</p>

<h2>4 Methods and Parameters 149</h2>

<ol>
<li>Calling a Method

<ul>
<li> Namespace

<ul>
<li>Everything should appear within a class definition.</li>
</ul>
</li>
<li> Type Name</li>
<li> Scope</li>
<li> Method Name</li>
<li> Parameters</li>
<li> Method Return

<ul>
<li><em>Language Contrast</em>:Unlike C++, C# classes never separate the implementation from the declaration. Cleaner and more readable.</li>
</ul>
</li>
</ul>
</li>
<li>Declaring a Method</li>
<li>The Using Directive

<ul>
<li> <em>Language Contrast</em> Java uses wildcards in <code>import</code> directive, while C# requires each namespace to be imported explicitly.</li>
<li> <code>using</code> could be nested in other namespaces but seldom used in this way.</li>
<li> <strong><em>Aliasing</em></strong> a namespace or type: <code>using CountDownTimer = System.Timers.Timer;</code></li>
</ul>
</li>
<li>Parameters

<ul>
<li> Value Parameters

<ul>
<li><code>static int Main(string[] args)</code> By convention, a return other than zero indicates an error.

<ul>
<li><em>Language Contrast</em>, CLI arguments start from <code>args[0]</code>. The name of the program is omitted.</li>
<li>access the CLI arguments through <code>args</code> or <code>System.Environment.GetCommandLineArgs()</code></li>
<li><strong><em>Multiple <code>Main()</code> Methods in a program</em></strong>? use <code>&gt;csc.exe /m main.cs</code></li>
</ul>
</li>
<li>call stack, <em>stack unwinding</em>, <em>call site</em>调用地点</li>
<li><code>string</code> as parameters are passed by value</li>
<li>By default, parameters are passed by value</li>
</ul>
</li>
<li> <strong><em>Reference Parameters (<code>ref</code>)</em></strong>

<ul>
<li>declare <code>ref Type variable</code> in the function's list of args and call it with <code>ref variable</code></li>
</ul>
</li>
<li> <strong><em>Output Parameters (<code>out</code>)</em></strong></li>
<li> <strong><em>Parameter Arrays (<code>params</code>)</em></strong></li>
<li> Optional Parameters

<ul>
<li>optional parameters
must appear after all required parameters (those that don’t have default
values). Also, the fact that the default value needs to be a constant, compile-
time-resolved value</li>
<li><strong>named parameters</strong></li>
</ul>
</li>
</ul>
</li>
<li>Method Overloading</li>
<li>Exception Handling

<ul>
<li> <strong><em>generic catch</em></strong>: <code>try { } catch { }</code> <em>Language Contrast</em> C++: <code>try { } catch (...) { }</code>. JAVA: <code>Exception</code> is the base class for all exceptions, so <code>try { } catch (Exception e) { }</code>.</li>
<li> Avoid using exception handling to deal with expected situations</li>
<li> <code>bool int.TryParse(textVariable, out number)</code></li>
</ul>
</li>
</ol>


<p>```
// Aliasing a namespace or type
using Timer = System.Timers.Timer;</p>

<p>class HelloWorld
{
  static void Main()
  {</p>

<pre><code>Timer timer;
// ...
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>```
// Refrence Parameters
class Program
{
  static void Main() {</p>

<pre><code>string first = "first";
string second = "second";
Swap(ref first, ref second);

System.Console.WriteLine(@"first = ""{0}"", second = ""{1}""", first, second);
</code></pre>

<p>  }</p>

<p>  static void Swap(ref string first, ref string second) {</p>

<pre><code>string tmp = first;
first = second;
second = tmp;
</code></pre>

<p>  }
}
```</p>

<p>```
// Parameter Arrays
class PathEx
{
  static void Main()
  {</p>

<pre><code>string fullName;
fullName = Combine(
    Directory.GetCurrentDirectory();
    "bin", "config", "index.html");
Console.WriteLine(fullName);
fullName = Combine(
    Environment.SystemDirectory,
    "Temp", "index.html");
Console.WriteLine(fullName);
fullName = Combine(
    new string[] {
        "C:\", "Data",
        "HomeDir", "index.html"} );
Console.WriteLine(fullName);
</code></pre>

<p>  }</p>

<pre><code>static string Combine(params string[] paths)
{
    string result = string.Empty;
    foreach (string path in paths) {
        result = System.IO.Path.Combine(result, path);
    }
    return result;
}
</code></pre>

<p>}
```</p>

<p>```
// named arguments
class Program
{
  static void Main()
  {</p>

<pre><code>DisplayGreeting(firstName: "Tim", lastName: "Pan");
</code></pre>

<p>  }
  public void DisplayGreeting(</p>

<pre><code>string firstName,
string middleName = default(string),
string lastName = default(string))
</code></pre>

<p>  {</p>

<pre><code>// ...
</code></pre>

<p>  }
}
```</p>

<h2>5 Classes 201</h2>

<ol>
<li>Declaring and Instantiating a Class</li>
<li>Instance Fields

<ul>
<li> Declaring</li>
<li> Accessing</li>
<li> Const and readonly modifiers</li>
</ul>
</li>
<li>Instance Methods</li>
<li>Access Modifiers

<ul>
<li> <code>public</code>, <code>private</code>, <code>protected</code>, <code>internal</code>, <code>protected internal</code></li>
</ul>
</li>
<li>Properties

<ul>
<li> Declaring

<ul>
<li><em>Language Contrast</em> Programmers should view <code>new</code> as a call to instantiate an object, <em>not as a call to allocate memory</em>. It just retrieves memory from the memory manager.</li>
</ul>
</li>
<li> Naming Conventions

<ul>
<li>property name <code>FirstName</code>, then field name <code>_FirstName</code>(preferred), <code>_firstName</code>, or <code>m_FirstName</code>(C++ style).</li>
</ul>
</li>
<li> Using Properties with Validation</li>
<li> Read-Only and Write-Only</li>
<li> Access Modifiers on Getters and Setters

<ul>
<li>e.g. <code>private set()</code></li>
</ul>
</li>
<li> Properties as Virtual Fields

<ul>
<li>They can even do not exist physically</li>
</ul>
</li>
<li> Properties and Method Calls <strong>Not Allowed</strong> as <code>ref</code> or <code>out</code> Parameter Values</li>
</ul>
</li>
<li>Constructors &amp; Finalizers

<ul>
<li> Declaring</li>
<li> Default constructors

<ul>
<li>Once there is a explicitely defined constructor, the default one (without parameters) is no longer provided.</li>
</ul>
</li>
<li> Object Initializers <code>Employee emp1 = new Employee("Inigo", "Montoya") { Title = "Computer Nerd", Salary = "Not Enough"};</code>

<ul>
<li>Collection Initializers</li>
</ul>
</li>
<li> Overloading Constructors</li>
<li> Constractor Chaining: Calling another Constructor Using <code>this</code>

<ul>
<li><code>public Employee(int id, string fristName, string lastName): this(firstName, lastName) { Id = id ; }</code></li>
</ul>
</li>
<li> Generalize initialization: Refactor init process in the ctor into a private init method</li>
<li> Finalizers

<ul>
<li>Like JAVA, unlike C++</li>
</ul>
</li>
</ul>
</li>
<li>Static

<ul>
<li> <em>Language Contrast</em> The equivalent of a global field or function within the realm of C# is a static field or function</li>
<li> Static Fields</li>
<li> Static Methods</li>
<li> Static Constructors</li>
<li> Static Classes

<ol>
<li>it prevents a programmer from writing code that
instantiates the SimpleMath class.</li>
<li>it prevents the declaration of any
instance fields or methods within the class. Since the class cannot be
instantiated, instance members would be pointless.</li>
</ol>
</li>
<li> <code>const</code> fields are <code>static</code> automatically, and declaring a <code>const</code> field as <code>static</code> explicitly will cause a compile error</li>
<li> <strong><em><code>readonly</code> modifier is available only for fields (not for local variables)</em></strong> it is modifiable only from inside the constructor or directly during declaration. 似乎是把C++中<code>const</code>可以ctor初始化的功能拆成<code>readonly</code>了.</li>
</ul>
</li>
<li><strong><em>Extension Methods</em></strong> requirements

<ul>
<li> The first parameter corresponds to the type on which the method
extends or operates.</li>
<li> To designate the extension method, prefix the extended type with the
this modifier.</li>
<li> To access the method as an extension method, import the extending
type’s namespace via a using directive (or place the extending class in
the same namespace as the calling code).</li>
</ul>
</li>
<li>Special Classes

<ul>
<li> <code>partial</code> Classes

<ul>
<li>the general purpose of a partial class is to allow the splitting of a class definition across multiple files</li>
<li><code>partial</code> methods allow for a declaration of a method without requiring
an implementation. However, when the optional implementation is
included, it can be located in one of the sister partial class definitions,
likely in a separate file.</li>
</ul>
</li>
<li> Nested Classes

<ul>
<li>One unique characteristic of nested classes is the ability to specify private
as an access modifier for the class itself</li>
<li>Another interesting characteristic of nested classes is that they can
access any member on the containing class, including private members.</li>
<li>treat public nested classes suspiciously;
they indicate potentially poor code that is likely to be confusing
and hard to discover.</li>
</ul>
</li>
</ul>
</li>
</ol>


<h2>6 Inheritance 269</h2>

<ol>
<li>Derivation

<ul>
<li> Extension methods are also inherited.</li>
<li> <em>Language Contrast:</em> Different from C++, C# is a <strong>single-inheritance</strong> programming language, as is the CIL. Derive from only one class a time.

<ul>
<li>avoid using a multiple-inheritance class</li>
<li><code>sealed</code> class cannot be derived. <em>Language Contrast:</em> C# sealed class = Java final class. In java, <code>final</code> can be applied to

<ol>
<li>classes. = C# sealed class</li>
<li><strong>methods, cannot be overridden in a derived class. This is default in C#, unless you declare a method as <code>virtual</code></strong>, and in a derived class this can be prevented for further classes with <code>sealed</code> again.</li>
<li>fields and variables, can be initialized only once. = C# readonly</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>Overriding

<ul>
<li> <em>Language Contrast:</em> Java -- Virtual Methods by Default. Java and C++ -- Implicit Overriding. However, in C#, in order to override a method, both the base class and the derived class members must match and have corresponding <code>virtual</code> and <code>override</code> keywords.</li>
<li> ctor: <em>Language Contrast:</em> Dispatch Method Calls during Construction

<ul>
<li>C++: the type is associated with the base type rather than the derived type, and virtual methods call the base implementation.</li>
<li>C#: dispatches virtual method calls to the most derived type.</li>
</ul>
</li>
<li> only instance members can be virtual. The CLR uses the concrete
type, specified at instantiation time, to determine where to dispatch a
virtual method call, so static virtual methods are meaningless and the
compiler prohibits them.</li>
<li> <code>new</code> modifier for methods. <strong><em>If neither <code>override</code> nor <code>new</code> is specified, then <code>new</code> will be assumed, thereby maintaining the desired version safety.</em></strong></li>
<li> <em>upcasting</em>: please see the example codes below. <em>downcasting</em>: ?dangerous?</li>
<li> <em>sealed</em> modifier for methods. prevent overriding</li>
<li> <em>base</em> member

<ul>
<li>ctor <code>public Contact(string name) : base(name) { Name = name; }</code></li>
</ul>
</li>
</ul>
</li>
<li>Abstract Classes

<ul>
<li> <em>Language Contrast</em>

<ul>
<li>C++ pure virtual function with <code>=0</code>. It does not require the class itself to have any special declaration.</li>
<li>C# and Java require <code>abstract</code> if the class has <code>abstract</code> member</li>
</ul>
</li>
<li> polymorphism.

<ul>
<li>base.foo() to derived1.foo(), derived2.foo(), derived3.foo() overriding</li>
</ul>
</li>
</ul>
</li>
<li><code>System.Object</code>

<ul>
<li> Every class is derived from <code>System.Object</code></li>
</ul>
</li>
<li><strong><em><code>is</code> operator</em></strong>

<ul>
<li> verify the underlying type with <code>is</code> operator, e.g. <code>if (data is string) data = Encrypt((string) data);</code></li>
</ul>
</li>
<li><strong><em><code>as</code> operator</em></strong>

<ul>
<li> conversion to a data type, and assign null if the source type is not inherently (within the inheritance chain). Avoid additional try/catch handling code. e.g. <code>Print(data as Document);</code></li>
</ul>
</li>
</ol>


<p>``` cpp
// C++ Dispatch method calls during construction
// It will call method in the same class although it is virtual</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>class A {
public:</p>

<pre><code>A() {
    cout &lt;&lt; "A ctor()" &lt;&lt;endl;
    Foo();
}

virtual void Foo() {
    cout &lt;&lt; "A Foo()" &lt;&lt;endl;
}
</code></pre>

<p>};</p>

<p>class B: public A {
public:</p>

<pre><code>B() {
    cout &lt;&lt; "B ctor()" &lt;&lt; endl;
    Foo();
}
void Foo() {
    cout &lt;&lt; "B Foo()" &lt;&lt; endl;
}
</code></pre>

<p>};</p>

<p>class C: public B {
public:</p>

<pre><code>C() {
    cout &lt;&lt; "C ctor" &lt;&lt; endl;
    Foo();
}
void Foo() {
    cout &lt;&lt; "C Foo()" &lt;&lt; endl;
}
</code></pre>

<p>};</p>

<p>int main(int argc, char** args) {</p>

<pre><code>A* a = new C();

delete a;

return 0;
</code></pre>

<p>}
// output>
// A ctor()
// A Foo()
// B ctor()
// B Foo()
// C ctor
// C Foo()</p>

<p><code>
</code>
// C#
using System;
class Tmp {</p>

<pre><code>static int Main(string[] args) {
    A a = new C();

    return 0;
}
</code></pre>

<p>}</p>

<p>class A {</p>

<pre><code>public A() {
    Console.WriteLine("A ctor"); 
    Foo();
}

public virtual void Foo() {
    Console.WriteLine("A Foo()");
}
</code></pre>

<p>}</p>

<p>class B: A {</p>

<pre><code>public B() {
    Console.WriteLine("B ctor"); 
    Foo();
}
public override void Foo() {
    Console.WriteLine("B Foo()");
}
</code></pre>

<p>}</p>

<p>class C: B {</p>

<pre><code>public C() {
    Console.WriteLine("C ctor"); 
    Foo();
}
public override void Foo() {
    Console.WriteLine("C Foo()");
}
</code></pre>

<p>}
// output>
// A ctor
// C Foo()
// B ctor
// C Foo()
// C ctor
// C Foo()</p>

<p>```</p>

<p><code>``
// upcasting in C#
//</code>new` modifier for methods
using System;
class Tmp {</p>

<pre><code>static int Main(string[] args) {
    D1 d1 = new D1();
    D2 d2 = new D2();
    C c = d1;
    B b = c;
    A a = b;

    d1.Foo();
    d2.Foo();
    c.Foo();
    b.Foo();
    a.Foo();

    return 0;
}
</code></pre>

<p>}</p>

<p>class A {</p>

<pre><code>public void Foo() {
    Console.WriteLine("A Foo()");
}
</code></pre>

<p>}</p>

<p>class B: A {</p>

<pre><code>public new virtual void Foo() { // warning if without new
    Console.WriteLine("B Foo()");
}
</code></pre>

<p>}</p>

<p>class C: B {</p>

<pre><code>public override void Foo() {
    Console.WriteLine("C Foo()");
}
</code></pre>

<p>}</p>

<p>class D1: C {</p>

<pre><code>public new void Foo() {
    Console.WriteLine("D1 Foo()");
}
</code></pre>

<p>}</p>

<p>class D2: C {</p>

<pre><code>public void Foo() {  // warning to add `new` by default
    Console.WriteLine("D2 Foo()");
}
</code></pre>

<p>}
// D1 Foo()
// D2 Foo()
// C Foo()
// C Foo()
// A Foo()</p>

<p>```</p>

<p>``` cpp
// upcasting in C++
// A -> B -> C -> D
// A::Foo()
// virtual B::Foo()
// virtual C::Foo()
// D:Foo()
// ...
int main(int argc, char** argv) {</p>

<pre><code> D* d = new D();
 C* c = d;
 B* b = c;
 A* a = b;

 d-&gt;Foo();
 c-&gt;Foo();
 b-&gt;Foo();
 a-&gt;Foo();

 delete d;

 return 0;
</code></pre>

<p> }
//
// D Foo()
// D Foo()
// D Foo()
// A Foo()</p>

<p>```</p>

<h2>7 Interfaces 305</h2>

<ul>
<li><code>IPascalCase</code>, no implementation, no data (no fields, but properties)</li>
<li>Polymorphism</li>
<li>Interface Implementation

<pre><code>- Declaring a class to implement an interface is similar to deriving from a
base class in that the implemented interfaces appear in a comma-separated
list along with the base class (order is not significant between interfaces).
***The only difference is that classes can implement multiple interfaces.***
- The base class specifier (if there is one) must come first: `public class Contact : PdaItem, IListable, IComparable {...`
- ***Explicit(more often) vs Implicit*** [Stackoverflow](http://stackoverflow.com/questions/143405/c-sharp-interfaces-implicit-implementation-versus-explicit-implementation) ??
  - Explicit: mechanism code, or avoid overriding,
    - `ITrace.Dump()` to save info to files in `Person`
  - Implicit: semantic/model/core code
    - Including an implicit `Compress()` implementation on a `ZipCompression`
    class is a perfectly reasonable choice, since `Compress()` is a core
    part of the `ZipCompression` class’s behavior.
</code></pre></li>
<li>Interface Inheritance

<ul>
<li>upcasting is always successful (<code>Base b = new Derived()</code>)</li>
<li>downcasting is not, so requires an explict cast</li>
<li>Explicit Implementation should match the exact corresponding level in the hierachy.</li>
</ul>
</li>
<li>Versioning</li>
<li>Extension Methods on Interfaces</li>
</ul>


<p>```
// Explicit interface implementation
public class Contact : PdaItem, IListable, IComprarable
{
  // ...
  string[] IListable.ColumnValues
  {</p>

<pre><code>// ...
</code></pre>

<p>  }
  // ...
}</p>

<p>// ...</p>

<pre><code>values = ((IListable)contact2).ColumnValues;
</code></pre>

<p>// ...
```</p>

<h2>8 Value Types 331</h2>

<p>All the C# primitive types are value types except <code>string</code> and <code>object</code>. How to define user's own value types? <code>struct</code></p>

<ol>
<li>Structs (derive from <code>System.Object</code> -> <code>System.ValueType</code>)

<ul>
<li> Recommend: Once you have instantiated a value type, you should not be able to modify the same instance.</li>
<li> *C# prevents explict definition of default constructors (parameterless)</li>
<li> <code>struct</code> fields can not be initialized at declaration time.</li>
<li> Unlike <code>class</code>, <code>struct</code> does not support finalizers. There is no need for the GC.</li>
<li> <em>Language Contrast</em>: In C++, the difference between structs and classes is simply that by
default, a struct’s members are public. C# doesn’t include this subtle distinction.
The contrast is far greater in C#, where struct significantly
changes the memory behavior from that of a class.</li>
<li> <code>T default(T)</code> to get the default value</li>
</ul>
</li>
<li><strong><em>Boxing</em></strong>: upcasting <code>ValueType</code> to <code>Object</code>

<ol>
<li>First, memory is allocated on the heap that will contain the value
type’s data and a little overhead (a SyncBlockIndex and method
table pointer).</li>
<li>Next, a memory copy occurs from the value type’s data on the stack,
into the allocated location on the heap.</li>
<li>Finally, the object or interface reference is updated to point at the
location on the heap.</li>
<li> <strong><em>unboxing</em></strong> TODO start from page 339</li>
<li> <strong><em><code>lock</code> statement</em></strong></li>
</ol>
</li>
<li>Enums

<ul>
<li> An enum always has an underlying type, which may be <code>int</code>(default), <code>uint</code>, <code>long</code>,
or <code>ulong</code>, but not <code>char</code>.</li>
<li> Cast between enums via <code>System.Array</code></li>
<li> Cast between enums and strings via

<ul>
<li><em>enum -> string</em>.</li>
<li><em>string -> enum</em>. <code>Enum.Parse()</code></li>
</ul>
</li>
<li> Enums as bit flags with <code>[Flags]</code> FlagsAttribute to perform bit operations.</li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
</feed>
