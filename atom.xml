<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CS Notebook]]></title>
  <link href="http://puncsky.github.com/atom.xml" rel="self"/>
  <link href="http://puncsky.github.com/"/>
  <updated>2012-12-19T14:02:19-05:00</updated>
  <id>http://puncsky.github.com/</id>
  <author>
    <name><![CDATA[Tian]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OOP Final Term Notes]]></title>
    <link href="http://puncsky.github.com/blog/2012/12/19/oop2/"/>
    <updated>2012-12-19T02:01:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/12/19/oop2</id>
    <content type="html"><![CDATA[<hr />

<p>如果自己不定义constructor，C++会默认使用空的constructor。但是如果自己声明了，就一定要把定义写出来。</p>

<hr />

<p>Reuse and recycle. Maintain a <strong>free list</strong> a pool of currently unused objects and reuse rather than recreate when possible.</p>

<hr />

<p>How to measure run time of a program?</p>

<p>Clocks advance in discrete clicks called <strong>jiffies</strong>. A jiffy on the Zoo linux machines is one millisecond (0.001 seconds) long.</p>

<p>the first run of a program is likely to be slower than subsequent runs because of caching.</p>

<p>class members are private by default.</p>

<pre><code>if(!in) {...}
</code></pre>

<p>to test if an istream object in is open for reading. Here, the <code>istream</code> object is coerced to a <code>bool</code> because operator <code>bool()</code> is defined inside the streams package.</p>

<hr />

<p>operator⊕ overload</p>

<h3>a⊕b can be ambiguous</h3>

<ul>
<li>Global function: operator⊕(a, b).</li>
<li>Member function: a.operator⊕(b).</li>
</ul>


<p>It could mean either, and the compiler sees if either one matches. If both match, it reports an ambiguity.</p>

<p>We use a global form of operator&lt;&lt; because the left hand operator is of predefined type ostream, and we can’t add member functions to that class.</p>

<h3>++, &#8211;</h3>

<ol>
<li><p>prefix unary operators</p></li>
<li><p>class member: <code>operator++()</code></p></li>
<li><p>global: <code>operator++(ClassA a)</code></p></li>
<li><p>postfix unary operators</p></li>
</ol>


<p>They <strong>must be</strong> like</p>

<ul>
<li>class member: <code>operator++(int)</code></li>
<li>global: <code>operator++(ClassA a, int)</code></li>
</ul>


<p>Here <code>int</code> is dummy.</p>

<hr />

<p>两种定义类的cast的方式 cast A to B</p>

<pre><code>class A {};
class B{
    public:
    B(A&amp; a) {
        cout &lt;&lt; "constructor cast called" &lt;&lt; endl;
    }
};
</code></pre>

<p>conversion function cast</p>

<pre><code>class B {};
class A {
    public:
    operator B() {
        cout &lt;&lt; "operator B cast called" &lt;&lt; endl;
        return *new B;
    } 
};
</code></pre>

<p>注意没有返回类型，讲述自己怎么被cast成其他类</p>

<hr />

<p>Polymorphism</p>

<pre><code>class B     { public: int f(); ... };
class U : B { int f(); ... };
class V : B { int f(); ... };
</code></pre>

<p><code>B* bp</code> can point to B, U, and V, but bp->f() always refers to B::f()</p>

<p>Solution: Polymorphic derivation</p>

<pre><code>   class B     { public: virtual int f(); ... };
   class U : B { virtual int f(); ... };
   class V : B { virtual int f(); ... };
   B* bp;
</code></pre>

<p>A virtual function is dispatched at run time to the class of the actual object.</p>

<ul>
<li>bp->f() refers to U::f() if bp points to a U.</li>
<li>bp->f() refers to V::f() if bp points to a V.</li>
<li>bp->f() refers to B::f() if bp points to a B.</li>
</ul>


<p>Here, the type refers to the allocation type.</p>

<p>其实，只有基类加virtual都是可以的</p>

<hr />

<p>Calling constructors implicitly</p>

<pre><code>MyClass b;
MyClass b(4);
new MyClass(4);
</code></pre>

<p>Calling constructors explicitly</p>

<pre><code>MyClass(4);
throw Fatal("Error message"); 
</code></pre>

<hr />

<p>A <strong>pure virtual function</strong> is sometimes called a <strong>promise</strong>. Instances of B are never created and B::f() does not exist. It tells the compiler that a construct like bp->f() is legal. The compiler requires every derived class to contain a method f().</p>

<p>An <strong>abstract class</strong> is a class with one or more pure virtual functions. An abstract class <strong>cannot be instantiated</strong>. It can <strong>only be used as the base</strong> for another class. The <strong>destructor can never be a pure virtual function but will generally be virtual</strong>.</p>

<p>A <strong>pure abstract class</strong> is one where all member functions are pure virtual (except for the destructor) and there are no data members, Pure abstract classes define an <strong>interface</strong> `a la Java. An interface allows user-supplied code to integrate into a large system.</p>

<hr />

<p>A global function is one that takes zero or more explicit arguments. Example: f(a, b) has two explicit arguments a and b.</p>

<p>A member function is one that <strong>takes an implicit argument</strong> along with zero or more explicit arguments.
Example: c.g(a, b) has two explicit arguments a and b and implicit argument c.
Example: d->g(a, b) has two explicit arguments a and b and implicit argument *d.</p>

<p>Note that an omitted implicit argument defaults to (<em>this), which must make sense in the context.
Example: If g is a member function of class MyClass, then within MyClass, the call g(a, b) defaults to (</em>this).g(a,b) (or equivalently this->g(a,b)).</p>

<hr />

<p>Good function prototypes</p>

<p>Pass by reference instead of by pointer. A pass by pointer may imply optional and the user may pass a null pointer:</p>

<pre><code>Method(const Class *value); // value can be null Cannot pass a null pointer via reference
Method(const Class &amp;value); // value cannot be null
</code></pre>

<p>Always include “const” unless the calling function needs to modify the state of passed reference</p>

<p>Do not pass simple data types (int, char, bool) by by const reference … it does not do anything good and may actually inhibit some optimizations</p>

<hr />

<p>Casting!</p>

<pre><code>int x = 5;
double y0 = (int) x;
double y1 = static_cast&lt;int&gt;(x);
</code></pre>

<p>Do not use C style casting it is difficult to find</p>

<hr />

<p>Iterators
Iterators are like generalized pointers into containers.
Most pointer operations *, ->, ++, ==, !=, etc. work with iterators.</p>

<ul>
<li><code>begin()</code> returns an iterator pointing to the first element of the vector.</li>
<li><code>end()</code> returns an iterator pointing past the last element of the vector.</li>
</ul>


<hr />

<p><code>class B : A { ... };</code> specifies private derivation of B from A.</p>

<hr />

<p>Protected class members are inaccessible from outside the class (like private) but accessible within a derived class (like public).</p>

<hr />

<p>ln16.pdf</p>

<ul>
<li>The declaration context is the context in which the <strong>referent</strong> of x appears.</li>
<li>The reference context is the context in which the <strong>reference</strong> x appears.</li>
</ul>


<hr />

<p>Template functions and specialization</p>

<p>Template functions
Definition:</p>

<p>   template <class X> void swapargs(X&amp; a, X&amp; b) {</p>

<pre><code> X temp;
 temp = a;
 a = b;
 b = temp;
</code></pre>

<p>}</p>

<p>Use:</p>

<pre><code> int i,j;
 double x,y;
 char a, b;
 swapargs(i,j);
 swapargs(x,y);
 swapargs(a,b);
</code></pre>

<p>Specialization
Definition:</p>

<pre><code> template &lt;&gt; void swapargs(int&amp; a, int&amp; b) {
   // different code
 }
</code></pre>

<p>This overrides the template body for int arguments.</p>

<hr />

<p><strong>Non-inline template functions must be compiled and linked for each instantiation</strong></p>

<ul>
<li>(a) Put all template function definitions in the .hpp file along with the class definition.</li>
<li>(b) Put template function definition in the .hpp file and explicitly instantiate all the possible types.
  e.g. <code>template class FlexArray&lt;int&gt;; template class FlexArray&lt;double&gt;; ...</code></li>
</ul>


<hr />

<p>C casts. C uses the same syntax for different kinds of casts.</p>

<ul>
<li><strong>Value casts</strong> convert from one representation to another, partially preserving semantics. Often called <em>conversions</em>.</li>
<li><strong>Pointer casts</strong> leave representation alone but change interpretation of pointer.</li>
</ul>


<p>C++ casts</p>

<p>C++ has four kinds of casts.</p>

<ol>
<li>Static cast includes value casts of C. Tries to preserve semantics, but not always safe. Applied at compile time.</li>
<li>Dynamic cast Applies only to pointers and references to objects. Preserves semantics. Applied at run time. [See demo 18c-Dynamic cast.]</li>
<li>Reinterpret cast is like the C pointer cast. Ignores semantics. Applied at compile time.</li>
<li>Const cast Allows const restriction to be overridden. Applied at compile time.</li>
</ol>


<p>notation</p>

<pre><code>int x; myBase* b; const int c;
static_cast&lt;double&gt;(x);
dynamic_cast&lt;myDerived*&gt;(b);
reinterpret_cast&lt;int*&gt;(p);
const_cast&lt;int&gt;(c);
</code></pre>

<hr />

<p><code>explicit</code> keyword inhibit implicit casts.</p>

<pre><code>class B;
class A {
public:
    A(){};
    explicit A(B&amp; b) { cout&lt;&lt; "constructed A from B\n"; }
};
</code></pre>

<hr />

<p>C-style exception solution uses status returns</p>

<p>The C library functions generally report exceptions by returning <em>status values</em> or <em>error codes</em>.</p>

<p>C++ exception mechanism</p>

<p>Deriving your own exception classes from std::exception</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;exception&gt;
using namespace std;
class myexception: public exception {
  virtual const char* what() const throw()
    { return "My exception happened"; }
} myex;  // declares class and instantiates it
int main () {
  try {
    throw myex;
  }
  catch (exception&amp; e) {
    cout &lt;&lt; e.what() &lt;&lt; endl;
  }
return 0; }
</code></pre>

<p>each kind of exception should <strong>throw it’s own type of object</strong>.</p>

<hr />

<p>rethrow</p>

<p><code>throw e;</code> will throw a new copy of e</p>

<p><code>throw;</code> will not throw a new copy of e, but e itself</p>

<hr />

<p><strong>All exceptions should be caught and dealt with explicitly.</strong> That terminate() is called to abort the process is a bad thing when exceptions are not caught or thrown by the destructor.</p>

<hr />

<p>multiple inheritance</p>

<p>class A: public B, protected C {&#8230;};</p>

<p><em>diamond pattern</em>, A->B, A->C, {B,C}->D</p>

<hr />

<p>Good Reference Books</p>

<p>C Programming Language, Effective C++, More Effective C++, Design Patterns</p>

<hr />

<p>test</p>

<pre><code>make test&amp;&amp; ./test
</code></pre>

<hr />

<p>STL</p>

<p>Common wisdom on the internet says <strong>not to inherit from STL containers</strong>.</p>

<blockquote><p>STL containers are not intended to be used as base classes (their destructors are deliberately non-virtual); deriving from a container is a common mistake.”</p></blockquote>

<hr />

<p>Two kinds of derivation</p>

<p>C++ supports two distinct kinds of derivation:</p>

<ul>
<li>Simple derivation.</li>
<li><p>Polymorphic derivation.</p>

<p>  class A { &#8230; };
  class B : public A { &#8230; };</p></li>
</ul>


<p>We say B is derived from A, and B inherits members from A. Each B object has an A object embedded within it.<strong>The derivation is simple if no members of A are virtual; otherwise it is polymorphic.</strong></p>

<hr />

<p>What are the problems of polymorphic derivation? (ln13.pdf)</p>

<p>Every polymorphic base class (containing even one virtual function) adds a <strong>runtime type tag</strong> to each instance.</p>

<p>This costs in both time and space.</p>

<ul>
<li>Time: Each call to a virtual function goes through a <strong>run-time dispatch table (the vtable)</strong>.</li>
<li>Space: Each instance of a polymorphic object contains a <strong>type tag</strong>, which takes extra space.</li>
<li>Every polymorphic base class should have a virtual destructor.</li>
</ul>


<hr />

<p>General OO principles</p>

<ol>
<li><strong>Encapsulation</strong> <em>Data members should be private.</em> Public accessing functions should be defined only when absolutely necessary. This minimizes the ways in which one class can depend on the representation of another.</li>
<li><strong>Narrow interface</strong> <em>Keep the interface (set of public functions) as simple as possible</em>; include only those functions that are of direct interest to client classes. Utility functions that are used only to implement the interface should be kept private. This minimizes the chance for information to leak out of the class or for a function to be used inappropriately.</li>
<li><strong>Delegation</strong> A class that is called upon to perform a task often delegates that task (or part of it) to one of its members who is an expert.</li>
</ol>


<hr />

<p>What is a design pattern?</p>

<p>A pattern has four essential elements.</p>

<ol>
<li>A pattern name.</li>
<li>The problem, which describes when to apply the pattern.</li>
<li>The solution, which describes the elements, relations, and responsibilities.</li>
<li>The consequences, which are the results and tradeoffs.</li>
</ol>


<p>Design Patterns</p>

<ul>
<li><em>Adaptor</em> matches interface between toolkit classes and applications.</li>
<li><em>Indirection</em> decouples high-level applications from manipulations of low-level devices.</li>
<li><em>Proxy</em> is like indirection and controls access via a placeholder</li>
<li><em>Polymorphism</em> enables multiple implementations from the abstraction</li>
<li><em>Controller</em> handles system events</li>
<li><em>Bridge</em> is generalized indirection and decouples interface from implementation. Used when both application and implementation are polymorphic.</li>
<li><em>Subject-observer</em>: keep updated states of the subject with observers.</li>
<li><em>Singleton</em> enforces only one instance of a class</li>
<li><em>Strategy</em> defines a family of algorithms, encapsulates each one, and makes them interchangeable at run time.</li>
<li><em>Factory method</em> defines an interface for creating an object but lets the implementation decide which class to instantiate.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OOP Mid Term Notes]]></title>
    <link href="http://puncsky.github.com/blog/2012/12/19/oop1/"/>
    <updated>2012-12-19T02:01:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/12/19/oop1</id>
    <content type="html"><![CDATA[<p>Referencing composed and base objects. site:http://zoo.cs.yale.edu/classes/cs427/</p>

<h2>C++ Basics</h2>

<h3>1. Properties of C++</h3>

<ol>
<li><strong>Widely used</strong> in the real world.</li>
<li><strong>Close to the machine</strong> and capable of producing efficient code.</li>
<li>Gives a programmer <strong>fine control</strong> over the use of resources.</li>
<li><strong>OOP</strong>: Supports the object-oriented programming paradigm.</li>
<li><strong>Modularity</strong>: Supports modularity and component isolation.</li>
<li><strong>Correctness</strong>: Supports correctness through privacy, modularity, and use of exceptions.</li>
<li><strong>Reusable code</strong>: Supports reusabale code through derivation and templates.</li>
</ol>


<h3>2. C++ file types</h3>

<ol>
<li><em>Header files (.hpp)</em> contain various kinds of declarations needed by clients of a module. They must not contain definitions of non-inline functions.</li>
<li><em>Implementation files (.cpp)</em> contain definitions of non-inline functions and class methods and a few other kinds of things. Public declarations belong in the corresponding .hpp files.</li>
<li><em>Object files (.o)</em> contain the code generated by the compiler from one .cpp file.</li>
<li><strong>Static library files (.a)</strong> are archives (collections) of object files.</li>
<li><em>Executable files</em> commands ready to be run. File names have no extension. They must have the “execute” mode bit set.
is compiled to produce a corresponding .o file.</li>
<li>Linking: All of the .o files, together with needed code from library files, are combined to produce one executable file.</li>
</ol>


<h3>3. Stages of a program creation. Kinds of errors that can be discovered at each stage. Compilation and linking. What does each do? What files are needed? What files are produced?</h3>

<p>Two stages:</p>

<ul>
<li>Compilation: Each .cpp file
<em>For every symbol referenced in any of the .o files, a definition must be found in exactly one .o file or in a library.</em></li>
</ul>


<p>Compiler errors at each stage:</p>

<ul>
<li>Preprocessor errors: Missing #include files, mismatched #ifndf…#endif pairs, etc.</li>
<li>Compilation errors: Syntax, semantics, missing/erroneous declarations. Sometimes the file produced by the preprocessor and seen by the compiler is not what the programmer intended.</li>
<li>Linker errors are generally methods that were declared but never defined, often because of mismatched signatures. Duplicate definitions from different modules also detected here, e.g., multiple definitions of main().</li>
</ul>


<h3>4. Qualifiers: inline, const, static</h3>

<p>4.1. Static data members
- A static class variable must be declared and defined.
- A static class member is declared by preceding the member declaration by the qualifier static.
- A static class member is defined by having it appear in global context with an initializer but without static.
- Must be defined only once.</p>

<p>Example
In mypack.hpp file, inside class definition:</p>

<pre><code>    class MyPack {
        static int instances; // count # instantiations
</code></pre>

<p>In mypack.cpp file:</p>

<pre><code>    int MyPack::instances = 0;
</code></pre>

<p>4.2. Static function members</p>

<ul>
<li>As with static variables, the are declared inside class by prefixing static.</li>
<li>They may be defined either inside the class (as inline functions) or outside the class.</li>
<li>If defined outside the class, the :: prefix must be used and the word static omitted.</li>
</ul>


<p>4.3. const declares a variable (L-value) to be readonly.</p>

<p>If they are used at all, global variables should be const. It is not bad style to use a global const variable because you can do things with it that you cannot do with #define (initialize a constant object of a structured type).</p>

<p>Here are three different uses of the const qualifier in a pointer declaration:</p>

<pre><code>        int const* p; //a mutable pointer to a constant int
        int* const p; //a constant pointer to a mutable int
        int const* const r; //a constant pointer to a constant int
</code></pre>

<p>A little trick: if you read the declaration statement from right to left, it will be much easier to figure out its meaning. For example:</p>

<pre><code>        int const* p; //p is a pointer to a constant integer
        int* const p; //p is a constant pointer to an integer.
</code></pre>

<p>4.4. inline
- Methods <strong>defined</strong> inside a class are inline (e.g., getN()).
- Inline functions are recompiled for every call.
- Inline avoids function call overhead but results in larger code size.
- inline keyword makes following function definition inline.
- Inline functions must be defined in the header (.hpp) file. Why? To expand the code of an inline function at the point of call, the compiler must have access to the function definition. The function prototype is insufficient.</p>

<h3>5. C++ types: primitive (built-in) value types, class types, enum types, typedef, reference types, and pointer types.</h3>

<h2>Classes and objects</h2>

<h3>1. The roles of a class</h3>

<ul>
<li>A type from which objects (instances) can be formed. We say the instances belong to the class.</li>
<li>A collection of things that belong together; a struct with its associated functions.</li>
<li>A way to encapsulate behavior: a public interface with a private implementation.</li>
<li>A way to protect the integrity of data, providing the rest of the world with functions that provide a view of the data but no way to modify it.</li>
<li>A way to organize and automate allocation, initialization, and deallocation</li>
<li>A reusable module.</li>
<li>A way to break a complex problem down into manageable, semi-independent pieces, each with a defined
interface.</li>
<li>An entity that can collaborate with other classes to perform a task</li>
</ul>


<h3>2. Class elements and class structure. class visibility.</h3>

<p>2.1. Class elements</p>

<ul>
<li>A class contains declarations for data members and function members (or methods).</li>
<li>int n; declares a data member of type int.</li>
<li>int getN(){ return n; } is a complete member function definition.</li>
<li>void sortData(); declares a member function that must be defined elsewhere.</li>
<li>By convention, member names begin with lower case letters and are written in camelCase.</li>
</ul>


<p>2.2. Visibility</p>

<ul>
<li>The visibility of declared names can be controlled.</li>
<li>public: declares that following names are visible outside of the class.</li>
<li>private: restricts name visibility to this class.</li>
<li>Public names define the interface to the class.</li>
<li>Private names are for internal use, like local names in functions.</li>
</ul>


<h3>3. Differences between a class definition and a class implementation. Importance of a class interface.</h3>

<p>the public functions of a class are called the class interface.</p>

<h3>4. Constructing/destructing objects.</h3>

<h3>5. Different kinds and roles of constructors: ctors, copy constructors, default constructors.</h3>

<p>Whenever a class object is created, one of its constructors is called.
If not specified otherwise, the default constructor is called. This is <strong>the one that takes no arguments</strong>.
If you do not define the default constructor, then the null constructor (which does nothing) is used.
This applies not only to the “outer” object but also to all of its embedded objects.</p>

<p>5.1. Ctors</p>

<p>(short for constructor/initializors) allow one to supply parameters to implicitly-called constructors.</p>

<p>Example:</p>

<pre><code>    class B : A {  
        B( int n ) : A(n) {};  
        // Calls A constructor with argument n  
    };
</code></pre>

<p>5.2. Copy constructors</p>

<ul>
<li>A copy constructor is automatically defined for each new class A and has prototype A(const A&amp;). It initializes a newly created A object by making a shallow copy of its argument.</li>
<li>Copy constructors are used for call-by-value parameters.</li>
<li><strong>Assignment</strong> uses operator=(), which by default copies the data members but does not call the copy constructor.</li>
<li><p><em>The results of the implicitly-defined assignment and copy constructors are the same</em>, but they can be redefined to be different.</p></li>
<li><p>Initialization, assignment, copying of objects (and variables in general)</p></li>
</ul>


<p>Initialization ctors
Ctors also can be used to initialze primitive (non-class) variables.</p>

<p>Example:</p>

<pre><code>    class  B {  
        int x;  
        const int y;  
        B( int n ) : x(n), y(n+1) {}; // Initializes x and y  
    };
</code></pre>

<p>Multiple ctors are separated by commas.</p>

<p>Ctors present must be in the same order as the construction takes place – base class ctor first, then data member ctors in the same order as their declarations in the class.</p>

<p>Initialization not same as assignment</p>

<p>Previous example using ctors is not the same as writing</p>

<pre><code>    B( int n ) { y=n+1; x=n; };
</code></pre>

<p>The order of initialization differs.</p>

<p>const variables can be initialized but not assgined to.</p>

<p>Initialization uses the constructor (for class objects).</p>

<p>Initialization from another instance of the same type uses the copy constructor.</p>

<h2>I/O</h2>

<h3>1. streams: cin, cout, cerr, and clog</h3>

<ul>
<li>cin is the standard input stream.</li>
<li>cout is the standard output stream.</li>
<li>cerr is the standard output stream for errors.</li>
<li>clog is the standard output stream for logging.</li>
</ul>


<p>Standard output is called cout. Other predefined output streams are cerr and clog. They are usually initialized to standard output <strong>but can be redirected</strong>.</p>

<h3>2. Handling files.</h3>

<ul>
<li>ifstream fin ( &#8220;myfile.in&#8221; ); opens stream fin for reading. This implicitly invokes the constructor ifstream( &#8220;myfile.in&#8221; ).</li>
<li>ifstream fin; creates an input stream not associated with a file. fin.open( &#8220;myfile.in&#8221; ); attaches it to a file. Can also specify open modes.</li>
<li>To test if fin failed to open correctly, write if (!fin) {…}.</li>
<li>To close, use fin.close();.</li>
</ul>


<p>Can read a line into a buffer with fin.get(buf, buflen);. This function stops before the newline is read. To continue, one must move past the newline with a simple fin.get(ch); or fin.ignore();.</p>

<h3>3. <strong>Manipulators</strong>.</h3>

<p>Manipulators are objects that can be arguments of <em>>></em> or <em>&lt;&lt;</em> but do not necessarily produce data.</p>

<p>Example:</p>

<pre><code>    cout &lt;&lt; hex &lt;&lt; x &lt;&lt; y &lt;&lt; dec &lt;&lt; z &lt;&lt; endl;
</code></pre>

<p>Prints x and y in hex and z in decimal. After printing z, a newline is printed and the output stream is flushed. Manipulators are used in place of C formats to control input and output formatting and conversions.</p>

<h3>4. Kinds of I/O errors and ways to handle them.</h3>

<h3>5. Error flags, their meaning and how they are set.</h3>

<p>I/O functions set status flags after each I/O operation. <strong>bad</strong> means there was a read or write error on the file I/O. <strong>fail</strong> means the data was not appropriate to the field, e.g., trying to read a non-numeric character into a numeric variable. <strong>eof</strong> means that the end of file has been reached. <strong>good</strong> means that the above three bits are all off.</p>

<p>The whole state can be read with one call to rdstate().</p>

<pre><code>    // getting state of stream object
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;
    using namespace std;

    int main () {
        ifstream is;
        is.open ("test.txt");
        if ( (is.rdstate() &amp; ifstream::failbit ) != 0 ) // if failbit flag is on
            cerr &lt;&lt; "Error opening 'test.txt'\n";
        return 0;
    }
</code></pre>

<p>Functions are also provided for testing useful combinations of status bits.</p>

<ul>
<li>good() returns true if the good bit is set.</li>
<li>bad() returns true if the bad bit is set. This is not the same as !good().</li>
<li>fail() returns true if the bad bit or the fail bit is set.</li>
<li>eof() returns true if the eof bit is set.</li>
</ul>


<p>As in C, correct end of file and error checking require paying close attention to detail of exactly when these state bits are turned on.</p>

<p>To continue after a bit has been set, must call <strong>clear()</strong> to clear it.</p>

<ol>
<li>Extending operators. What operators can be extend and how? Advantages of extending operators.</li>
</ol>


<p>Operators can be extended to work with new types, for example, complex numbers. +-*/</p>

<p>The built-in arithmetic operators in C and C++ are generic; they are defined for all built-in numeric types. One of the purposes of an object-oriented language is to enable the programmer to define new classes and use them in the same ways that the built-in classes are used. Combining these two facts, we see a need to extend the built-in generic operators to work on new classes. An operator extension implements a built-in function for a new type in such a way that the intention and character of the original operator are preserved.</p>

<pre><code>    inline  
    ostream&amp; operator&lt;&lt;(ostream&amp; out, const Square&amp; sq) {  
        return sq.print(out);  
    }
</code></pre>

<h2>Functions and methods</h2>

<h3>1. Passing data to a function. What are the different ways to pass data to a function? Advantages of each method.</h3>

<ul>
<li>Call by value: The argument values are copied into the parameter storage locations in the function&#8217;s stack frame. There is no way for the function to change values in main&#8217;s stack frame.</li>
<li>Call by pointer: The arguments must be addresses of integer variables in the caller&#8217;s stack frame. These
addresses are stored in the parameter locations in the function&#8217;s stack frame. They permit the function to
modify its caller&#8217;s memory locations.</li>
<li>Call by reference: The arguments must be integer variables in the caller&#8217;s stack frame. The addresses of
these variables are stored in the parameter locations in the function&#8217;s stack frame, permitting the function to modify its caller&#8217;s memory locations.</li>
</ul>


<p>TODO advantages</p>

<h3>2. Receiving data from a function. How data can be passed back from a function? Can more than one value be returned?</h3>

<ul>
<li>Return by value.</li>
<li>Return by pointer.</li>
<li>Return by const T *</li>
<li>Return by reference</li>
<li><p>Return by const T &amp;</p>

<pre><code>  int ret0( int* ar ) { return ar[0]; } // Returns an integer R-value.
  int* ret1( int* ar ) { return &amp;ar[1]; } // A pointer R-value.
  const int* ret2( int* ar ) { return &amp;ar[2]; } // A read-only pointer R-value.
  int&amp; ret3( int* ar ) { return ar[3]; } // An L-value (reference).
  const int&amp; ret4( int* ar ) { return ar[4]; } // A read-only L-value reference.
</code></pre></li>
</ul>


<h2>Pointers and references</h2>

<h3>1. L-values and R-values.</h3>

<p>Something that can appear on the left is called an L-value.
Something that can appear on the right is called an R-value.
Intuitively, an L-value is the <strong>address of a storage location</strong> – some place where a value can be stored.
An R-value is a thing that can be placed in a storage location.
R-values are sometimes called <strong>pure data values</strong>.</p>

<p>The declaration int x = 3; says several things:</p>

<ul>
<li>All values that can be stored in x have type int.</li>
<li>The name x is bound (when the code is executed) to a storage location adequate to store an int.</li>
<li>The int value 3 is initially placed in x’s storage location.</li>
</ul>


<p>The assignment statement x = 3; means the following:</p>

<ul>
<li>Get an L-value from the left hand side (x).</li>
<li>Get an R-value from the right hand side (3).</li>
<li>Put the R value from step 2 into the storage location whose address was obtained from step 1.</li>
</ul>


<p>Given int x = 3;  int y = 4; Consider x = y; This is processed as before, except what does it mean to get an R-value from y?</p>

<p><strong>Whenever an L-value is presented and an R-value is needed, automatic deferencing occurs.</strong></p>

<p>This means to go the storage location specified by the presented L-value (y) and get its R-value (4).</p>

<p>Then the assignment takes place as before.</p>

<h3>2. References vs. pointers</h3>

<p>A pointer [reference value] is a primitive object with an associated L-value.</p>

<p>TODO</p>

<h3>3. Relationship between a reference and a pointer.</h3>

<p>TODO</p>

<h2>Derivation</h2>

<h3>1. What is derivation?</h3>

<p>One class can be derived from another.</p>

<p>Syntax:</p>

<pre><code>    class A {  
    public:  
        int x;  
        ...  
    };  
    class B : public A {  
        int y;  
        ...  
    };
</code></pre>

<p>A is the base class; B is the derived class.</p>

<p>B inherits the members from A.</p>

<h3>2. When to use and when not to use class derivation.</h3>

<p>Use</p>

<ul>
<li>To allow a family of related classes to share common parts.</li>
<li>To describe abstract interfaces like Java.</li>
<li>To allow generic methods with run-time dispatching.</li>
<li>To provide a clean interface between existing, non-modifiable code and added user code.</li>
</ul>


<h3>3. Structure of an object</h3>

<p>Structure of an object A simple object is like a struct in C. It consists of a block of storage large enough to contain all of its data members. An object of a derived class contains an instance of the base class followed by the data members of the derived class.</p>

<p>Example:</p>

<pre><code>    class B : A { …};
    B bObj;
</code></pre>

<p>Then “inside” of bObj is an A-instance!</p>

<h3>4. Referencing composed and base objects.</h3>

<h4>4.1 Referencing a composed object</h4>

<p>Contrast the previous example to</p>

<pre><code>    class B { A aObj; …};
    B bObj;
</code></pre>

<p>Here B composes A.</p>

<p>The embedded A object can be referenced using data member name aObj, e.g., bObj.aObj.</p>

<h4>4.2 Referencing a base object</h4>

<pre><code>    class A { public: int x; int y; …};
    class B : A { int y; …};
    B bObj;
</code></pre>

<ul>
<li>The data members of A can be referenced directly by name.</li>
<li>x refers to data member x in class A.</li>
<li>y refers to data member y in class B.</li>
<li>A::y refers to data member y in class A.</li>
<li>this points to the whole object. Its type is B*. It can be coerced to type A*.</li>
</ul>


<h3>5. Construction/destruction rules.</h3>

<h4>5.1 Construction rules</h4>

<p>The rule for an object of a simple class is:</p>

<ol>
<li>Call the constructor/initializer for each data member object in sequence.</li>
<li>Call the constructor for the class.</li>
</ol>


<p>The rule for an object of a derived class is:</p>

<ol>
<li>Call the constructor for the base class recursively.</li>
<li>Call the constructor/initializer for each data member object of the derived class in sequence.</li>
<li>Call the constructor for the derived class.</li>
</ol>


<h4>5.2 Destruction rules</h4>

<p>When an object is deleted, the destructors are called in the opposite order.</p>

<p>The rule for an object of a derived class is:</p>

<ol>
<li>Call the destructor for the dervied class.</li>
<li>Call the destructor for each data member object of the derived class in reverse sequence.</li>
<li>Call the destructor for the base class.</li>
</ol>


<h2>Error</h2>

<h3>1. Five kinds of failures. When different errors can occur?</h3>

<ul>
<li><strong>Memory leak</strong>—Dynamic storage that is no longer accessible but has not been deallocated.</li>
<li><strong>Amnesia</strong>—Storage values that mysteriously disapper.</li>
<li><strong>Bus error</strong>—Program crashes because of an attempt to access non-existant memory.</li>
<li><strong>Segmentation fault</strong>—Program crashes because of an attempt to access memory not allocated to your process.</li>
<li><strong>Waiting for eternity</strong>—Program is in a <em>permanent wait state</em> or an infinite loop.</li>
</ul>


<h3>2. Memory leaks – what they are, how they arise, how they can be detected and design patterns for avoiding them.</h3>

<h3>3. Memory management paradigms.</h3>

<h2>C++ Standard Library </h2>

<h3>1. What is the C++ Standard Library and how can it be used?</h3>

<h3>2. Two classes: stringstream and vector</h3>

<p>stringstream – permits I/O to an in-memory string-like object.</p>

<p>vector<T> – creates a growable array of objects of type T, where T can be any type.</p>

<h4>Class stringstream</h4>

<p>A stringstream object (in the default case) acts like an ostream object.</p>

<p>It can be used just like you would use cout.</p>

<p>The characters go into an internal buffer rather than to a file or device.</p>

<p>The buffer can be retrieved as a string using the str() member function.</p>

<p>stringstream example</p>

<p>Example: Creating a label from an integer.</p>

<pre><code>    #include &lt;sstream&gt;  
    ...  
    int examScore=94;  
    stringstream ss;  
    string label;  
    ss &lt;&lt; "Score=" &lt;&lt; examScore;  
    label = ss.str();  
    cout &lt;&lt; label &lt;&lt; endl;
    This prints Score=94.
</code></pre>

<h4>vector</h4>

<p><em>vector<T> myvec</em> is something like the C array T myvec[].</p>

<p>The element type T can be any primitive, object, or pointer type.</p>

<p>One big difference is that a vector starts empty (in the default case) and it grows as elements are appended to the end.</p>

<p>Useful functions:</p>

<ul>
<li>myvec.push_back( item ) appends item to the end.</li>
<li>myvec.size() returns the number of objects in myvec</li>
<li>myvec[k] returns the object in myvec with index k (assuming it exists.) Indices run from 0 to size()-1.
Other operations on vectors</li>
<li>Other operations include creating an empty vector, inserting, deleting, and copying elements, scanning through the vector, and so forth.</li>
<li>Liberal use is made of operator definitions to make vectors behave as much like other C++ objects as possible.</li>
<li>Vectors implement value semantics, meaning type T objects are copied freely within the vectors.</li>
<li>If copying is a problem, store pointers instead.
vector examples</li>
</ul>


<p>You must</p>

<pre><code>    #include &lt;vector&gt;.
</code></pre>

<p>Elements can be accessed using standard subscript notion.</p>

<p>Inserting at the beginning or middle of a vector takes time O(n).</p>

<p>Example:</p>

<pre><code>    vector&lt;int&gt; tbl(10);  // creates length 10 vector of int  
    tbl[5] = 7;           // stores 7 in slot #5  
    cout &lt;&lt; tbl[5];       // prints 7  
    tbl[10] = 4;          // illegal, but not checked!!!  
    cout &lt;&lt; tbl.at(5);    // prints 7  
    tbl.at(10) = 4;       // illegal and throws an exception  
    tbl.push_back(4);     // creates tbl[10] and stores 4  
    cout &lt;&lt; tbl.at(10);   // prints 4
</code></pre>

<h2>Class dependencies</h2>

<ol>
<li>Tightly coupled classes.</li>
</ol>


<p>Class B depends on class A if B refers to elements declared within class A or to A itself.</p>

<p>A pair of classes A and B are <strong>tightly coupled</strong> if each depends on the other.</p>

<ol>
<li>Circular dependencies.</li>
</ol>


<p>File list.hpp:</p>

<pre><code>        #pragma once  
        #include "cell.hpp"  
        class List { ... };
        File cell.hpp:

        #pragma once  
        #include "list.hpp"  
        class Cell { ... };
        File main.cpp:

        #include "list.hpp"  
        #include "cell.hpp"  
        int main() { ... }
</code></pre>

<p>Resolving circular dependencies</p>

<ul>
<li>Suppose the only reference to B in A is to declare a pointer. Then it works to put a <strong>“forward” declaration</strong> of B at the top of A.hpp, for example:

<pre><code>  class B;
  class A { B* bp; ... };
</code></pre></li>
<li>If a function defined in A references symbols of B, then the definition of the function must be moved outside the class and placed where it will be read after B has been read in, e.g., in the A.cpp file.</li>
<li>If the function needs to be inline, this is still possible, but it’s much trickier getting the inline function definition in the right place.</li>
</ul>


<h2>Visualization</h2>

<ol>
<li>Unified Modeling Language (UML)</li>
</ol>


<p>TODO</p>

<ol>
<li><p>Elementary design principles.</p></li>
<li><p>Privacy</p></li>
<li>Expert</li>
<li>Creation</li>
<li>Deletion</li>
<li>Consistency</li>
<li>Delegation</li>
<li>Don&#8217;t talk to strangers</li>
<li>Responsibility</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CLRS Notes]]></title>
    <link href="http://puncsky.github.com/blog/2012/12/19/clrs/"/>
    <updated>2012-12-19T01:42:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/12/19/clrs</id>
    <content type="html"><![CDATA[<h2>I Foundations</h2>

<h3>1 The Role of Algorithms in Computing 5</h3>

<h4>1.1 Algorithms 5</h4>

<p>An algorithm is thus a sequence of computational steps that transform the input into the output.</p>

<h4>1.2 Algorithms as a technology 11</h4>

<p>lg n &lt; sqrt(n) &lt; n &lt; n lg(n) &lt; n<sup>2</sup> &lt; n<sup>3</sup> &lt; n!</p>

<h3>2 Getting Started 16</h3>

<h4>2.1 Insertion sort 16</h4>

<pre><code>void insertionSort(double* A, int size) {
    for (int i = 1; i &lt; size; ++i) {
        double key = A[i];
        int index = i - 1;
        while (index &gt;= 0 &amp;&amp; A[index] &gt; key) {
            A[index+1] = A[index];
            -- index;
        }
        A[i+1] = key;
    } 
}
</code></pre>

<h4>2.2 Analyzing algorithms 23</h4>

<p>insertion sort has a worst-case running time of Θ(n<sup>2)</sup></p>

<h4>2.3 Designing algorithms 29</h4>

<ul>
<li>The divide-and-conquer approach and recursive</li>
</ul>


<p>c-code:</p>

<pre><code>//Input:
//  A array
//  size size of A
//  p starting index of the span waiting to be sorted
//  r ending index of the span waiting to be sorted
//Procedure:
//  sort left
//  sort right
//  merge by comparing two numbers from the sorted left and right pair by pair
//Output:
//  A sorted array 
void mergeSort(double* A, int size, int p, int r) {
    if (p &lt; r) {
        int q = (p+r)/2;
        mergeSort(A, 10, p, q);
        mergeSort(A, 10, q+1, r);
        merge(A, 10, p, q, r);
    }
}
void merge(double* A, int size, int p, int q, int r) {
    // create left and right arrays                                                                                                          
    int span1 = q-p+1;
    int span2 = r-q;
    double* left = reinterpret_cast&lt;double*&gt;(malloc(sizeof(double) * (span1+1)));
    double* right= reinterpret_cast&lt;double*&gt;(malloc(sizeof(double) * (span2+1)));
    for (int i = 0; i &lt; span1; ++i) left [i] = A[p+i];
    for (int i = 0; i &lt; span2; ++i) right[i] = A[q+1+i];
    left [span1] = numeric_limits&lt;double&gt;::max();
    right[span2] = numeric_limits&lt;double&gt;::max();
    for(int k=p, i=0, j=0; k&lt;=r; ++k) {
        if (left[i] &lt;= right[j]) {
            A[k] = left [i];
            ++i;    
        } else {
            A[k] = right[j];
            ++j;
        }
    }
    free(left);
    free(right);
}
int main() {
    double A[10] = {4.,3.,2.,1.,0.,5.,6.,8.,7.,9.};
    for (int i=0; i&lt;10; ++i)
        cout &lt;&lt; A[i];
    cout &lt;&lt; endl;
    mergeSort(A, 10, 0, 9);
    for (int i=0; i&lt;10; ++i)
        cout &lt;&lt; A[i];
    cout &lt;&lt; endl;
}
</code></pre>

<ul>
<li>Θ(n lg n) but not operate in place</li>
</ul>


<h3>3 Growth of Functions 43</h3>

<h4>3.1 Asymptotic notation 43</h4>

<ul>
<li><strong>O()</strong>. When we have only an <strong>asymptotic upper bound</strong>, we use O-notation.

<ul>
<li>O(g(n)) = {f(n): there exist positive constants c and n0 such that 0 &lt;= f(n) &lt;= c*g(n) for all n >= n0}.</li>
<li>if f(n) == c*g(n) is not possible, we use <strong>o()</strong></li>
</ul>
</li>
<li><strong>Θ()</strong>. When we have <strong>both an asymptotic upper bound and an asymptotic lower bound</strong>, we use Θ-notation.

<ul>
<li>Θ(g(n)) = {f(n): there exist positive constants c1, c2, and n0 such that 0 &lt;= c1<em>g(n) &lt;= f(n) &lt;= c2</em>g(n) for all n >=  n0}</li>
</ul>
</li>
<li><strong>Ω()</strong>, When we have only an <strong>asymptotic lower bound</strong>, we use omega-notation.

<ul>
<li>uppercase_omega(g(n)) = {f(n): there exist positive constants c and n0 such that 0 &lt;= c*g(n) &lt;=  f(n) for all n >= n0}</li>
<li>if f(n) == c*g(n) is not possible, we use <strong>ω()</strong></li>
</ul>
</li>
</ul>


<h4>3.2 Standard notations and common functions 53</h4>

<h3>4 Divide-and-Conquer 65</h3>

<ul>
<li>Three ways for solving recurrences

<ul>
<li>substitution method</li>
<li>recursive-tree method</li>
<li>master method

<ul>
<li>T(n) = a*T(n/b) + f(n), a>=1, b>1. It characterizes a divide- and-conquer algorithm that creates <em>a</em> subproblems, each of which is <em>1/b</em> the size of the original problem, and in which the divide and combine steps together take f(n) time.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>4.1 The maximum-subarray problem 68</h4>

<p>In the stock market, you need to buy low and sell high. But the maximum profit does not always start at the lowest price or end at the highest price.</p>

<h5>A brute-force solution</h5>

<p>Choose 2 from n pairs of (date, price) and calculate the difference. Θ(n<sup>2)</sup></p>

<h5>A solution using divide-and-conquer</h5>

<p>A transformation: create an array of the daily change in price, and <strong>find the maximum subarray</strong>.</p>

<ul>
<li>find the max subarray on the left</li>
<li>find the max subarray on the right</li>
<li>find the max subarray crossing the middle

<ul>
<li>find max left, max right, and their sum</li>
</ul>
</li>
<li>take the max of the above</li>
</ul>


<p>TODO: codes</p>

<p>Θ(n*lg(n))</p>

<h4>4.2 Strassen’s algorithm for matrix multiplication 75</h4>

<p>O(n<sup>3)</sup> to O(n<sup>2.81)</sup></p>

<h4>4.3 The substitution method for solving recurrences</h4>

<ol>
<li>Guess the form of the solution.</li>
<li>Use mathematical induction to find the constants and show that the solution works.</li>
</ol>


<h4>4.4 The recursion-tree method for solving recurrences 88</h4>

<p>depth * height</p>

<h4>4.5 The master method for solving recurrences 93</h4>

<p><img src="http://puncsky.github.com/images/CLRS/mastermethod.png" alt="Master Method" /></p>

<h3>5 Probabilistic Analysis and Randomized Algorithms 114</h3>

<p>5.1 The hiring problem 114
5.2 Indicator random variables 118
5.3 Randomized algorithms 122
5.4 Probabilistic analysis and further uses of indicator random variables</p>

<h2>II Sorting and Order Statistics Introduction 147</h2>

<table>
  <tr>
    <th></th>
    <th>worst-case running time</th>
    <th>average-cased running time</th>
  </tr>
  <tr>
    <th>Insertion sort</th>
    <td>Θ(n^2)</td>
    <td>Θ(n^2)</td>
  </tr>
  <tr>
    <th>Merge sort</th>
    <td>Θ(n lg n)</td>
    <td>Θ(n lg n)</td>
  </tr>
  <tr>
    <th>Heapsort</th>
    <td>O(n lg n)</td>
    <td>-</td>
  </tr>
  <tr>
    <th>Quicksort</th>
    <td>Θ(n^2)</td>
    <td>Θ(n lg n) (*)</td>
  </tr>
  <tr>
    <th>Counting sort</th>
    <td>Θ(k+n)</td>
    <td>Θ(k+n)</td>
  </tr>
  <tr>
    <th>Radix sort</th>
    <td>Θ(d(n+k))</td>
    <td>Θ(d(n+k))</td>
  </tr>
  <tr>
    <th>Bucket sort</th>
    <td>Θ(n^2)</td>
    <td>Θ(n) </td>
  </tr>
</table>


<h3>6 Heapsort 151</h3>

<p>O(n lg n),Our heap data structure is not garbage-collected storage.</p>

<h4>6.1 Heaps 151</h4>

<p>The (binary) heap data structure is an array object that we can view as a nearly complete binary tree.</p>

<pre><code>// calculate by shifting the binary representation
int parent(i) {
    return i/2;
}
int left(i) {
    return 2*i;
}
int right(i) {
    return 2*i + 1;
}
</code></pre>

<ul>
<li>max-heap: for every node <em>i</em> other than the root, A[parent(i)]>=A[i].</li>
<li>min-heap: for every node <em>i</em> other than the root, A[parent(i)]&lt;=A[i].</li>
<li>height of a node: number of edges on the longest simple downward path from the node to a leaf.</li>
<li>height of the heap: height of its root. Θ(lg n)</li>
</ul>


<h4>6.2 Maintaining the heap property 154</h4>

<pre><code>// Input:
//      A array
//      i index
//   Binary trees rooted at left(i) and right(i) are max-heaps
//   but A[i] might be smaller than its children. 
// Procedure:
//      exchange A[i] with the larger one between A[left[i]] and A[right[i]]
//      maxHeapify the new sub tree
// Output:
//      This routine lets the value at A[i] float down in the max-heap. 
maxHeapify(A, i) {
    TODO;
}
</code></pre>

<p>T(n) &lt;= T(2*n/3) + Θ(1)</p>

<h4>6.3 Building a heap 156</h4>

<p>6.4 The heapsort algorithm 159
6.5 Priority queues 162</p>

<h3>7 Quicksort 170</h3>

<p>7.1 Description of quicksort 170
7.2 Performance of quicksort 174
7.3 A randomized version of quicksort 179
7.4 Analysis of quicksort 180</p>

<h3>8 Sorting in Linear Time 191</h3>

<p>8.1 Lower bounds for sorting 191
8.2 Counting sort 194
8.3 Radix sort 197
8.4 Bucket sort 200</p>

<h3>9 Medians and Order Statistics 213</h3>

<p>9.1 Minimum and maximum 214
9.2 Selection in expected linear time 215
9.3 Selection in worst-case linear time 220</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast Crash Recovery in RAMCloud (SOSP'11)]]></title>
    <link href="http://puncsky.github.com/blog/2012/12/13/fast-crash-recovery-in-ramcloud/"/>
    <updated>2012-12-13T12:22:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/12/13/fast-crash-recovery-in-ramcloud</id>
    <content type="html"><![CDATA[<p><a href="http://www.stanford.edu/~ouster/cgi-bin/home.php">Stanford</a>, <a href="http://www.stanford.edu/~ouster/cgi-bin/papers/ramcloud-recovery.pdf">paper</a>, <a href="https://ramcloud.stanford.edu/wiki/display/ramcloud/RAMCloud+Presentations">slides</a>, <a href="http://www.youtube.com/watch?v=RE3CmdEGv4M">video</a></p>

<h3>1. Problem</h3>

<p>RAMCloud is a storage system helping developers manage large-scale DRAM storage, driven by the fact that large-scale Web applications need to cache large data in DRAM. (For example, Facebook cached 150TB DRAM in <em>memcached</em> out of 200TB of disk storage.)</p>

<p>In order to keep a high level of durability and availability without impacting system performance, RAMCloud has only one single copy of data in DRAM. The problem here is how to recover from crash within 1s~2s.</p>

<!--more-->


<h3>2. Challenges</h3>

<ul>
<li><strong>Durability</strong>. RAM is lack of durability. Data is unavailable on crashed nodes.</li>
<li><strong>Availability</strong>. How to recover as soon as possible?

<ul>
<li>Synchronous disk writes too slow</li>
</ul>
</li>
<li><strong>Large scale</strong>. 10,000 nodes, 100TB to 1PB</li>
</ul>


<h3>3. Solution</h3>

<ul>
<li>For durability, keep a <em>pervasive log structure</em>. Even RAM is a log.</li>
<li>For availability, employ data parallelism and pipelining while backup data are distributed across a large number of secondary storage devices.</li>
</ul>


<p>Architecture Overview</p>

<p>(Up to 100,000) application servers are connected to (up to 10,000) master/backup storage servers. Each storage server contains a master and a backup. Masters expose RAM as key-value store, while backups store data from other Masters. A central coordinator manages the server pool and tablet configuration.</p>

<p>When a master receives a write requests, it updates its in-memory log and forwards the new data to several backups, which buffer the data in their memory. Master maintains a hash table to record locations of data objects. The data is eventually written to disk or flash in large batches. <strong>Backups must use an auxiliary power source to ensure that buffers can be written to stable storage after a power failure.</strong></p>

<p>When a master crashes, its in-memory log and hash table will be lost, but log data stored on disk on backups will survive.</p>

<p>How to recover? The crashed and restarted master replays log data into RAM and reconstruct the hash table.</p>

<p>How to recover with scale? Partition and scatter log data to more backups randomly. So backup data can be read in parallel.</p>

<p>How about the network bandwidth bottleneck of NIC on recovery master? More recovery masters are used and each master&#8217;s data are also partitioned. Before recovery, backups receive a partition list specifying which master should what part of data should be sent to.</p>

<p><strong>What if one backup is slow and make the whole process slow?</strong> The master chooses candidate Backups randomly and selects the best one according to its locality, disk information, etc.</p>

<p>Performance: recovers 35GB to RAM in 1.6s using 60 nodes.</p>

<h3>4. Conclusion</h3>

<p>The authors use the log-structured storage instead of synchronous disk write to preserve durability. And the availability is achieved via data parallelism. The design harness the scale well and has exceptional performance.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CleanOS: Limiting Mobile Data Exposure with Idle Eviction (OSDI'12)]]></title>
    <link href="http://puncsky.github.com/blog/2012/12/06/cleanos/"/>
    <updated>2012-12-06T06:40:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/12/06/cleanos</id>
    <content type="html"><![CDATA[<p><a href="http://systems.cs.columbia.edu/projects/cleanos/">Columbia University</a>, <a href="https://www.usenix.org/system/files/conference/osdi12/osdi12-final-203.pdf">paper</a> <a href="https://www.usenix.org/sites/default/files/conference/protected-files/tang_osdi12_slides.pdf">slides</a>, <a href="https://www.usenix.org/conference/osdi12/cleanos-increasing-mobile-data-control-cloud-based-eviction">video</a></p>

<h3>1. Problem</h3>

<p>How to protect sensitive data in mobile phones? Mobile devices are extremely prone to be stolen or lost.</p>

<!--more-->


<h3>2. Challenges</h3>

<ul>
<li>Users don’t lock their devices (57%) or configure poor passwords</li>
<li><strong>Physical attacks</strong> are notoriously difficult to protect against

<ul>
<li>E.g., memory dumps, cold boot attacks, breaking trusted-hardware seals can reveal data or decryption keys</li>
</ul>
</li>
</ul>


<h3>3. Solution</h3>

<p>CleanOS evicts cryptographic keys to the trusted cloud and keeps a clean environment at all times:</p>

<ol>
<li>Sensitive data objects (SDOs) disappear automatically unless are frequently used</li>
<li><em>evict-idle</em> garbage collector (eiGC) encrypts objects that have not been active for a while</li>
</ol>


<p>Architecture Overview: 1. SDO abstraction, 2. Dalvik interpreter with eiGC, 3. SDO cloud store</p>

<h4>SDO</h4>

<p>Application developers restrict sensitive data with SDO. There are three default default: &#8220;SSL&#8221;, &#8220;User Input&#8221;, &#8220;Password&#8221; SDOs in SDK. And it does not rely on app modifications.</p>

<pre><code>// SDO API:
class SDO {
    SDO(String description, SDOLevel level) // new SDO
    void add(Object o)      // adds object to SDO
    void remvoe(Object o)   // removes object from SDO
}
// CleanOS protocol between the phone and the cloud
registerSDO(sdoID, appName, description, key) 
    // register SDO with DB
fetchKey(appName, sdoID, bucketID) -&gt; key || null
    // fetches the key for a bucket in the SDO
    // bucketID = 0 returns the SDO's key
sdoEvicted(appName, sdoID)
    // anounces an SDO's eviction to the cloud
</code></pre>

<h4>Dalvik VM</h4>

<ol>
<li>Tracking module(Modified TaintDroid): automatically marks and saves SDO</li>
<li>Eviction module with eiGC: periodically <code>sdoEvicted()</code> (AES)</li>
<li>Decryption module: <code>fetchKey()</code> (Several keys at once)</li>
</ol>


<h4>Trusted Clouds</h4>

<p>The cloud keeps the DB to store SDO information and audit logs.</p>

<h4>Implementation &amp; Evaluation</h4>

<p>Dalvik VM(TaintDroid taint-tracking system, interpreter, GC,&#8230;) , Google App Engine.</p>

<p>Exposure: ~100% to &lt;~7%</p>

<p>Auditing: much better with user-defined SDOs</p>

<p>Reasonable network traffic and energy overhead with optimization.</p>

<h3>4. Conclusion</h3>

<p>Smartphones accumulate sensitive data over time and is vulnerable to physical attacks. CleanOS protects confidentiality in smartphones by evicting idle sensitive data to the trusted cloud. The idea is mainly implemented with SDO and eiGC. It successfully provides practical protection and auditing services for Android devices.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chord: A Scalable Peer-to-peer Lookup Service for Internet Applications]]></title>
    <link href="http://puncsky.github.com/blog/2012/12/06/chord/"/>
    <updated>2012-12-06T06:29:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/12/06/chord</id>
    <content type="html"><![CDATA[<p><a href="http://pdos.lcs.mit.edu/chord/">MIT PDOS</a>, <a href="http://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf">paper</a>, <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=5&amp;cad=rja&amp;ved=0CGEQFjAE&amp;url=http%3A%2F%2Fpdos.csail.mit.edu%2Frtm%2Fslides%2Fsigcomm01.ppt&amp;ei=tYLAUNjmLoSt0AGb7YCoBw&amp;usg=AFQjCNHmlld_WDglWjj7TP_coYsk1O_l-A&amp;sig2=SO8yiWfEsi_V2VEI-F2pmw">slides</a></p>

<h3>1. Problem</h3>

<p><em>A lookup protocol</em>: How to locate the node that stores a data item in a dynamic P2P system with frequent node arrivals and departures? In other words, given a key, it maps the key onto a node.</p>

<!--more-->


<h3>2. Challenges</h3>

<ul>
<li>Scalability

<ul>
<li>Previous consistent hashing needs to know <strong>most</strong> other nodes</li>
</ul>
</li>
<li>Robustness</li>
<li>Efficiency

<ul>
<li>Centralized lookup (Napster): O(N)</li>
<li>Flooded queries (Gnutella): Worst case O(N)</li>
</ul>
</li>
<li>Simplicity</li>
</ul>


<h3>3. Solution</h3>

<p>Chord: Just <code>IPaddress Lookup(key)</code> service, no data storage.</p>

<p>Distributed Hash Table (DHT)</p>

<p><strong>Consistent Hashing</strong>: Key ID and Node ID are in the <strong>same ID space</strong> with SHA-1. A key is stored at is successor (node with next higher ID). For each node &#8230;</p>

<h4>Simple Lookup Algorithm (O(n))</h4>

<p>Each node picks a random ID in a circular numeric space, and supervises a region of ID space immediately following its ID. The data shall be stored in its successor.</p>

<pre><code>Lookup(my-id, key-id)
    n = my sucessor
    if my-id &lt; n &lt; key-id
        call Lookup(id) on node n   // next hop
    else
        return my successor         // done
</code></pre>

<h4>Lookup with finger tables (log(N))</h4>

<p>Finger i points to successor of n+2<sup>i.</sup></p>

<pre><code>Lookup(my-id, key)
    look in local finger table for highest node m s.t. my-id &lt; n &lt; key-id
    if n exists
        call Lookup(id) on node n   // next hop
    else
        return my successor         // done
</code></pre>

<p>How to join a new node? For example, join N36 (Node 36) between N25 and N40.</p>

<ol>
<li>Lookup(36) and get N40&#8217;s IP</li>
<li>N36 sets its own successor pointer point to N40</li>
<li>Copy keys 26~36 from N40 to N36</li>
<li>Set N25&#8217;s successor pointer point to N36, and update finger pointers in the background</li>
</ol>


<p>How to deal with failure (a node doesn&#8217;t know correct successor)?</p>

<ul>
<li>Successor lists. Each node knows <em>r</em> immediate successors.

<ul>
<li>Assume 1/2 of nodes fail.</li>
<li>P(successor list all dead) (1/2)<sup>r</sup></li>
<li>P(no broken nodes)=(1-(1/2)<sup>r)<sup>N</sup></sup></li>
</ul>
</li>
</ul>


<h4>Lookup with fault tolerance</h4>

<pre><code>Lookup(my-id, key-id)
    look in local finger table and sucessor-list for highest node n s.t. my-id &lt; n &lt; key-id
    if n exists
        call Lookup(id) on node n   // next hop
        if call failed
            remove n from finger table
            return Lookup(my-id, key-id)
    else return my sucessor         // done
</code></pre>

<h3>4. Conclusion</h3>

<p>Chord uses consistent hashing, distributed hash tables, and novel finger tables to provide lookup services for P2P systems. Each node maintains only O(logN) other nodes. The arrivals and departures acquire only O(log<sup>2</sup> N) messages. The successor list can deal with failure effectively. Chord is simple, scalable, and efficient.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cells: a virtual mobile smartphone architecture (SOSP '11)]]></title>
    <link href="http://puncsky.github.com/blog/2012/12/01/cells/"/>
    <updated>2012-12-01T19:52:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/12/01/cells</id>
    <content type="html"><![CDATA[<p><a href="http://systems.cs.columbia.edu/archive/pub/2011/10/cells-a-virtual-mobile-smartphone-architecture/">Columbia University</a>, <a href="http://www.sigops.org/sosp/sosp11/current/2011-Cascais/printable/13-andrus.pdf">papers</a>, <a href="http://www.sigops.org/sosp/sosp11/current/2011-Cascais/13-andrus-slides.pdf">slides</a>, <a href="http://www.youtube.com/watch?v=XBBJ8873vqE">video</a></p>

<h3>1. Problem</h3>

<p>The popularity of smartphones results in the need that a user may purchase several smartphones for different uses. Virtual machine (VM) mechanisms may be the solution, which enables separate and isolated instances of a smartphone software stack to run on the same ARM hardware.</p>

<h3>2. Challenges</h3>

<p>Traditional VMs for desktops and servers can not be applied to smartphones for</p>

<ol>
<li>limited resources can not fully support running an another entire OS</li>
<li>existing design cannot leverage new devices, such as GPS, camera, GPUs, &#8230;</li>
</ol>


<h3>3. Solution</h3>

<p>Key observation: <strong>one app at a time</strong></p>

<!--more-->


<ul>
<li>Cells, a new, lightweight virtualization architecture for enabling multiple virtual phones (VPs) to run simultaneously on the same smartphone hardware with high performance.

<ul>
<li>not entire OS virtualization but multiple isolated virtual phones (VP) on a single OS.</li>
<li>a novel file system layout based on unioning which minimizes memory consumption</li>
</ul>
</li>
<li>Architecture

<ul>
<li>one foreground VP for displaying and multiple background VPs</li>
<li>remap OS resource id to virtual ones and then each VP has its own private virtual namespaces</li>
<li>foreground VP has direct access to hardware. If the foreground VP does not acquire exclusive access, the hardware can be shared by background VPs.

<ul>
<li>Kernel-Level Device Virtualization to support transparency and performance by introducing <em>device namespace</em></li>
<li>User-Level Device Virtualization to support portability and transparency by proxy</li>
</ul>
</li>
</ul>
</li>
<li>Graphics

<ul>
<li>Linux framebuffer (FB) provides an abstraction to a physical display, so a new FB device driver <strong>mux_fb</strong>  is introduced between virtual addresses and physical addresses, providing an identical device interface to all VPs.</li>
<li>The foreground VP uses the GPU directly, but background VPs use GPU render into their respective <em>backing buffers</em>.</li>
</ul>
</li>
<li>Power Management

<ul>
<li><em>early suspend</em> interface: it is blocked by Cells for background VPs</li>
<li><em>fbearlysuspend</em> interface: Cells makes it namespace-aware. Block &amp; unblock.</li>
<li><em>weak locks</em> interface: The same weak lock can be locked and unlocked independently by multiple device namespaces.</li>
</ul>
</li>
<li>Phone calls: combination use of VoIP and cellular network

<ul>
<li>VoIP provides telephone numbers for VPs</li>
<li>Proxy libraries</li>
</ul>
</li>
</ul>


<p>Implementation &amp; evaluation</p>

<ul>
<li>Up to 5 VPs on Nexus 1, Nexus S &#8230;</li>
<li>Modest memory overhead (less than 2%)</li>
<li>Imperceptible switch time among VPs</li>
</ul>


<h3>4. Conclusion</h3>

<ul>
<li>First OS virtualization fully supports smartphone hardware with native performance</li>
<li>One app at a time -> foreground and background usage model</li>
<li>No need of modifications for applications</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[王功权先生给年轻人的四点建议]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/27/wang-gong-quan-jiang-zuo/"/>
    <updated>2012-11-27T16:34:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/27/wang-gong-quan-jiang-zuo</id>
    <content type="html"><![CDATA[<h3>概述</h3>

<p>方才在和朋友们一起去管理学院参加了王功权先生的讲座，期间做了一些笔记，稍作整理记录在此。王功权先生似乎并没有为这次演讲做过多的准备，也不愿意表现地太过正式，毕竟谈人生这种事情，还是需要明月夜短松冈这种微醺的情怀的。实际的情况可能是，他在从哥伦比亚大学过来的路上稍微用iPhone写了个提纲，讲述之前看了几眼，便开始侃侃而谈，当然，情到深处之时，还是让人颇有触动的，不愧为一位诗人。以下的记录纯属个人笔记，有我个人理解的偏差，并不能确保准确地反映王功权先生的观点，也不反映我自己的观点。</p>

<p>他讲述的这四点建议分别是：</p>

<ol>
<li>规划未来不如调整现在</li>
<li>志存高远</li>
<li>选择意味着放弃</li>
<li>在美国就业，在中国创业</li>
</ol>


<p>在其后的问答环节中，他回答同学们提出的两个问题：</p>

<ol>
<li>简要介绍您现在在哥伦比亚大学东亚研究所研究的“公民社会”这一议题？</li>
<li>对经济管理类毕业生就业领域选择有那些建议？</li>
</ol>


<!--more-->


<h3>规划未来不如调整现在</h3>

<p>首先，王功权先生非常谦虚地表示，外界对他们的评价说”有远见卓识“是不正确的，他从未有过非常长远的规划，很多次人生的重大转折都只是出于对现状有着强烈的不满，然后追随心意做出选择。另外，他在讲述的过程中更是反复强调，他认为他的道路不值得模仿。</p>

<p>在大学毕业步入省委机关宣传部四年后，他每天的生活非常平淡：处长和他同处一个办公室，两个人每天躲在报纸背后，偶尔四目相交，处长会和他谈论人生道理什么的，但是当时的他虽然表面上毕恭毕敬地聆听着，实际上只是看着领导的嘴一张一合。他从从处长那里看到自己将来的影子，对现状产生了强烈的恐惧，于是依然决然地辞职了。当时，为了怕自己后悔，他将辞职信一式五份投递到机关上下各部门，不给自己留任何退路。他向同学借了五百块便奔了去海南。后来因缘际会，受过八九牵连被关押、降过职，但无论做什么事情都兢兢业业，升职很快。后来，他不想因为一碗饭而丢失一位朋友，彻底离开体制内。</p>

<p>其后他和朋友白手起家一起创立海南农高投联合开发总公司（万通前身）。因为当时《公司法》还没有出来，直接给银行交纳七千块，便可托银行代理注册“初始资金上千万”的空壳公司。他感觉到不光荣，很尴尬，尽管假借时代的潮流，公司后来的发展一日千里。在与政府官员打交道的过程中，他又一次次地目睹了那些体制内现有的流弊。一开始送一条领带就能办成大事，后来送领带当然是远远不够的不够的。吃饭、搓澡也是必须的，甚至出现同一个饭桌开两场，同一个晚上搓澡三次的情况。因为当年受过关押，他认为即便把钱撕掉也不要给官员，坚守原则，从不行贿。</p>

<p>他再一次不愿意如是这般如履薄冰地生活，便辞职开始到硅谷担任IDG高技术创业投资基金高级合伙人，后来尽管获得了巨大的成功，可是功成名就之后感觉实在太忙，百忙之中抽空积累不少手稿，希望能够整理成书，于是意图退出创投领域。但是，这时候，他发现仅仅是自己投钱还不甘心，希望考量自己是否有募资的能力、是否能够赢得国际市场的信任，便接受恰好鼎晖投资的邀请，负责创办鼎晖创业投资基金，取得了不少成就。</p>

<p>再后来就发生了引起轩然大波的那次私奔事件……一时间遍尝人情冷暖、人世沧桑。最近一年多来，他在哥伦比亚大学东亚研究所研究“公民社会”。</p>

<p>最后他总结道，<strong>他从不在感觉不好的事情上停留，尽管这句话总是说起来容易做起来难</strong>。</p>

<h3>志存高远</h3>

<p>这里的<strong>志存高远并不是说要为国家、人类做多大的贡献，而仅仅是要看得远一点。每个人总会有那些“从前碌碌却因何？到如今，回头试想真无趣！”的体验。看得远一点，未来的自己就不会轻易地为现在短视的选择而后悔。</strong></p>

<p>走在时代车轮的前面有可能被轧死，走在时代车轮的后面有可能被弃死，走在时代车轮的上面有可能被摔死，紧跟时代车轮的旁边最合适。无论如何，只要个人脉搏与时代浪潮共鸣，无论成败，都是弄潮儿。</p>

<p>特别地，他表示为中国如此多的年轻人有志跻身公务员行列感到悲哀，因为在未来，政府精兵简政是时代的必然。</p>

<h3>选择意味着放弃</h3>

<p>选择一件事，就放弃了除这件事之外的所有东西。选择了科研就不要想赚钱，选择了创业就不要想过安稳的日子，选择了安稳就不要想一鸣惊人自己当老板。因为，<strong>打工练就的经验80%是对创业没用的</strong>，打工注重的是卓有成效地完成上级的任务，而“完成任务”是很难帮助回答创业者需要面对的最基本的三个问题的：</p>

<ol>
<li>我干什么？

<ul>
<li>自己决定去做资本正确的事情，而不是简单地完成任务。</li>
</ul>
</li>
<li>钱从哪来？

<ul>
<li>创业本身就是解决钱的问题。没有条件就要创造条件。</li>
</ul>
</li>
<li>谁跟我干？

<ul>
<li>怎么能让他们跟我干？</li>
</ul>
</li>
</ol>


<p>王先生并没有具体指导大家应该怎么做，但是他表示年轻人应该有着年轻人特有的朝气和豪气：<strong>拿青春赌明天，年轻就是资本。拿出五年来赌，五年后的情况不会比现在差。</strong>因为刚毕业，你本来就什么都没有……至于男生的个人问题，他表示<strong>没钱就不爱你的女生咱不要好吗？</strong></p>

<p>最后，他总结道，<strong>即便失败，也要会总结教训，尝试就是赢</strong>。失败，不是让你失去所有，而是让你学到“这样不对”。</p>

<h3>在美国就业在中国创业</h3>

<p>王先生首先强调，这里不是说党国好，只是无法否认的是，中国广袤的市场和机遇是其他土地无法比拟的。中国留学生在美国创业要比在中国困难很多。这里并不是建议大家毕业就回国，实际上，<strong>两到三年美国大机构的工作经验特别重要，teamwork的能力特别重要</strong>。</p>

<p>那么，在什么领域创业呢？<strong>走社会良性的道路，做能够创造真正价值的事业。</strong>人性本善，每个人的内心深处是有真善美的，公道自在人心。无论做什么，自己将来总是能够本能地意识到到现在的自己过去做得对不对。比如他自己就觉得自己私奔一场，羞于开口。</p>

<p>前一阵子有朋友邀请他加盟去重庆铸造中国最高的金融大厦，把重庆打造成金融中心。他反问道：重庆真的需要成为中国最高的金融大厦吗？重庆真的需要成为金融中心吗？中国真的需要一个新的金融中心吗？</p>

<h3>Q&amp;A</h3>

<h4>公民社会？</h4>

<p>中国政治体制转型是社会上下的、党内外的共识，不走邪路、不走老路，怎么走？不知道。山雨欲来风满楼。要改革，两条路：</p>

<ol>
<li>乱摸，总结教训 （摸着石头过河）</li>
<li>借鉴</li>
</ol>


<p>党的选择自然是第一点。虽然不知道怎么走，仍旧有一些共识：</p>

<ul>
<li>要稳定，不应该有暴力型的动乱 （跳出 暴力-轮回）</li>
<li>改革党和国家的领导体制（温总理），这是宪法层面的问题，<strong>宪政民主</strong></li>
<li>不改造政治文化，所以有<strong>公民社会</strong>的议题，维护公民权利，约束政府的权利</li>
<li>不反对党，党内外一致反对的是专制。开放党 禁很难，但可以通过民众推动政府改革</li>
</ul>


<p>公民社会强调社会化管理，强调NGO组织在社会管理中的作用，它既不属于政府，也不属于追求盈利的私人。具体案例非常复杂，王先生没有细讲，但是他很高兴地看到，在广东，NGO已经可以不再强制需要挂靠上级主管部门了。</p>

<h4>年轻人在创业/就业领域选择？</h4>

<p>王先生表示，要慎重进入对权利比较依赖的部门，特权/权力的削弱是大的趋势，大型国企很可能在将来会被解构。年轻人最好依赖市场竞争而不是国家权力，要进入出于蓝海的领域，比如教育、医疗。</p>

<p>至于房地产，房地产行业与城市人口增多是最直接的线性相关的，不管土地财政依赖不依赖，不管政府政策调控不调控。只要有大量的人口涌进城市，城市房地产就会兴旺。</p>

<p>至于私募股权基金，私募股权基金不是主流产品，在中国之所以火爆，是因为媒体抄得火爆。实际上其中的竞争是非常激烈的，对于青年来说是极其危险的。这个行业只适合经验丰富的人。年轻人就牛皮哄哄地做这个行业，天天跟老总打交道，四处找错，这样不好。当然，如果有应届毕业生有志进入这个领域，他也欢迎，因为是金子总会发光 ：D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CryptDB: Protecting Confidentiality with Encrypted Query Processing (SOSP '11)]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/26/cryptdb/"/>
    <updated>2012-11-26T19:45:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/26/cryptdb</id>
    <content type="html"><![CDATA[<p><a href="http://css.csail.mit.edu/cryptdb/">MIT CSAIL</a>, <a href="http://people.csail.mit.edu/nickolai/papers/raluca-cryptdb.pdf">papers</a>, <a href="http://www.sigops.org/sosp/sosp11/current/2011-Cascais/07-popa.pptx">slides</a></p>

<h3>1. Problem</h3>

<p>Provide confidentiality for applications using DBMSes to solve two threats:</p>

<ol>
<li><em>Passive DB server attacks</em>. The curious database administrator (DBA) learns private data.</li>
<li><em>Any attacks on all servers</em>. The adversary gains complete control over application and DBMS servers.</li>
</ol>


<!--more-->


<h3>2. Challenges</h3>

<ol>
<li>Tension between confidentiality and efficiency. (Threat 1 + 2)

<ul>
<li>too slow or not enough confidentiality</li>
<li>incapable of executing SQL queries without giving keys to DBMS servers</li>
</ul>
</li>
<li>Support user-shared data while minimizing data leakage when both application servers and DBMS servers are compromised.

<ul>
<li>“Different keys for different users” alone is not suitable for user-shared data.</li>
</ul>
</li>
</ol>


<h3>3. Solutions</h3>

<p>How to solve Challenge 1 (Threat 1+2) while still retaining data sharing (Challenge 2)?</p>

<p>Architecture Overview</p>

<p><img src="http://puncsky.github.com/images/cryptdb/arch.png" alt="architecture overview" /></p>

<ol>
<li>No plaintext in database at all. (eliminate Threat 1)</li>
<li>Fine-grind keys chained to user passwords. (eliminate Threat 2 and Challenge 2)</li>
</ol>


<h4>3.1 Solution to Threat 1</h4>

<p>How to deal with <em>Passive DB server attacks</em>? No plaintext in database at all.</p>

<h5>3.1.1 Execute SQL queries over encrypted data</h5>

<p>Six types of SQL-aware encryption</p>

<p>SQL-aware encryption strategy with symmetric-key encryption (for efficiency).</p>

<ol>
<li>Random (RND)

<ul>
<li>support indistinguishability under an adaptive chosen-plaintext attack (IND-CPA), same plain texts -> different cipher texts</li>
<li>AES / Blowfish in CBC mode, a random initialization vector (IV)</li>
</ul>
</li>
<li>Deterministic (DET)

<ul>
<li>support equality checks, same plain texts -> same cipher texts</li>
<li>different keys for different columns to prevent cross-column correlations</li>
<li>Pseudo-random permutation (PRP), Blowfish for 64-bit block, AES for 128-bit block</li>
<li>AES in CMC mode (= one round of CBC + another round of CBC in reverse order), zero IV. (to prevent leakage of prefix equality in CBC mode)</li>
</ul>
</li>
<li>Order-preserving (OPE)

<ul>
<li>support order relations. If x &lt; y, then OPEk(x) &lt; OPEk(y) for any secret key K.</li>
<li>Weaker. Thus, OPE-encrypted columns are revealed to the server only when the order query is needed.</li>
<li>Implementation and optimization of <a href="http://www.cc.gatech.edu/~aboldyre/papers/bclo.pdf">Order-preserving symmetric encryption</a>. Use AVL BST for batch encryption. 25 ms/encryption -> 7 ms/encryption</li>
</ul>
</li>
<li>Homomorphic encryption(HOM)

<ul>
<li>retains IND-CPA while allows computations to be conducted on ciphertext and obtain an encrypted result which is the ciphertext of the result of operations performed on the plaintext.</li>
<li>UDF calling Paillier crytosystem</li>
<li>e.g. SUM: HOMk(x)*HOMk(y)=HOMk(x+y)</li>
</ul>
</li>
<li>Join (JOIN and OPE-JOIN)

<ul>
<li>support joins between two columns (because of DET)</li>
<li>TODO</li>
</ul>
</li>
<li>Word search (SEARCH)

<ul>
<li>support LIKE operation</li>
<li>A new implementation of the protocol from <a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=848445">Practical Techniques for Searches on Encrypted Data</a></li>
<li>Proxy

<ol>
<li>split texts to keywords</li>
<li>remove repetitions</li>
<li>randomly permute the positions of the words</li>
<li>encrypt each of the words</li>
<li>paddle each word to the same size</li>
<li>send the encrypted words to the server as a token</li>
</ol>
</li>
<li>Server can only know whether the token matches.</li>
</ul>
</li>
</ol>


<h5>3.1.2 Adjustable query-based encryption</h5>

<p>However, the query set is not always known in advance. So we need to dynamically adjust a layer of SQL-aware encryption scheme for queries at runtime. <strong>Onions of encryption</strong>: different keys for different layers of onions. The proxy will not give all keys to the server at any time.</p>

<p><img src="http://puncsky.github.com/images/cryptdb/onion.png" alt="onion encryption" /></p>

<p><img src="http://puncsky.github.com/images/cryptdb/table1.png" alt="table" /></p>

<ul>
<li>Encrypt data in one or more onions</li>
<li>Multiple onions are needed in practice</li>
<li>Onion decryption (stripe-off) happens only when operations on a column are required</li>
<li>Once a layer of decryption happens, the layer remains its new state</li>
</ul>


<p>keys for each layer are calculated by</p>

<p><img src="http://puncsky.github.com/images/cryptdb/calcKey.png" alt="keys" /></p>

<p><strong>MK is the proxy&#8217;s Master Key and only intended for a single principal (user).</strong></p>

<h6>a) Read query execution</h6>

<ol>
<li>Application server issues a query

<ul>
<li>SELECT ID FROM Employees WHERE Name = ‘Alice’</li>
</ul>
</li>
<li>Proxy server anonymizes the query, and adjust encryption layers if stripe-off is needed

<ul>
<li>UPDATE Table1 SET C2-Eq = DECRYPT RND(KT1,C2,Eq,RND, C2-Eq, C2-IV)</li>
</ul>
</li>
<li>DBMS server execute the adjusted query and return the results

<ul>
<li>SELECT C1-Eq, C1-IV FROM Table1 WHERE C2-Eq = x7..d</li>
</ul>
</li>
<li>Proxy server decrypts the results and sends them to the user</li>
<li>No need to decrypt data in DBMS when a new similar type of query is issued</li>
</ol>


<h6>b) Write query execution</h6>

<ul>
<li>INSERT and UPDATE queries make the proxy encrypts data to the layer that has not yet been stripped off.</li>
<li>Addition and direct comparison should not be allowed simultaneously.

<ul>
<li>If a column is incremented and then only projected, DBMS operates on add onion.</li>
<li>If a column is used in comparisons after increasing, proxy calculates the final value and updates it once and for all.</li>
</ul>
</li>
</ul>


<p>At this time, we can defend against Threat 1 (passive DB server attacks) by not exposing any plaintext to the DBMS server while most SQL queries can still be supported.</p>

<h4>3.2 Solution to Threat 2 and Challenge 2</h4>

<p>How to deal with <em>any attacks on all servers</em> while <strong>still retaining data-sharing</strong> among users? The proxy&#8217;s Master Key (MK) is not adequate for multi-users. The solution is to chain encryption keys to user passwords with the specification of key access policy among users.</p>

<h5>3.2.1 Chain encryption keys to user passwords</h5>

<ul>
<li>What does the key derives from?

<ol>
<li><em>One Single principal</em> uses Global proxy Master Key (MK).</li>
<li><em>Multiple principals</em> chain encryption keys to user passwords.</li>
</ol>
</li>
</ul>


<h6>Define <em>principal</em></h6>

<p>A principal is an entity such as a user or a group, over which it is natural to specify an access policy.</p>

<ul>
<li><em>external principals</em>: real users authenticated with their passwords</li>
<li><em>internal principals</em>: entities whose privileges are acquired through delegations</li>
</ul>


<h6>Annotate the schema with access control policy</h6>

<p>We need to support data-sharing, so the access control policy should be specified to the schema.</p>

<ul>
<li>ENC_FOR(Sensitive-Column1, PrincipalA), A has access to column1.</li>
<li>(principalA typeX) SPEAKS_FOR(principalB typeY), A has access to all keys that b has access to.</li>
</ul>


<p><img src="http://puncsky.github.com/images/cryptdb/accessControl.png" alt="Access Control Policy Annotation" /></p>

<h6>Chain encryption keys</h6>

<ul>
<li>Each principal is associated with a secret and random-generated key

<ul>
<li>symmetric key (online) + public/private key pair (off-line)</li>
<li>External principal&#8217;s random-generated symmetric key and private key is encrypted with user&#8217;s password and stored in <em>external_keys</em></li>
</ul>
</li>
<li>If B speaks for A, A&#8217;s key is encrypted with B&#8217;s key and stored in <em>access_keys</em> table</li>
<li>When a user logs in, the proxy loads all the key the user has access to.</li>
<li>When a user logs out, the proxy delete all the user&#8217;s keys in the memory.</li>
</ul>


<p>At this time, threat 2 is successfully conquered while the data-sharing feature is retained.</p>

<h3>4. Implementation &amp; Evaluation</h3>

<h4>4.1 Implementation</h4>

<ul>
<li>No change to the DBMS and applications</li>
<li>Portable</li>
<li>Multi-user keys: annotations and login/logout</li>
</ul>


<h4>4.2 Evaluation</h4>

<ul>
<li>Support most queries</li>
<li>Exceptional confidentiality

<ul>
<li>Most columns at RND layer</li>
<li>Most columns at OPE analyzed were less sensitive</li>
</ul>
</li>
<li>Throughput loss 26%</li>
</ul>


<h3>5. Conclusion</h3>

<ol>
<li>First practical DBMS to process most SQL queries on encrypted data

<ul>
<li>Hide DB from DBA, outsource DB</li>
</ul>
</li>
<li>Protects data of users logged out during attack, even when all servers are compromised

<ul>
<li>Limit leakage from compromised applications</li>
</ul>
</li>
<li>Modest overhead: 26% throughput loss for TPC-C</li>
<li>No changes to DBMS (e.g., Postgres, MySQL)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何阅读一篇论文？]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/21/ru-he-yue-du-%5B%3F%5D-pian-lun-wen-%3F/"/>
    <updated>2012-11-21T16:15:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/21/ru-he-yue-du-[?]-pian-lun-wen-?</id>
    <content type="html"><![CDATA[<p>阅读是人生的终极命题之一。人生苦短，我们需要阅读来继承前人的衣钵，我们需要笔记来对抗过往的遗忘，我们需要写作来连接自我和人世沧桑。</p>

<p>那么，<a href="http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf">如何最高效地阅读一篇论文呢？</a></p>

<p>如同任何一个学习过程，读论文的周期显然是螺旋向上的，可以划分为简单的三板斧：</p>

<!--more-->


<h3>1. 略读</h3>

<p>五到十分钟的快速略读：</p>

<ol>
<li>题目，摘要，介绍</li>
<li>各部分的标题</li>
<li>如果有数学式子，大致了解有什么样的理论基础</li>
<li>结论</li>
<li>标出引用中度过的文献</li>
</ol>


<p>此时回答下列五个C：</p>

<ol>
<li>类别Category: A measurement paper? An analysis of an existing system? A description of a research prototype?</li>
<li>背景Context: Related papers? Theoretical bases?</li>
<li>正确？Correctness: Valid assumptions?</li>
<li>贡献Contributions.</li>
<li>清楚？Clarify. Well-written?</li>
</ol>


<p>此时，可以据此进一步决定该文章是否值得打印出来细看。相应的，自己写论文的时候如果给这些部分写得不出彩，也就不会被人关注到。</p>

<h3>2. 选读</h3>

<p>一个小时的选读，就像GRE阅读那样，只读关键的主干，不要读细节，比如证据、例子什么的。批注关键点、评论、或者自己不懂的地方。细读图表，标注相关阅读文献。</p>

<p>如果此时还是不懂这篇论文在说什么，有三种选择：</p>

<ol>
<li>算了，这篇文章对我将来没帮助</li>
<li>认了，大侠过两天重新读过，不过是充点背景知识先</li>
<li>拼了，进入第三阶段</li>
</ol>


<h3>3. 重现</h3>

<p>四到五小时的重现：自己基于作者的假设会怎么解决这个问题？将自己的解决过程和作者的过程一一比较，就能够发现两者各自的优缺点。</p>

<h3>后话</h3>

<p>这三个步骤并不一定是连在一起的，通常的情况是，拿着一堆论文先走第一步，几个星期后走第二部，再几个星期或者几个月后走第三步。当然，如果是赶进度的话，就甭想这么闲了 :P</p>

<p>总而言之，想要一口吃掉一篇论文似乎是很难的事情，我们需要反复咀嚼，这也是为什么我要写不完整的阅读笔记的原因。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HadoopDB: an architectural hybrid of MapReduce and DBMS technologies for analytical workloads (VLDB '09)]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/20/hadoopdb-an-architectural-hybrid-of-mapreduce-and-dbms-technologies-for-analytical-workloads-vldb-09/"/>
    <updated>2012-11-20T16:20:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/20/hadoopdb-an-architectural-hybrid-of-mapreduce-and-dbms-technologies-for-analytical-workloads-vldb-09</id>
    <content type="html"><![CDATA[<p><a href="http://db.cs.yale.edu/hadoopdb/">Yale DB</a></p>

<h3>1. Problem</h3>

<p>Large analytical data management (OLAP) with commodity clusters</p>

<h3>2. Challenges</h3>

<ul>
<li>Performance and efficiency

<ul>
<li>hadoop

<ul>
<li>is not for structured data analysis</li>
<li>scale well</li>
<li>open source, without cost</li>
</ul>
</li>
</ul>
</li>
<li>scalability, fault-tolerance, and flexibility

<ul>
<li>Previous parallel db fit into tens of nodes, not thousand of nodes.</li>
<li>not scale well for failures, heterogeneous machines, performance untested</li>
</ul>
</li>
</ul>


<h3>3. Solutions</h3>

<ul>
<li>MapReduce (Hadoop) + parallel db (or single-node DBs) = HadoopDB<!--more-->

<ul>
<li>Translation layer: Hive</li>
<li>Communication layer: Hadoop</li>
<li>Database layer: PostgreSQL (or MySQL, &#8230; JDBC)</li>
</ul>
</li>
<li><p>Components</p>

<ol>
<li>Database Connector

<ul>
<li>Interface among dbs on nodes</li>
<li>extends InputFormat class -> InputFormat Implementation lib</li>
<li>JDBC-complaint</li>
</ul>
</li>
<li>Catalog

<ul>
<li>metainformation as XML = connection para + metadata</li>
</ul>
</li>
<li>Data Loader

<ul>
<li>Global Hasher: MR, repartition raw data from HDFS to NO. of nodes</li>
<li>Local Hasher: copy from HDFS, repartition the partition into chunks</li>
<li>Better load balance than Hadoop</li>
</ul>
</li>
<li>SQL - MR - SQL (SMS) Planner

<ul>
<li>extend Hive for</li>
<li>open and low cost</li>
<li>each table stored separately in HDFS, low performance in multi-table trans.
intercept normal Hive flow in</li>
<li>update MetaStore before query execution</li>
<li>between query plan generation and MR jobs
retrieve fields, determine partition keys</li>
</ul>


<p>   traverse DAG bottom-up</p>

<p> only support filter, select, aggregation</p></li>
</ol>
</li>
<li><p>Extend performance [23] with fault tolerance and heterogeneous node exp</p>

<p>  TODO: modify the current task scheduler, connect not straggler node but the replicas.</p>

<p>  Exp on EC2, Hadoop, HadoopDB, Vertica, DBMS-X</p></li>
</ul>


<h3>4. Conclusion</h3>

<ul>
<li>HadoopDB&#8217;s performance &lt; parallel db for

<ul>
<li>PostgreSQL (not column-store, not compression)</li>
<li>Hadoop and Hive are young</li>
</ul>
</li>
<li>performance, heterogeneous environ., fault tolerance, flexibility</li>
</ul>


<h3>Related Readings</h3>

<p>[23] A Comparison of Approaches to Large Scale Data Analysis</p>

<p>[6] Scope [11] Hive [24] C-store [4] What is the right way to measure scale?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reliable Client Accounting for P2P-Infrastructure Hybrids (NSDI '12)]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/20/reliable-client-accounting-for-p2p-infrastructure-hybrids-nsdi-12/"/>
    <updated>2012-11-20T16:16:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/20/reliable-client-accounting-for-p2p-infrastructure-hybrids-nsdi-12</id>
    <content type="html"><![CDATA[<p><a href="http://www.mpi-sws.org/~paditya/">MPI-SWS</a>, UPenn, Duke, Akamai, <a href="http://www.mpi-sws.org/~paditya/papers/rca-nsdi2012.pdf">paper</a>, <a href="https://www.usenix.org/sites/default/files/conference/protected-files/nsdi12_reliable_client_accounting_for_p2p-infrastructure_hybrids.pdf">slides</a>, <a href="https://www.usenix.org/conference/nsdi12/reliable-client-accounting-hybrid-content-distribution-networks">video</a></p>

<h2>1. Problems</h2>

<p>Hybrid (Servers with assisting peers) designs in CDNs -> malicious clients can cause significant accounting inaccuracies.</p>

<h2>2. Challenges</h2>

<p>Infrastructure can not control P2P communications by malicious clients (peers). Even if infrastructure provides signed metadata and fallback (so content can not be mishandled by peers), there are still:</p>

<ul>
<li>Affect service quality</li>
<li>Misreport P2P transfers</li>
</ul>


<p>For example, inflation attack occurred for a fake download report.</p>

<h2>3. Solutions</h2>

<p>Reliable Client Accounting (RCA)</p>

<!--more-->


<p>Clients keep logs of network activity and upload them to the infrastructure periodically. The infrastructure collects logs, verifies them, and isolate suspicious nodes.</p>

<h3>1. Record client activities reliably</h3>

<p>Tamper evident logging: log recording sending/receiving history forms hash chains. Every massages contains a signature (authenticator) from its sender (O(# of messages)). -> Later, RCA only records authenticators for clients (O(# of pairs)).</p>

<h3>2. Identify misbehaving/suspicious clients</h3>

<p>By accounting the logs, infrastructure can find clients unilaterally claim fake downloads.</p>

<p>As to malicious client software:</p>

<p>What if bad clients do not follow the above steps (e.g. do not keep logs and serve bad content)? Simplify NetSession protocol to a state machine. Rules are manually set to identify bad logs not following the them.</p>

<p>What if many clients collude to cheat? It is difficult in practice (infrastructure assigns peers), but can still be found by statistical checks.</p>

<p>As to malicious users:</p>

<p>What if a user repeatedly downloading content to drive up demand? (can be amplified by Sybil attack) Statistical checks, too.</p>

<h3>3. Handle misbehavior without affecting service quality</h3>

<p>Blacklist and quarantine bad clients.</p>

<h2>4. Conclusions</h2>

<p>Since infrastructure cannot observe P2P communication, accounting is vulnerable to malicious clients (peers) in a hybrid design of CDN, e.g. inflation attacks. So the authors advance RCA to 1) keep tamper-evident logs and set rules for fixed state machines 2) perform statistical analysis on collected logs. Malicious clients can be detected and isolated effectively by RCA. The evaluation with real world Akamai NetSession shows that overhead is reasonable &lt;= 0.5%.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Towards Statistical Queries over Distributed Private User Data (NSDI '12)]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/20/towards-statistical-queries-over-distributed-private-user-data-nsdi-12/"/>
    <updated>2012-11-20T16:13:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/20/towards-statistical-queries-over-distributed-private-user-data-nsdi-12</id>
    <content type="html"><![CDATA[<p>From <a href="https://sites.google.com/site/ruichuanc/">MPI-SWS, Germany</a>, <a href="https://73aab115-a-62cb3a1a-s-sites.googlegroups.com/site/ruichuanc/pddp-nsdi12.pdf?attachauth=ANoY7cqTHmW8qn2UrCjxk0u-eafRsp77w2XtpG9QdnY9nOnDKkELrYiH-RrOI2ILFnQUv6gt-oz_ek1DA8q7TptjvCEWWWpT02huRCgNYXW-bUNQwjJjM0DLN7tiJzOKD509vt1JhOZ_fHQ_rijDX5Dhh3Bx1pdZotJp7mDbCw0yrcSTYEfbXAuzkZK2zDxfRKYzZXww-dESgY9wquSilSiX3ZrPYrATOg%3D%3D&amp;attredirects=0">paper</a> and <a href="https://www.usenix.org/sites/default/files/conference/protected-files/pddp-talk-nsdi12.pdf">slides</a></p>

<h2>1. Problem</h2>

<p>To protect user privacy in distributed systems from leaking by statistical queries.</p>

<h2>2. Challenges</h2>

<p>The most direct solutions are</p>

<ol>
<li><p>to <strong>anonymize + add noise</strong> to <em>user data</em>.</p>

<p> [-] utility, de-anonymize</p></li>
<li><p>differential privacy. add noise to <em>answer of queries</em>.</p>

<p> [-] scale, churn tolerance, malicious client</p></li>
</ol>


<h2>3. Solution </h2>

<p>PDDP: Practical Distributed Differential Privacy.</p>

<!--more-->


<ul>
<li>Binary answer in bucket. The query result should not be distorted by the client arbitrarily.</li>
<li>Blind noise addition. The Malicious should not be trusted. Private data are controlled by its user only.</li>
</ul>


<h3>3.1 Assumption</h3>

<p>Clients and analysts are potentially malicious. Proxy is HbC (honest but curious) and should not have access to noise-free result.</p>

<h3>3.2 Work Flow</h3>

<ol>
<li><p>Query Initialization(Analyst -> Proxy)</p></li>
<li><p>Query Forwarding (Proxy -> Client)</p></li>
<li><p>Client Respond (Client -> Proxy)</p>

<p>answers are encrypted with the analyst&#8217;s public key.</p></li>
<li><p>Differential Private Noise Addition.</p>

<p>collaborative coin generation with a GM cryptosystem. Unbiased proxy flip encrypted coins from clients randomly and thus transform them into unbiased ones. Coins serve as DP noises.</p></li>
<li><p>Noisy Answers to Analyst ( Proxy -> Analyst)</p></li>
</ol>


<h3>3.3 Implementation and Deployment</h3>

<p>600+ Client = Firefox add-on + SQLite</p>

<p>Proxy = Tomcat web service + MySQL</p>

<p>Analyst = Java program</p>

<h1>4. Conclusion</h1>

<p>The authors achieve scalable, churn-tolerant user privacy against malicious analyst and clients by</p>

<ol>
<li>making a trade off between utility and privacy. (differential privacy)</li>
<li>introduce distributed system to traditionally centralized differential privacy environment. (distributed)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Three Papers Review about Deterministic Parallelism]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/20/three-papers-review-about-deterministic-parallelism/"/>
    <updated>2012-11-20T16:10:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/20/three-papers-review-about-deterministic-parallelism</id>
    <content type="html"><![CDATA[<p><a href="http://dedis.cs.yale.edu/2010/det/">Yale Dedis</a></p>

<h3>1. Efficient System-Enforced Deterministic Parallelism (OSDI’10)</h3>

<p>Parallelism introduces 1) non-determinism and 2) data races (heisenbugs). Determinism means that a given input always produces the same output. In other words, input alone determines the output, regardless of extrinsic events such as the OS’s thread scheduling.</p>

<p>To achieve determinism,<!--more--> Determinator, an OS offering a programming model that is naturally and pervasively deterministic, is introduced. Its private workspace model solves data races in the first place, and the model is deterministic at all levels of abstraction. Like a version control system, this model gives a thread a private replica of all the state and the thread operate within its private state but could not interact directly with other threads until reconcile. At this time, write-write races become conflicts and determinator would throw an exception when main thread joins them.</p>

<p>In terms of implementation, determinator takes an arbitrarily deep hierarchy of spaces, consisting of CPU register state and private virtual memory. The space is like a single-threaded process but different from the concepts of process and thread. Interaction is allowed only for the space’s parent and child spaces via put, get and return three system calls. It could be applied to multiprocessor/multicore system and also multiple nodes in a homogeneous cluster. In high level abstractions, it emulates traditional fork/exec/wait APIs, and shared state abstractions with no physical state sharing, which involves Distributed Shared Memory techniques. Its runtime maintains a complete file system replica in the address space of each process, with the copy-on-write mechanism. The runtime treats I/O as a special case of file system synchronization for the reason of space hierarchy.</p>

<p>Determinator is written in C with small assembly fragments. PIOS is a subset of it, and the former is partly derived from MIT’s JOS.</p>

<p>Since determinator is a primitive proof-of-concepts prototype, it inevitably has some limitations:</p>

<ol>
<li>A restrictive space hierarchy -> a performance bottleneck for I/O-bound applications     AND no support for non-hierarchical synchronization, queue, future</li>
<li>Limited address space -> limited file system size</li>
<li>No focus on file system -> no persistent storage</li>
<li>Inefficient cross-node communication: no prefetching or other optimization, Eternet only.</li>
</ol>


<h3>2. Workspace Consistency: A Programming Model for Shared Memory Parallelism (WoDet ‘11)</h3>

<p>To address the 1st limitation, Workspace Consistency: A Programming Model for Shared Memory Parallelism extends WC from OSDI’10 version of hierarchical structure to a more generalized non-hierarchical structure. It supports non-hierarchical synchronization patterns (dynamic producer/consumer graphs and inter-thread queues), besides hierarchical synchronization patterns such as fork/join and barrier. WC highlights matched release/acquire pairs, adding three constrains to Release Consistency (RC):</p>

<ol>
<li>Release/acquire pair is unique.</li>
<li>One thread’s writes is not visible to another thread’s read until sync.</li>
<li>Data races are handled by throwing a runtime exception or other deterministic ways.</li>
</ol>


<p>Two prototypes: one on Linux, one on Determinator, both supporting only hierarchical synchronization patterns.</p>

<p>This generalized WC extends Determinator’s virtual memory system to support a Single Producer Multiple Consumer (SPMC) shared memory primitive – SPMC channels. The implementation adds 2 optional arguments to existing Put/Get system calls. Determinator maps the virtual memory ranges of the producer and all consumers to the same physical memory. Consumer would be blocked until the producer fixes the page.It is suitable for applications demanding pipeline parallelism or &#8220;all-to-all&#8221; communication.</p>

<p>Full WC model atop SPMC extension is not yet implemented.</p>

<h3>3. Deterministic OpenMP for Race-Free Parallelism (HotPar ‘11)</h3>

<p>DOMP is a variant of OMP based on the WC model. It keeps parallel, loop, sections, barrier, excludes atomic, critical, flush, generalizes reduction as reduction (function : list), and extends the sections with pipeline clause.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quincy: Fair Scheduling for Distributed Computing Clusters (SOSP '09)]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/20/quincy-fair-scheduling-for-distributed-computing-clusters-sosp-09/"/>
    <updated>2012-11-20T16:08:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/20/quincy-fair-scheduling-for-distributed-computing-clusters-sosp-09</id>
    <content type="html"><![CDATA[<p><a href="http://research.microsoft.com/en-us/people/misard/">Microsoft</a>, <a href="http://www.sigops.org/sosp/sosp09/papers/isard-sosp09.pdf">paper</a>, <a href="http://www.sigops.org/sosp/sosp09/videos/19_michael_isard.mov">video</a>, <a href="http://www.sigops.org/sosp/sosp09/slides/quincy/QuincyTestPage.html">slides</a></p>

<h2>1. Problem</h2>

<p>How to achieve fair scheduling? In other words, a guy who gets up early and performs huge tasks on a cluster should not always monopolize most computing resource, and someone else&#8217;s assignments should not be ignored. Otherwise, it is unfair for all the cluster users.</p>

<p><strong>Fair sharing</strong> of the cluster resources</p>

<p>Job x takes <em>t</em> seconds, when running exclusively on the cluster. When the cluster has <em>J</em> jobs, x should take &lt;= <em>Jt</em> seconds.</p>

<p><em>N</em> computers and <em>J</em> jobs: each job gets at least N/J computers.</p>

<h2>2. Challenges</h2>

<p>Traditionally,</p>

<!--more-->


<p>MPI Model, tasks are in a pipeline and then assigned to a part of cluster.</p>

<ul>
<li>If one node is down, all the processes should be killed and the user have to start at a new checkpoint.</li>
<li>Coarse grain allocation. Allocation is static.</li>
<li>Off cluster data strage, e.g. SAN</li>
</ul>


<p>Dryad MapReduce Model</p>

<ul>
<li>No communication between slaves.</li>
<li>No fine grain sharing for resource competence. Many Idle nodes.</li>
</ul>


<p><strong>Fine-grain sharing model</strong></p>

<ul>
<li>Multiplex all computers in cluster between jobs.</li>
<li>When a task completes, computer may be assigned to another job.</li>
<li>Jobs uses <em>N/J</em> computers at a time but set in use varies over lifetime.</li>
</ul>


<h2>3. Solution</h2>

<p>The solution is intended for data-intensive computing with locality. There is no SAN. However, data locality conflicts with fairness. So they present Quincy: a new, graph-based framework for cluster scheduling under a fine grain cluster resource-sharing model with locality constrains. 2 basic ideas:</p>

<ol>
<li>sub-optimal assignment of a job&#8217;s tasks.</li>
<li>kill running tasks to free resources</li>
</ol>


<h3>3.1 Queue-based Scheduling</h3>

<p>Architecture: A core switch (CS) manages rack switches (RC). A rack switch (RC) manages computers (C). For example, C1, C2 and C3 in a rack have their own queues, and share a same rack queue. R1 R2 managed by the same core switch have their own queues above, and share a same core queue. Every time a task X is finished, X will be deleted from all the queues, no matter what hierarchy it is in.</p>

<p>So how to get fairness?</p>

<h3>3.2 Flow-based Scheduling</h3>

<p>Simplify a scheduling problem to a matching problem.</p>

<ul>
<li>each task is either scheduled or unscheduled.</li>
<li>can assign a cost to any matching</li>
<li>fairness constrains number of tasks that are scheduled</li>
</ul>


<p>How to minimize matching cost while still maintaining fairness?</p>

<p>Min-cost network flow.</p>

<p>There are U (unscheduled nodes), X (cluster aggregator nodes), R (rack aggregator nodes), C (computing nodes). In addition to queue-based scheduling, the edges connecting tasks to these nodes have weights showing the cost of the matching. The capacities on the outgoing edge of job <em>j</em>&#8217;s unscheduled node <em>Uj</em> control the number of running tasks that the job will be allocated.</p>

<h2>4. Conclusion</h2>

<p>The authors advance a new fair schedule modeling for Dryad/MapReduce/Hadoop by min-cost network flow, achieving much better performance and effectiveness than traditional ways.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[春天在哪里呀春天在哪里？]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/17/chun-tian-zai-na-li-ya-chun-tian-zai-na-li-%3F/"/>
    <updated>2012-11-17T15:51:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/17/chun-tian-zai-na-li-ya-chun-tian-zai-na-li-?</id>
    <content type="html"><![CDATA[<h3>一 大叔</h3>

<p>第一次见到阿米(Amittai F. Aviram)大叔就被彻底震撼到了，你简直就无法相信眼前这位爷爷辈的大叔居然是计算机系的博士！OSDI&#8217;10（计算机系统界顶级会议）最佳论文的第一作者！要知道，人人生而平等，会议生而不等，同是顶级会议，论文被OSDI录用就比VLDB、WWW、NSDI等等这些难得不是一点两点；而且系统领域的论文不是推个数学公式，做个小实验验证一下就可以过关，而是需要老老实实动手实现整个复杂的设计的。而这位谈吐之间无时无刻不环绕着功成身退气息的大叔，此刻正在向比他小个几十岁的教授们作毕业答辩！机缘巧合的是，不久之后，当我想看看如何实现一个简单的数据库的时候，满心欢喜地查到一个B+树的C语言实现，左上角竟然也是赫然打着阿米大叔的大名！</p>

<p>大叔啊，您都一大把年纪了，上能发好论文，下能写好代码，让我们这群自诩码农的后生们情何以堪？元芳，你怎么看？此事必有蹊跷！于是怀着复杂的心情，我点开了大叔的履历。其实，大叔在三十年前就已经成为了南卡大学(University of South Carolina)的英语文学教授，酷爱写诗，是拿到了终身教职的。后来，不知为何对计算机产生了浓厚的兴趣，04年去哥大读计算机专业的本科，后来一发不可收拾，经过八年的锤炼，几个月前在耶鲁博士毕业。现在在MathWorks任高级软件工程师……</p>

<!--more-->


<h3>二 狂奔</h3>

<p>我在这一年多以来一直没有把一件事情做好的快感，内心里念想太大，脑子里干货太少，拼命狂奔，累到趴下，然后再狂奔。我觉得很可能很多人会像我一样，对新的人生阶段有这种后知后觉的不适应。大四之后也没有“课程”这种规定“几点到几点必须在什么地方和那些人一起干什么事情”的固定的安排，身边也没有人管你是死是活，于是作息变得不规律起来：你可以心血来潮时持续工作到凌晨五六点，也可以一觉睡到下午两三点；你可以早上五点起床，一天吃六餐，跑很多步，读很多书，见很多人，你也可以26小时不起床，一整天不吃东西……</p>

<p>楠哥曾经表示过，身为一位计算机科学专业的博士，早就历练出了可以在一天之中任意时间任意睡着和醒着的本能。这位敬职的助教在学术上不辞劳苦日夜兼程，经常的情况是，我凌晨一两点给他发邮件，他凌晨三四点给我回复，甚至有一次我下午去他办公室，他不在，另一位博士说，他回去睡觉了……教授和博士后们似乎就更是这样了。我不止一次在凌晨4点左右收到不同教授发来的邮件。</p>

<p>同时，各色论坛、微博、人人上，同学们都似乎很享受“最近很辛苦，每天凌晨几点睡”这样的言论！各种主流媒体也似乎非常欣赏“每天只睡三四个小时”这种埋头苦干拼命硬干日夜不辍的革命情怀……</p>

<p>饶了我吧，对我来说，这不科学。我要把不规律的生活规律列为我这辈子最大的敌人。</p>

<h3>三 趣味</h3>

<p>另一件没有快感的事情是贫乏的趣味。本来我们这群神经病(Geek)就是拉低整条街趣味性平均水平的罪魁祸首，更何况背井离乡只身在外？现在愈发地赞同，所谓向往向往，心之所向的是过往的美好：最美妙的早餐当然是湖北的热干面，最温馨的香味当然是妈妈用的百雀羚，最得意的事情当然是小学的时候就想研习的码术，潜伏在深深的黑夜里欲罢不能的欲望当然还是那火锅、卤味、穆斯林的烤串、渔村的烤鱼、桃李二的麻辣烫……最最让我不敢相信的是，我居然还梦到了国关食堂打的饭菜！这梦也太没有节操了。</p>

<p>突然之间，对我而言，黑樱桃汽水不是饮料，而是塑料，楼下无小黑，商店无零食，晚睡无宵夜，早起无早餐，举目无亲人，校园无美女。哦？对不起，我真心不好异国风情这一口！</p>

<p>我问同学海神，你看人家“还能害得你好(Helen Hadley Hall 研究生公寓的谐音，大部分中国研究生都居住于此)”又成全了一对鸳鸯，少年你作为我们大HGS(Hall of Graduate Studies研究生宿舍)的杰出华人代表，还不赶紧加了个油？为我们HGS华人同胞们争光？</p>

<p>海神淡定地表示，工作都没找到，哪来时间考虑这些？</p>

<p>哪来时间考虑这些？</p>

<p>我被戳到了痛处。突然之间，“有所成就”和”有趣”突然在我心目中成为了一对矛盾的存在。一方面，我的心目中浮现这样一个画面：</p>

<blockquote><p>弟子毕恭毕敬地问大师：请问将此绝技修炼到炉火纯青需要多少时日？</p>

<p>大师：七年</p>

<p>弟子一惊：若每日勤加修炼，不分昼夜，不问世事，需要多久？</p>

<p>大师：十年</p></blockquote>

<p>程代展教授数日前发表博客称“<a href="http://blog.sciencenet.cn/blog-660333-632151.html">昨夜无眠</a>”，因为一位在他看来在学术上前程极其远大的学生，突然不再跟他继续科研，转而去做中学老师，而且居然还已经考过了会计师。这篇博客在网上掀起了讨论的狂潮，有一种观点认为，程教授是一位好的伯乐，可是伯乐骑到了千里马上，把千里马压得太紧了，以至于科研的过程太苦、太累、太没有意思。</p>

<p>可是另一方面，在一个社会分工高度细化的时代，没有长时间、高强度的训练是无法<a href="http://www.geekonomics10000.com/519">练习一万小时成就天才</a>的。</p>

<p>我要有趣地刻苦，哪怕慢一点，也不要刻苦到无趣。无论是谁在哪里生活，他的生活都有着自己的节奏，就像跑步的时候，每个运动员都有自己的步调，人生很长，毕竟有限，太快终会慢下、太慢不可致远。我们要做的是在合适的时机跑合适的速度，找到自己生命的节拍，只有跑得合拍，才能跑得长久，跑得悠远。</p>

<h3>四 春天在哪里？</h3>

<p>小乘佛法里认为，我执（无明, ignorance）是一切痛苦的根源。但我也很同意无知即是力量(ignorance is power)，这种认知既来源于阿甘正传里面的那种执着，也来自“宁肯大陆不长草，也要收复什么岛”的那种执着。</p>

<p>我不知对错。</p>

<p>孔子可以不饮盗泉之水，盗跖也可以骂孔丘“矫言伪行，以迷惑天下之主，而欲求富贵焉。盗莫大于子，天下何故不谓子为盗丘，而乃谓我为盗跖？”</p>

<p>我不知对错。</p>

<blockquote><p>大流士王召集了一批希腊人到宫廷上，问他们，什么代价可以使他们愿意去吃自己父亲的遗体；希腊人说，不可能，没有任何代价能让他们去做出如此可怕的勾当。同时，殿前有一批印度人，这个部落的印度人是以吃父辈遗体为风俗的。大流士问他们，什么代价可以使他们愿意将父亲的遗体火化（希腊人火化遗体）。印度人大惊失色：不可能，没有任何代价能让他们去做出如此可怕的勾当，想都别想。”希罗多德的评语：“这个世界就是这么回事。”</p></blockquote>

<p>我不知对错。</p>

<p>或者说，世上本无对错，只有选择，大多数人选择正确的，就是对，大多数人选择错误的，就是错。可是，如果真理是不言自明的，那还需要著书立说这种多余的行为干什么呢？</p>

<p>既然都没有了对错，那一切似乎都可以随意，在这随意的、未知的世界，未来在哪里呢？</p>

<blockquote><p>春天在哪里呀春天在哪里？</p>

<p>春天在那青翠的山林里</p>

<p>春天在那小朋友的眼睛里</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HomeOS: An Operating System for the Home (NSDI '12)]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/16/homeos-an-operating-system-for-the-home-nsdi-12/"/>
    <updated>2012-11-16T22:06:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/16/homeos-an-operating-system-for-the-home-nsdi-12</id>
    <content type="html"><![CDATA[<p><a href="http://researcher.watson.ibm.com/researcher/view.php?person=us-ckd">IBM</a>, <a href="http://research.microsoft.com/en-us/projects/homeos/">MS</a>, <a href="https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final149.pdf">paper</a>,  <a href="https://www.usenix.org/conference/nsdi12/towards-commodity-smarthomes-homeos">Video</a>, <a href="https://www.usenix.org/sites/default/files/conference/protected-files/homeos-nsdi-talk-given-clean.pdf">Slides</a></p>

<h3>1. Problem</h3>

<p>High overhead of managing and extending network devices for <strong>smart home</strong>: 1) growing number of devices 2) heterogeneity 3) hardware/software incompatible.</p>

<h3>2. Challenges</h3>

<ul>
<li>Appliance abstraction: a closed, monolithic system. (manageability)</li>
<li>Decentralized network-of-devices: bad portability. (extensibility: both software and hardware)</li>
</ul>


<!--more-->


<h3>3. Solution</h3>

<p>HomeOS: a PC-like abstraction for network devices</p>

<h4>3.1 Overview</h4>

<table>
    <tr>
        <td>Application layer</td><td>Tasks</td>
    </tr>
    <tr>
        <td>Management layer</td><td>Control</td>
    </tr>
    <tr>
        <td>Device functionality layer (DFL)</td><td>Device</td>
    </tr>
    <tr>
        <td>Device connectivity layer (DCL)</td><td>Topological</td>
    </tr>
    <tr>
        <td>PCs, XBox, Smartphones, TVs, &#8230;</td><td>Heterogeneity source handled</td>
    </tr>
</table>


<h4>3.2 Application Layer</h4>

<p>Environment for develop-written codes. An application should have a manifest {rules} to specify what devices it needs.</p>

<h4>3.3 Management Layer</h4>

<ol>
<li><p>Application manager with access control</p>

<ul>
<li>Time-based access control.</li>
<li>Applications as security principals</li>
<li>Settings should be querable</li>
<li>Sensitive devices need extra attention</li>
</ul>
</li>
<li><p>Mediate conflicting accesses</p>

<ul>
<li>Datalog access control rules: (r, g, m, Ts, Te, d, pri, a): Resource r can be accessed by users in group g, using module m, in the time window from Ts to Te, on day of the week d, with priority pri and access mode a.</li>
<li>Simplicity. User account works within a given time. Groups are in a tree hierarchy.</li>
</ul>
</li>
</ol>


<h4>3.4 Device Functionality Layer</h4>

<p>Provide APIs for higher layers by using handles.</p>

<p>Service interfaces = roles{operations()} (&#8220;lightswitch&#8221; role = turnOn()+turnOff())</p>

<ul>
<li>A new device can either use an existing role or register new roles</li>
<li>OS is agnostic to the services</li>
</ul>


<h4>3.5 Device Connectivity Layer</h4>

<p>Provide handles for higher layers.</p>

<ul>
<li>No understanding of device semantics</li>
<li>A uniform interaction with different kinds of devices</li>
</ul>


<h4>3.6 Implementation and Evaluation</h4>

<p>C#</p>

<p>Developer: &#8220;music follows the lights&#8221;/&#8221;custom lights per user&#8221;. 8/10 of them finished in 2h</p>

<p>User: 77% completion rate</p>

<h3>4. Conclusion</h3>

<p>Bad abstractions in &#8220;smart home&#8221; result in high overhead of managing and extending network devices, which are in increasing number and mostly not compatible with each other. Traditionally, appliance abstraction provides a huge system with no potential for customization and extension. Meanwhile, decentralized network-of-devices provide little portability. So the authors present a new abstraction &#8211; HomeOS, a PC-like abstraction for network devices. The new abstraction architecture consists of four layers. Lower layers interact with heterogenous devices and protocols. Upper layers simplify development and use of applications. HomeOS is implemented with C# and its experience shows a satisfying manageability and extensibility.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast and Parallel Webpage Layout (WWW '10)]]></title>
    <link href="http://puncsky.github.com/blog/2012/11/16/fast-and-parallel-webpage-layout-www-10/"/>
    <updated>2012-11-16T15:56:00-05:00</updated>
    <id>http://puncsky.github.com/blog/2012/11/16/fast-and-parallel-webpage-layout-www-10</id>
    <content type="html"><![CDATA[<iframe src="http://www.slideshare.net/slideshow/embed_code/15270792" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe>


<p></p>

<p><a href="http://www.eecs.berkeley.edu/~lmeyerov/">UCB</a>, <a href="http://www.eecs.berkeley.edu/~lmeyerov/projects/pbrowser/pubfiles/playout.pdf">paper</a></p>

<h2>1. Problem</h2>

<p>The browsing of webpages is slow on smartphones for their limited CPU computational resources. The <em>power wall</em> forces hardware architects to apply increases in transistor counts towards improving parallel performance, not sequential performance. So the authors introduce the <strong>parallel</strong> mobile browser.</p>

<h2>2. Challenges</h2>

<!--more-->


<p>In the analysis,  three core limitations of the rendering speed are:</p>

<ol>
<li>CSS selector matching</li>
<li>Box and text layout</li>
<li>Glyph rendering</li>
</ol>


<h2>3. Solution</h2>

<p>Overall Input and Output</p>

<ul>
<li>Input: an HTML tree of content, CSS style rules, font files.</li>
<li>Output: absolute element positions.</li>
</ul>


<h3>3.1 Algo1: CSS Selector Matching</h3>

<p><em>Rule matcher</em> associates CSS rule set with HTML node tree.</p>

<p>Two assumptions:</p>

<ol>
<li>In general, selector language is an exact subset of regular expression.</li>
<li>Disjunctions are split into separate selectors</li>
</ol>


<p>Algorithm paraphrase:</p>

<ol>
<li>sequentially read rules and correspondingly build hash maps</li>
<li>parallelly <strong>map</strong> nodes to different kinds of rules</li>
<li>parallelly <strong>reduce</strong> several rules to each node</li>
</ol>


<p>Optimizations from WebKit:</p>

<ol>
<li>Hashtables. [×] check CSS for every node [√] read once, build hashmap, and check hash</li>
<li>Right-to-left matching.</li>
</ol>


<p>New Optimization:</p>

<ol>
<li>Redundant selector elimination.</li>
<li>Hash Tiling. partition the hashtable. reduce cache misses.</li>
<li>Tokenization. store attributes as int instead of string to save cache.</li>
<li>Parallel document traversal.</li>
<li>Random load balancing. If in sequence, neighboring nodes will cause load imbalance.</li>
<li>Result pre-allocation.</li>
<li>Delayed set insertion.</li>
<li>Non-STL sets.preallocate a vector with a size of potential matches.</li>
</ol>


<p>Overall Speedup = 60x: 204ms->3.5ms, 3s->50ms</p>

<h3>3.2 Algo2:</h3>

<ul>
<li>Input: HTML tree nodes with symbolic constraint attributes</li>
<li>Output: layout actual details (size, shape, position)</li>
</ul>


<p>Because CSS is confusing and informally-writtened, we create a new simple, concise, uniform, and intermediate language, Berkeley Style Sheets (BBS), which is transformed from CSS and will be specified with an attribute grammar (which shows potential for parallelization).</p>

<p>Three contributions:</p>

<ol>
<li>Increase performance. decompse the tasks.</li>
<li>Uniform a correct, concise specification.</li>
<li>Prove it is at most linear in the size of HTML tree.</li>
</ol>


<p><strong>PARALLELIZATION</strong></p>

<p>Two steps recursively for every node in the DOM tree</p>

<ol>
<li>calculate inherited attributes (top-down). Every level of childs in the tree enjoyes the parallelization.</li>
<li>calculate synthesized attributes (node&#8217;s own attributes) (bottom-up). Every level of parents in the tree enjoys the parallelization.</li>
</ol>


<p>2 is dependent on 1.</p>

<p>Complexity: O(log)</p>

<p>Speedup of box + text layout = 2-3x</p>

<p>Advanced layouts: floats</p>

<h3>3.3 Algo3: Font Handling</h3>

<ol>
<li>create a pool of necessary font library request</li>
<li>group the requests</li>
<li>make parallel calls to process each group</li>
</ol>


<h2>4. Conclusions</h2>

<p>Address three bottlenecks of loading a page</p>

<ol>
<li>CSS selector matching

<ul>
<li>Pre-built hash tables, map-reduce</li>
</ul>
</li>
<li>Box and text layout solving

<ul>
<li>Specify layout as attribute grammars</li>
</ul>
</li>
<li>Glyph rendering

<ul>
<li>Combine requests to groups and render in parallel</li>
</ul>
</li>
</ol>


<p>Milestone in building a parallel and mobile browser</p>
]]></content>
  </entry>
  
</feed>
